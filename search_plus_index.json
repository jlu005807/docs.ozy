{"./":{"url":"./","title":"Introduction","keywords":"","body":" docs.ozy docs.ozy 你好，这里是一位计算机专业的普通学生的文档站点，记录本人的学习。 内容包括 C++、数据结构与算法、操作系统、命令行工具，计算机组成原理等，希望你可以从中学习和参考。 这里有我呕心沥血整理但是不保绝对正确和高分的学习笔记以及摸着石头过河编写的一大堆乱七八糟的不规范代码。 所以建议大家谨慎浏览不要在意过多的细节，当然如果发现问题可以告诉我进行整改，在这里先谢谢提供建议的你。 最后，这是我的主页ozy.website，里面有我的介绍和一些想法，欢迎大家访问和浏览 想交流或反馈问题？ 可以直接在页面下的评论区发表你的建议。 在docs.ozy打开 Issue。我也欢迎 PR 和改进建议。 发邮件到：1289406660@qq.com 如果我的内容对你有所帮助，或者你真的从中学习到了知识，不妨请我喝一杯奶茶 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - Introduction "},"docs/计算机教育中缺失的一课/":{"url":"docs/计算机教育中缺失的一课/","title":"计算机教育中缺失的一课","keywords":"","body":" 计算机教育中缺失的一课 计算机教育中缺失的一课 本文件夹收集了实用且面向初学者的工具与方法，目的是弥补课堂教学中常被忽视但对实际工作很有用的技能。 如果你是一名计算机专业的学生，我十分建议你结合the missing semester of your cs education学习完当前笔记。 虽然内容并不简单，但是我认为每一个计算机的学生都必须了解这些知识，尽管你可能在学习的初期使用不到这些知识和工具，但我相信，在你真正进入计算机领域的大门后会发现这些内容的重要性甚至是必要性。 [!tip] 建议首先学习当前笔记，然后再去学习相关高级语言以及数据结构和算法 章节简介： 01_the_shell.md：介绍命令行（终端）基础，教你如何在命令行里做文件操作、查看内容和运行程序。 02_Shell_Tools_and_Scripting.md：介绍常用的命令行工具和简单脚本，帮你把重复工作自动化。 03_ Editors (Vim).md：讲一个常用编辑器的基本使用方法（如 Vim），让你不用鼠标也能高效编辑文件。 04_Data_Wrangling.md：说明如何清理和整理数据，方便后续分析或处理。 05_ Command-line Environment.md：介绍设置和优化命令行工作环境的小技巧，提升效率。 06_ Version Control (Git).md：讲版本控制的基本概念和常用操作，让你能管理代码历史并与他人协作。 07_Debugging and Profiling.md：介绍调试程序和分析性能的基本方法，帮助你找到并修复问题。 08_Metaprogramming.md：用通俗语言介绍元编程的想法（写能写代码的代码），理解后能写出更通用的工具。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 计算机教育中缺失的一课 "},"docs/计算机教育中缺失的一课/01_the_shell.html":{"url":"docs/计算机教育中缺失的一课/01_the_shell.html","title":"01_the_shell","keywords":"","body":" the Shell 使用Shell 在 shell 中导航 文件权限 在程序间创建连接 一个功能全面又强大的工具 课后习题 the Shell shell 是什么？ 文字接口：Shell 允许你执行程序，输入并获取某种半结构化的输出 使用Shell 打开终端，看到一个提示符:missing:~$ shell 是最主要的文本接口 主机名是 missing 当前的工作目录（”current working directory”）或者说您当前所在的位置是 ~ (表示 “home”) $ 符号表示您现在的身份不是 root 用户 传递的参数中包含空格（例如一个名为 My Photos 的文件夹），用使用单引号，双引号将其包裹起来，要么使用转义符号 \\ 进行处理（My\\ Photos）。 missing:~$ date Fri 10 Jan 2020 11:49:31 AM EST missing:~$ echo hello hello 对于命令date 和 echo,shell 是一个编程环境，所以它具备变量、条件、循环和函数，在 shell 中执行命令时，您实际上是在执行一段 shell 可以解释执行的简短代码，该指令并不是 shell 所了解的编程关键字，那么它会去咨询 环境变量 $PATH missing:~$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin missing:~$ which echo /bin/echo missing:~$ /bin/echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin 例如：执行 echo 命令时，shell 会在 $PATH 中搜索由 : 所分割的一系列目录，基于名字搜索该程序。（定某个程序名代表的是哪个具体的程序，可以使用 which 程序）。 所以我们也可以绕过 $PATH，通过直接指定需要执行的程序的路径来执行该程序 在 shell 中导航 shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用 / 分割 路径 / 代表的是系统的根目录 某个路径以 / 开头，那么它是一个 绝对路径 不是以/开头的其他的都是 相对路径，相对路径是指相对于当前工作目录的路径 当前工作目录可以使用 pwd 命令来获取 切换目录需要使用 cd 命令。在路径中，. 表示的是当前目录，而 .. 表示上级目录： missing:~$ pwd /home/missing missing:~$ cd /home missing:/home$ pwd /home missing:/home$ cd .. missing:/$ pwd / missing:/$ cd ./home missing:/home$ pwd /home missing:/home$ cd missing missing:~$ pwd /home/missing missing:~$ ../../bin/echo hello hello mv（用于重命名或移动文件）、 cp（拷贝文件）以及 mkdir（新建文件夹） man 这个程序。它会接受一个程序名作为参数，然后将它的文档（用户手册）展现 文件权限 missing:~$ ls -l /home drwxr-xr-x 1 missing users 4096 Jun 15 2019 missing 第一栏共有十个字符，第一栏代表这个文件的类型与权限(permission)： 第一个字符代表这个文件是『目录、文件或链接文件等等』： 当为[ d ]则是目录，例如上表档名为『.gconf』的那一行； 当为[ - ]则是文件，例如上表档名为『install.log』那一行； 若是[ l ]则表示为连结档(link file)； 若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。 下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。 [ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 第一组为『文件拥有者的权限』； 第二组为『同群组的权限』； 第三组为『其他非本群组的权限』。 第二栏表示有多少档名连结到此节点(i-node) 第三栏表示这个文件(或目录)的『拥有者账号』 第四栏表示这个文件的所属群组 第五栏为这个文件的容量大小，默认单位为bytes； 第六栏为这个文件的建档日期或者是最近的修改日期 第七栏为这个文件的档名 如果档名之前多一个『 . 』，则代表这个文件为『隐藏档』 [!note] 权限意义 权限对于文件：文件是实际含有数据的地方，包括一般文本文件、数据库内容文件、二进制可执行文件(binary program)等等 r (read)：可读取此一文件的实际内容，如读取文本文件的文字内容等； w (write)：可以编辑、新增或者是修改该文件的内容(但不含删除该文件)； x (execute)：该文件具有可以被系统执行的权限。 权限对于目录：目录主要的内容在记录文件名列表，文件名与目录有强烈的关连 r (read contents in directory)： 表示具有读取目录结构列表的权限，表示你可以查询该目录下的文件名数据。 w (modify contents of directory) 具有异动该目录结构列表的权限，也就是底下这些权限： 建立新的文件与目录； 删除已经存在的文件与目录(不论该文件的权限为何！) 将已存在的文件或目录进行更名； 搬移该目录内的文件、目录位置。 总之，目录的w权限就与该目录底下的文件名异动有关 x (access directory)： 目录的x代表的是用户能否进入该目录成为工作目录的用途！ 所谓的工作目录(work directory)就是你目前所在的目录 在程序间创建连接 在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。 当程序尝试读取信息时，它们会从输入流中进行读取 当程序打印信息时，它们会将信息输出到输出流中 通常，一个程序的输入输出流都是您的终端 最简单的重定向是 和 > file 还可以使用 >> 来向一个文件追加内容。 | 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来 missing:~$ ls -l / | tail -n1 drwxr-xr-x 1 root root 4096 Jun 20 2019 var missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=' ' -f2 219 一个功能全面又强大的工具 根用户（root user） 用户几乎不受任何限制，他可以创建、读取、更新和删除系统中的任何文件 sudo 命令：可以以 su（super user 或 root 的简写）的身份执行一些操作 课后习题 本课程需要使用类 Unix shell，例如 Bash 或 ZSH。如果您在 Linux 或者 MacOS 上面完成本课程的练习，则不需要做任何特殊的操作。如果您使用的是 Windows，则您不应该使用 cmd 或是 Powershell；您可以使用 Windows Subsystem for Linux 或者是 Linux 虚拟机。使用 echo $SHELL 命令可以查看您的 shell 是否满足要求。如果打印结果为 /bin/bash 或 /usr/bin/zsh 则是可以的。 在 /tmp 下新建一个名为 missing 的文件夹。 用 man 查看程序 touch 的使用手册。 用 touch 在 missing 文件夹中新建一个叫 semester 的文件。 将以下内容一行一行地写入 semester 文件： #!/bin/sh curl --head --silent https://missing.csail.mit.edu 第一行可能有点棘手， # 在 Bash 中表示注释，而 ! 即使被双引号（\"）包裹也具有特殊的含义。 单引号（'）则不一样，此处利用这一点解决输入问题。更多信息请参考 Bash quoting 手册 尝试执行这个文件。例如，将该脚本的路径（./semester）输入到您的 shell 中并回车。如果程序无法执行，请使用 ls 命令来获取信息并理解其不能执行的原因。 查看 chmod 的手册(例如，使用 man chmod 命令) 使用 chmod 命令改变权限，使 ./semester 能够成功执行，不要使用 sh semester 来执行该程序。您的 shell 是如何知晓这个文件需要使用 sh 来解析呢？更多信息请参考：shebang) 使用 | 和 > ，将 semester 文件输出的最后更改日期信息，写入主目录下的 last-modified.txt 的文件中 ./semester |grep \"last-modified\" > last-modified.txt ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 01_the_shell "},"docs/计算机教育中缺失的一课/02_Shell_Tools_and_Scripting.html":{"url":"docs/计算机教育中缺失的一课/02_Shell_Tools_and_Scripting.html","title":"02_Shell_Tools_and_Scripting","keywords":"","body":" Shell工具和脚本 变量赋值 函数 输入输出 test命令 Shell流程控制 if else· for循环 while循环 until循环 case ... esac 跳出循环 Shell通配符 shebang(#!) Shell特点 Shell工具 查看命令如何使用 查找文件 查找代码 查找 shell 命令 文件夹导航 习题 Shell工具和脚本 [!tip] 大多数 shell 都有自己的一套脚本语言，包括变量、控制流和自己的语法。 创建命令流程（pipelines）、将结果保存到文件、从标准输入中读取输入，这些都是 shell 脚本中的原生操作，这让它比通用的脚本语言更易用。 变量赋值 [!important] 在 bash 中为变量赋值的语法是 foo=bar，访问变量中存储的数值，其语法为 $foo。 [!warning] 注意的是，foo = bar （使用空格隔开）是不能正确工作的，因为解释器会调用程序 foo 并将 = 和 bar 作为参数 在 shell 脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆，请务必多加检查。 字符串通过 ' 和 \" 分隔符来定义 以 ' 定义的字符串为原义字符串，其中的变量不会被转义 而 \" 定义的字符串会将变量值进行替换。 foo=bar echo \"$foo\" # 打印 bar echo '$foo' # 打印 $foo 函数 bash 也支持函数，它可以接受参数并基于参数进行操作。 mcd () { mkdir -p \"$1\" cd \"$1\" } $1 是脚本的第一个参数 [!tip] bash 使用了很多特殊的变量来表示参数、错误代码和相关变量。 $0 - 脚本名 $1 到 $9 - 脚本的参数。 $1 是第一个参数，依此类推。 $@ - 所有参数 $# - 参数个数 $? - 前一个命令的返回值 $$ - 当前脚本的进程识别码 !! - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 sudo !! 再尝试一次。 $_ - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 Esc 之后键入 . 来获取这个值。 输入输出 命令通常使用 STDOUT 来返回输出值，使用 STDERR 来返回错误及错误码，便于脚本以更加友好的方式报告错误。 返回值 0 表示正常执行，其他所有非 0 的返回值都表示有错误发生。 退出码可以搭配 &&（与操作符）和 ||（或操作符）使用，用来进行条件判断，决定是否执行其他程序。 它们都属于短路 运算符（short-circuiting） 同一行的多个命令可以用 ; 分隔。 程序 true 的返回码永远是 0，false 的返回码永远是 1。 false || echo \"Oops, fail\" # Oops, fail true || echo \"Will not be printed\" # true && echo \"Things went well\" # Things went well false && echo \"Will not be printed\" # false ; echo \"This will always run\" # This will always run 以变量的形式获取一个命令的输出，这可以通过 命令替换（command substitution）实现。 通过 $( CMD ) 这样的方式来执行 CMD 这个命令时，它的输出结果会替换掉 $( CMD ) 一个冷门的类似特性是 进程替换（process substitution）， 会执行 CMD 并将结果输出到一个临时文件中，并将 替换成临时文件名。 #!/bin/bash echo \"Starting program at $(date)\" # date会被替换成日期和时间 echo \"Running program $0 with $# arguments with pid $$\" for file in \"$@\"; do grep foobar \"$file\" > /dev/null 2> /dev/null # 如果模式没有找到，则grep退出状态为 1 # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息 if [[ $? -ne 0 ]]; then echo \"File $file does not have any foobar, adding one\" echo \"# foobar\" >> \"$file\" fi done 使用 grep 搜索字符串 foobar，如果没有找到，则将其作为注释追加到文件中。 test命令 [!important] Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。 数值测试 代码中的 [] 执行基本的算数运算 | 参数 | 说明 | | :--- | :------------- | | -eq | 等于则为真 | | -ne | 不等于则为真 | | -gt | 大于则为真 | | -ge | 大于等于则为真 | | -lt | 小于则为真 | | -le | 小于等于则为真 | num1=100 num2=100 if test $[num1] -eq $[num2] then echo '两个数相等！' else echo '两个数不相等！' fi #!/bin/bash a=5 b=6 result=$[a+b] # 注意等号两边不能有空格 echo \"result 为： $result\" 字符串测试 | = | 等于则为真 | | --------- | ------------------------ | | != | 不相等则为真 | | -z 字符串 | 字符串的长度为零则为真 | | -n 字符串 | 字符串的长度不为零则为真 | num1=\"ru1noob\" num2=\"runoob\" if test $num1 = $num2 then echo '两个字符串相等!' else echo '两个字符串不相等!' fi 文件测试 | 参数 | 说明 | | :-------- | :----------------------------------- | | -e 文件名 | 如果文件存在则为真 | | -r 文件名 | 如果文件存在且可读则为真 | | -w 文件名 | 如果文件存在且可写则为真 | | -x 文件名 | 如果文件存在且可执行则为真 | | -s 文件名 | 如果文件存在且至少有一个字符则为真 | | -d 文件名 | 如果文件存在且为目录则为真 | | -f 文件名 | 如果文件存在且为普通文件则为真 | | -c 文件名 | 如果文件存在且为字符型特殊文件则为真 | | -b 文件名 | 如果文件存在且为块特殊文件则为真 | cd /bin if test -e ./bash then echo '文件已存在!' else echo '文件不存在!' fi 其他 Shell 还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为： ! 最高， -a 次之， -o 最低。 cd /bin if test -e ./notFile -o -e ./bash then echo '至少有一个文件存在!' else echo '两个文件都不存在' fi Shell流程控制 if else· if 语句语法格式： if condition then command1 command2 ... commandN fi if else 语法格式： if condition then command1 command2 ... commandN else command fi if else-if else 语法格式： if condition1 then command1 elif condition2 then command2 else commandN fi [!tip] [...] 判断语句中大于使用 -gt，小于使用 -lt。 ((...)) 作为判断语句，大于和小于可以直接使用 > 和 。 for循环 for循环一般格式为： for var in item1 item2 ... itemN do command1 command2 ... commandN done [!tip] in 列表可以包含替换、字符串和文件名。 in列表是可选的，如果不用它，for循环使用命令行的位置参数。 while循环 while 循环用于不断执行一系列命令，也用于从输入文件中读取数据。其语法格式为： while condition do command done [!tip] while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按结束循环。 echo '按下 退出' echo -n '输入你最喜欢的网站名: ' while read FILM do echo \"是的！$FILM 是一个好网站\" done 无限循环 无限循环语法格式： while : do command done 或者 while true do command done 或者 for (( ; ; )) until循环 until 循环执行一系列命令直至条件为 true 时停止。 until 语法格式: until condition do command done case ... esac case ... esac 为多选择语句， 每个 case 分支用右圆括号开始，用两个分号 ;; 表示 break，即执行结束，跳出整个 case ... esac 语句，esac（就是 case 反过来）作为结束标记。 case ... esac 语法格式如下： case 值 in 模式1) command1 command2 ... commandN ;; 模式2) command1 command2 ... commandN ;; esac 跳出循环 break 命令 break 命令允许跳出所有循环（终止执行后面的所有循环）。 continue continue 命令与 break 命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。 Shell通配符 [!note] 通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 ? 和 * 来匹配一个或任意个字符。 例如，对于文件 foo, foo1, foo2, foo10 和 bar, rm foo? 这条命令会删除 foo1 和 foo2 ，而 rm foo* 则会删除除了 bar 之外的所有文件。 花括号 {} - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。 convert image.{png,jpg} # 会展开为 convert image.png image.jpg cp /path/to/project/{foo,bar,baz}.sh /newpath # 会展开为 cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath # 也可以结合通配使用 mv *{.py,.sh} folder # 会移动所有 *.py 和 *.sh 文件 mkdir foo bar # 下面命令会创建 foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h 这些文件 touch {foo,bar}/{a..h} touch foo/x bar/y # 比较文件夹 foo 和 bar 中包含文件的不同 diff y shebang(#!) 在Shebang之后，可以有一个或数个空白字符，后接解释器的绝对路径，用于指明执行这个脚本文件的解释器。 在 shebang 行中使用 env 命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，这样就提高了您的脚本的可移植性。 Shell特点 [!note] 函数只能与 shell 使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 shebang 是很重要的。 函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。 函数会在当前的 shell 环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 export 将环境变量导出，并将值传递给环境变量。 与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell 脚本中往往也会包含它们自己的函数定义。 Shell工具 查看命令如何使用 最常用的方法是为对应的命令行添加 -h 或 --help 标记。 另外一个更详细的方法则是使用 man 命令。man 命令是手册（manual）的缩写，它提供了命令的用户手册。 TLDR pages （tldr命令） 查找文件 find 命令会递归地搜索符合条件的文件，例如： # 查找所有名称为src的文件夹 find . -name src -type d # 查找所有文件夹路径中包含test的python文件 find . -path '*/test/*.py' -type f # 查找前一天修改的所有文件 find . -mtime -1 # 查找所有大小在500k至10M的tar.gz文件 find . -size +500k -size -10M -name '*.tar.gz' [!tip] find 还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。 # 删除全部扩展名为.tmp 的文件 find . -name '*.tmp' -exec rm {} \\; # 查找全部的 PNG 文件并将其转换为 JPG find . -name '*.png' -exec convert {} {}.jpg \\; fd 就是一个更简单、更快速、更友好的程序，它可以用来作为 find 的替代品。 locate 使用一个由 updatedb 负责更新的数据库，在大多数系统中 updatedb 都会通过 cron 每日更新 查找代码 grep 命令，它是用于对输入文本进行匹配的通用工具。 grep 有很多选项 -C ：获取查找结果的上下文（Context）； -v 将对结果进行反选（Invert），也就是输出不匹配的结果。 grep -C 5 会输出匹配结果前后五行。 -R 会递归地进入子目录并搜索所有的文本文件。 查找 shell 命令 history 命令允许您以程序员的方式来访问 shell 中输入的历史命令。 利用管道将输出结果传递给 grep 进行模式搜索。 history | grep find 会打印包含 find 子串的命令。 使用 Ctrl+R 对命令历史记录进行回溯搜索。敲 Ctrl+R 后您可以输入子串来进行匹配，查找历史命令行。 使用方向键上或下也可以完成这项工作。 Ctrl+R 可以配合 fzf 使用。fzf 是一个通用的模糊查找工具 文件夹导航 使用 fasd 和 autojump 这两个工具来查找最常用或最近使用的文件和目录。 习题 阅读 man ls ，然后使用 ls 命令进行如下操作： 所有文件（包括隐藏文件） 文件打印以人类可以理解的格式输出 (例如，使用 454M 而不是 454279954) 文件以最近访问顺序排序 以彩色文本显示输出结果 典型输出如下： -rw-r--r-- 1 user group 1.1M Jan 14 09:53 baz drwxr-xr-x 5 user group 160 Jan 14 09:53 . -rw-r--r-- 1 user group 514 Jan 14 06:42 bar -rw-r--r-- 1 user group 106M Jan 13 12:12 foo drwx------+ 47 user group 1.5K Jan 12 18:08 .. //ans ls -a -l -h -t --color=auto 编写两个 bash 函数 marco 和 polo 执行下面的操作。 每当你执行 marco 时，当前的工作目录应当以某种形式保存，当执行 polo 时，无论现在处在什么目录下，都应当 cd 回到当时执行 marco 的目录。 为了方便 debug，你可以把代码写在单独的文件 marco.sh 中，并通过 source marco.sh 命令，（重新）加载函数。 #!/bin/bash marco() { export MARCO=$(pwd) } polo() { cd \"$MARCO\" } 假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段 bash 脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。 #!/usr/bin/env bash n=$(( RANDOM % 100 )) if [[ n -eq 42 ]]; then echo \"Something went wrong\" >&2 echo \"The error was using magic numbers\" exit 1 fi echo \"Everything went according to plan\" #ans #!/usr/bin/env bash count=0 echo > out.log while true do ./buggy &>> out.log if [[ $? -ne 0 ]]; then cat out.log echo \"failed after $count times\" break fi ((count++)) done 本节课我们讲解的 find 命令中的 -exec 参数非常强大，它可以对我们查找的文件进行操作。但是，如果我们要对所有文件进行操作呢？例如创建一个 zip 压缩文件？我们已经知道，命令行可以从参数或标准输入接受输入。在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如 tar 则需要从参数接受输入。这里我们可以使用 xargs 命令，它可以使用标准输入中的内容作为参数。 例如 ls | xargs rm 会删除当前目录中的所有文件。 您的任务是编写一个命令，它可以递归地查找文件夹中所有的 HTML 文件，并将它们压缩成 zip 文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行（提示：查看 xargs 的参数 -d，译注：MacOS 上的 xargs 没有 -d，查看这个 issue） 如果您使用的是 MacOS，请注意默认的 BSD find 与 GNU coreutils 中的是不一样的。你可以为 find 添加 -print0 选项，并为 xargs 添加 -0 选项。作为 Mac 用户，您需要注意 mac 系统自带的命令行工具和 GNU 中对应的工具是有区别的；如果你想使用 GNU 版本的工具，也可以使用 brew 来安装。 find . -type f -name \"*.html\" -print0 | xargs -d tar -cvzf html.zip （进阶）编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？ find . -type f -mmin -60 -print0 | xargs -0 ls -lt | head -10 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 02_Shell_Tools_and_Scripting "},"docs/计算机教育中缺失的一课/04_Data_Wrangling.html":{"url":"docs/计算机教育中缺失的一课/04_Data_Wrangling.html","title":"04_Data_Wrangling","keywords":"","body":" 数据整理 日志处理 sed 正则表达式 回到数据整理 awk 分析数据 数据整理 不断地对数据进行处理，直到得到我们想要的最终结果。 在之前的课程中，其实我们已经接触到了一些数据整理的基本技术。可以这么说，每当您使用管道运算符的时候，其实就是在进行某种形式的数据整理。 [!tip] journalctl | grep -i intel 它会找到所有包含 intel（不区分大小写）的系统日志。 将某种形式的数据（全部系统日志）转换成了另外一种形式的数据（仅包含 intel 的日志） 日志处理 日志处理通常是一个比较典型的使用场景，因为我们经常需要在日志中查找某些信息，这种情况下通读日志是不现实的。 看看哪些用户曾经尝试过登录我们的服务器并且把涉及 sshd 的信息过滤出来： ssh myserver journalctl | grep sshd 注意，这里我们使用管道将一个远程服务器上的文件传递给本机的 grep 程序 ssh myserver 'journalctl | grep sshd | grep \"Disconnected from\"' | less 采取另外一种方式，我们先在远端机器上过滤文本内容，然后再将结果传输到本机。 less 为我们创建来一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。 甚至可以将当前过滤出的日志保存到文件中，这样后续就不需要再次通过网络访问该文件了： $ ssh myserver 'journalctl | grep sshd | grep \"Disconnected from\"' > ssh.log $ less ssh.log sed [!note] sed 是一个基于文本编辑器 ed 构建的 “流编辑器” 。 在 sed 中，基本上是利用一些简短的命令来修改文件，而不是直接操作文件的内容 [!important] 最常用的是 s，即 替换 命令，例如我们可以这样写： ssh myserver journalctl | grep sshd | grep \"Disconnected from\" | sed 's/.*Disconnected from //' s 命令的语法如下：s/REGEX/SUBSTITUTION/, 其中 REGEX 部分是我们需要使用的正则表达式，而 SUBSTITUTION 是用于替换匹配结果的文本。 正则表达式 从这一句正则表达式开始学习： /.*Disconnected from / [!note] 不同字符所表示的含义，根据正则表达式的实现方式不同，也会有所变化，这一点确实令人沮丧。常见的模式有： . 除换行符之外的 “任意单个字符” * 匹配前面字符零次或多次 + 匹配前面字符一次或多次 [abc] 匹配 a, b 和 c 中的任意一个 (RX1|RX2) 任何能够匹配 RX1 或 RX2 的结果 ^ 行首 $ 行尾 [!tip] sed 的正则表达式需要你在这些模式前添加 \\ 才能使其具有特殊含义。 也可以添加 -E 选项来支持这些匹配 注意：这里是因为正则表达式不同版本要求不同 [!warning] 某些正则表达式的实现来说，您可以给 * 或 + 增加一个 ? 后缀使其变成非贪婪模式，但是很可惜 sed 并不支持该后缀 可以切换到 perl 的命令行模式，该模式支持编写这样的正则表达式： perl -pe 's/.*?Disconnected from //' 匹配用户名后面的文本，尤其是当这里的用户名可以包含空格时，这个问题变得非常棘手！这里我们需要做的是匹配 一整行： | sed -E 's/.*Disconnected from (invalid |authenticating )?user .* [^ ]+ [^ ]+ 会匹配任意非空且不包含空格的序列 我们实际上希望能够将用户名保留 下来。 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' 对此，我们可以使用“捕获组（capture groups）”来完成。被圆括号内的正则表达式匹配到的文本，都会被存入一系列以编号区分的捕获组中。捕获组的内容可以在替换字符串时使用（有些正则表达式的引擎甚至支持替换表达式本身），例如 \\1、 \\2、\\3 等等 回到数据整理 [!tip] ssh myserver journalctl | grep sshd | grep \"Disconnected from\" | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' sed ：(使用 i 命令)，打印特定的行 ,(使用 p 命令)，基于索引选择特定行 过滤出那些最常出现的用户 [!note] ssh myserver journalctl | grep sshd | grep \"Disconnected from\" | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c | sort -nk1,1 | tail -n10 sort 会对其输入数据进行排序。 uniq -c 会把连续出现的行折叠为一行并使用出现次数作为前缀 -n 会按照数字顺序对输入进行排序（默认情况下是按照字典序排序 -k1,1 则表示“仅基于以空格分割的第一列进行排序”。 n 部分表示“仅排序到第 n 个部分”，默认情况是到行尾。 希望得到登录次数最少的用户，我们可以使用 head 来代替 tail。或者使用 sort -r 来进行倒序排序。 只想获取用户名，而且不要一行一个地显示 ssh myserver journalctl | grep sshd | grep \"Disconnected from\" | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c | sort -nk1,1 | tail -n10 | awk '{print $2}' | paste -sd, paste 命令来合并行(-s)，并指定一个分隔符进行分割 (-d) awk awk 其实是一种编程语言，只不过它碰巧非常善于处理文本。 [!note] awk 程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作 默认当模式串即匹配所有行（上面命令中当用法）( {print $2} ) 其中： 代码块中，$0 表示整行的内容，$1 到 $n 为一行中的 n 个区域，区域的分割基于 awk 的域分隔符（默认是空格，可以通过 -F 来修改） 统计一下所有以 c 开头，以 e 结尾，并且仅尝试过一次登录的用户。 | awk '$1 == 1 && $2 ~ /^c[^ ]*e$/ { print $2 }' | wc -l 该匹配要求文本的第一部分需要等于 1（这部分刚好是 uniq -c 得到的计数值） 第二部分必须满足给定的一个正则表达式 代码块中的内容则表示打印用户名 wc -l 统计输出结果的行数 awk 是一种编程语言 BEGIN { rows = 0 } $1 == 1 && $2 ~ /^c[^ ]*e$/ { rows += $1 } END { print rows } BEGIN 也是一种模式，它会匹配输入的开头（ END 则匹配结尾） 对每一行第一个部分进行累加，最后将结果输出 分析数据 将每行数字加起来： | paste -sd+ | bc -l #或者 echo \"2*($(data | paste -sd+))\" | bc -l R语言的st ssh myserver journalctl | grep sshd | grep \"Disconnected from\" | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c | awk '{print $1}' | R --slave -e 'x R 也是一种编程语言，适合被用来进行数据分析和 绘制图表 gnuplot绘图 绘制一些简单的图表， gnuplot 可以帮助到您： ssh myserver journalctl | grep sshd | grep \"Disconnected from\" | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c | sort -nk1,1 | tail -n10 | gnuplot -p -e 'set boxwidth 0.5; plot \"-\" using 1:xtic(2) with 利用数据整理确定参数 利用数据整理技术从一长串列表里找出你所需要安装或移除的东西 使用xargs实现 rustup toolchain list | grep nightly | grep -vE \"nightly-x86\" | sed 's/-x86.*//' | xargs rustup toolchain uninstall 整理二进制数据 可以用 ffmpeg 从相机中捕获一张图片，将其转换成灰度图后通过 SSH 将压缩后的文件发送到远端服务器，并在那里解压、存档并显示。 ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 - | convert - -colorspace gray - | gzip | ssh mymachine 'gzip -d | tee copy.jpg | env DISPLAY=:0 feh -' ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 04_Data_Wrangling "},"docs/计算机教育中缺失的一课/05_Command-line_Environment.html":{"url":"docs/计算机教育中缺失的一课/05_Command-line_Environment.html","title":"05_Command-line Environment","keywords":"","body":" 命令行环境 任务控制 结束进程 暂停和后台执行进程 终端多路复用 别名 配置文件（Dotfiles） 概念 版本控制 可移植性 远程设备 执行命令 SSH密钥 密钥生成 基于密钥的认证机制 通过SSH复制文件 端口转发 SSH配置 杂项 命令行环境 同时执行多个不同的进程并追踪它们的状态、如何停止或暂停某个进程以及如何使进程在后台运行 改善您的 shell 及其他工具的工作流：定义别名或基于配置文件对其进行配置 如何使用 SSH 操作远端机器 任务控制 中断正在执行的任务：大多数情况下，可以使用 Ctrl-C 来停止命令的执行 结束进程 shell 会使用 UNIX 提供的信号机制执行进程间通信 一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。信号是一种 软件中断。 输入 Ctrl-C 时，shell 会发送一个 SIGINT 信号到进程。 Python 程序向您展示了捕获信号 SIGINT 并忽略它的基本操作，它并不会让程序停止。 为了停止这个程序，我们需要使用 SIGQUIT 信号，通过输入 Ctrl-\\ 可以发送该信号 #!/usr/bin/env python import signal, time def handler(signum, time): print(\"\\nI got a SIGINT, but I am not stopping\") signal.signal(signal.SIGINT, handler) i = 0 while True: time.sleep(.1) print(\"\\r{}\".format(i), end=\"\") i += 1 SIGINT 和 SIGQUIT 都常常用来发出和终止程序相关的请求。SIGTERM 则是一个更加通用的、也更加优雅地退出信号 其中 kill -TERM 发出SIGTERM信号 暂停和后台执行进程 Ctrl-Z SIGSTOP 会让进程暂停。在终端中，键入 Ctrl-Z 会让 shell 发送 SIGTSTP 信号，SIGTSTP 是 Terminal Stop 的缩写（即 terminal 版本的 SIGSTOP）。 fg 或 bg 同时可以使用 fg 或 bg 命令恢复暂停的工作。它们分别表示在前台继续或在后台继续。 jobs 命令会列出当前终端会话中尚未完成的全部任务 以使用 pid 引用这些任务（也可以用 pgrep 找出 pid） 更加符合直觉的操作是您可以使用百分号 + 任务编号（jobs 会打印任务编号）来选取该任务。如果要选择最近的一个任务，可以使用 $! 这一特殊参数。 &命令后缀 命令中的 & 后缀可以让命令在直接在后台运行，这使得您可以直接在 shell 中继续做其他操作，不过它此时还是会使用 shell 的标准输出，这一点有时会比较恼人（这种情况可以使用 shell 重定向处理）。 让已经在运行的进程转到后台运行， Ctrl-Z +bg。 注意，后台的进程仍然是您的终端进程的子进程，一旦您关闭终端（会发送另外一个信号 SIGHUP），这些后台的进程也会终止 nohup 一个用来忽略 SIGHUP 的封装）来运行程序。针对已经运行的程序，可以使用 disown 下面这个简单的会话中展示来了些概念的应用。 $ sleep 1000 ^Z [1] + 18653 suspended sleep 1000 $ nohup sleep 2000 & [2] 18745 appending output to nohup.out $ jobs [1] + suspended sleep 1000 [2] - running nohup sleep 2000 $ bg %1 [1] - 18653 continued sleep 1000 $ jobs [1] - running sleep 1000 [2] + running nohup sleep 2000 $ kill -STOP %1 [1] + 18653 suspended (signal) sleep 1000 $ jobs [1] + suspended (signal) sleep 1000 [2] - running nohup sleep 2000 $ kill -SIGHUP %1 [1] + 18653 hangup sleep 1000 $ jobs [2] + running nohup sleep 2000 $ kill -SIGHUP %2 $ jobs [2] + running nohup sleep 2000 $ kill %2 [2] + 18745 terminated nohup sleep 2000 $ jobs [!tip] SIGKILL 是一个特殊的信号，它不能被进程捕获并且它会马上结束该进程。不过这样做会有一些副作用，例如留下孤儿进程。 终端多路复用 tmux 这类的终端多路复用器可以允许我们基于面板和标签分割出多个终端窗口，这样您便可以同时与多个 shell 会话进行交互。 tmux 的快捷键需要我们掌握，它们都是类似 x 这样的组合 即需要先按下 Ctrl+a，松开后再按下 x。 tmux 中对象的继承结构如下： [!note] 会话 - 每个会话都是一个独立的工作区，其中包含一个或多个窗口 tmux 开始一个新的会话 tmux new -s NAME 以指定名称开始一个新的会话 tmux ls 列出当前所有会话 在 tmux 中输入 d ，将当前会话分离 tmux a 重新连接最后一个会话。您也可以通过 -t 来指定具体的会话 窗口 - 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分 c 创建一个新的窗口，使用 关闭 N 跳转到第 N 个窗口，注意每个窗口都是有编号的 p 切换到前一个窗口 n 切换到下一个窗口 , 重命名当前窗口 w 列出当前所有窗口 面板 - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell - 水平分割 | 垂直分割 / Alt 切换到指定方向的面板， 指的是键盘上的方向键 z 切换当前面板的缩放 [ 开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分 在不同的面板排布间切换 别名 shell 的别名相当于一个长命令的缩写，shell 会自动将其替换成原本的命令。例如，bash 中的别名语法如下： alias alias_name=\"command_to_alias arg1 arg2\" 注意， = 两边是没有空格的，因为 alias 是一个 shell 命令，它只接受一个参数。 # 创建常用命令的缩写 alias ll=\"ls -lh\" # 能够少输入很多 alias gs=\"git status\" alias gc=\"git commit\" alias v=\"vim\" # 手误打错命令也没关系 alias sl=ls # 重新定义一些命令行的默认行为 alias mv=\"mv -i\" # -i prompts before overwrite alias mkdir=\"mkdir -p\" # -p make parent dirs as needed alias df=\"df -h\" # -h prints human readable format # 别名可以组合使用 alias la=\"ls -A\" alias lla=\"la -l\" # 在忽略某个别名 \\ls # 或者禁用别名 unalias la # 获取别名的定义 alias ll # 会打印 ll='ls -lh' 值得注意的是，在默认情况下 shell 并不会保存别名。为了让别名持续生效，您需要将配置放进 shell 的启动文件里，像是 .bashrc 或 .zshrc 配置文件（Dotfiles） 概念 多程序的配置都是通过纯文本格式的被称作 点文件 的配置文件来完成的（之所以称为点文件，是因为它们的文件名以 . 开头，例如 ~/.vimrc。也正因为此，它们默认是隐藏文件，ls 并不会显示它们） shell 程序会读取很多文件以加载其配置项。根据 shell 本身的不同，您从登录开始还是以交互的方式完成这一过程可能会有很大的不同。 对于 bash 来说，在大多数系统下，您可以通过编辑 .bashrc 或 .bash_profile 来进行配置。 实际上，很多程序都要求您在 shell 的配置文件中包含一行类似 export PATH=\"$PATH:/path/to/program/bin\" 的命令 [!tip] bash - ~/.bashrc, ~/.bash_profile git - ~/.gitconfig vim - ~/.vimrc 和 ~/.vim 目录 ssh - ~/.ssh/config tmux - ~/.tmux.conf 版本控制 如何管理这些配置文件呢？ [!important] 在它们的文件夹下，并使用版本控制系统进行管理，然后通过脚本将其 符号链接 到需要的地方 安装简单: 如果您登录了一台新的设备，在这台设备上应用您的配置只需要几分钟的时间； 可移植性: 您的工具在任何地方都以相同的配置工作 同步: 在一处更新配置文件，可以同步到其他所有地方 变更追踪: 您可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的 可移植性 配置文件 if 语句，可以借助它针对不同的设备编写不同的配置。例如，您的 shell 可以这样做： if [[ \"$(uname)\" == \"Linux\" ]]; then {do_something}; fi # 使用和 shell 相关的配置时先检查当前 shell 类型 if [[ \"$SHELL\" == \"zsh\" ]]; then {do_something}; fi # 您也可以针对特定的设备进行配置 if [[ \"$(hostname)\" == \"myServer\" ]]; then {do_something}; fi 配置文件支持 include 功能，您也可以多加利用。例如：~/.gitconfig 可以这样编写： [include] path = ~/.gitconfig_local 希望在不同的程序之间共享某些配置，该方法也适用。例如，如果您想要在 bash 和 zsh 中同时启用一些别名，您可以把它们写在 .aliases 里，然后在这两个 shell 里应用： # Test if ~/.aliases exists and source it if [ -f ~/.aliases ]; then source ~/.aliases fi 远程设备 使用 ssh 连接到其他服务器： ssh c21231511@jlulinux.cn 以用户名 c21231511 登录服务器 jlulinux.cn。服务器可以通过 URL 指定（例如 bar.mit.edu），也可以使用 IP 指定（例如 foobar@192.168.1.42 执行命令 ssh 的一个经常被忽视的特性是它可以直接远程执行命令。 ssh foobar@server ls | grep PATTERN 会在本地查询远端 ls 的输出 ls | ssh foobar@server grep PATTERN 会在远端对本地 ls 输出的结果进行查询。 SSH密钥 只需要向服务器证明客户端持有对应的私钥，而不需要公开其私钥。这样您就可以避免每次登录都输入密码的麻烦了秘密就可以登录 私钥(通常是 ~/.ssh/id_rsa 或者 ~/.ssh/id_ed25519) 等效于您的密码 密钥生成 使用 ssh-keygen 命令可以生成一对密钥： ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519 您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。 检查您是否持有密码并验证它，您可以运行 ssh-keygen -y -f /path/to/key. 基于密钥的认证机制 ssh 会查询 .ssh/authorized_keys 来确认那些用户可以被允许登录。您可以通过下面的命令将一个公钥拷贝到这里： cat .ssh/id_ed25519.pub | ssh foobar@remote 'cat >> ~/.ssh/authoriz' 或者 ssh-copy-id -i .ssh/id_ed25519.pub foobar@remote 通过SSH复制文件 ssh+tee, 最简单的方法是执行 ssh 命令，然后通过这样的方法利用标准输入实现 cat localfile | ssh remote_server tee serverfile。tee 命令会将标准输出写入到一个文件； scp ：当需要拷贝大量的文件或目录时，使用 scp 命令则更加方便，因为它可以方便的遍历相关路径。语法如下：scp path/to/local_file remote_host:path/to/remote_file； rsync 对 scp 进行了改进，它可以检测本地和远端的文件以防止重复拷贝。它还可以提供一些诸如符号连接、权限管理等精心打磨的功能。甚至还可以基于 --partial 标记实现断点续传。rsync 的语法和 scp 类似； [!warning] 注意，如果不是通过默认的密钥登录服务器的话，在windows系统需要通过补全密钥路径免密登录 ssh -i path User@Hostname 而在 Linux 系统中，SSH 客户端（ssh 命令）默认会自动尝试使用标准路径下的私钥文件（如 ~/.ssh/id_rsa、~/.ssh/id_ecdsa 等），而无需手动指定私钥路径。 端口转发 需要监听特定设备的端口。如果是在您的本机，可以使用 localhost:PORT 或 127.0.0.1:PORT 使用本地端口转发，即远端设备上的服务监听一个端口：ssh -L 9999:localhost:8888 foobar@remote_server 。这样只需要访问本地的 localhost:9999 即可。 SSH配置 使用 ~/.ssh/config. Host vm User foobar HostName 172.16.174.141 Port 2222 IdentityFile ~/.ssh/id_ed25519 LocalForward 9999 localhost:8888 # 在配置文件中也可以使用通配符 Host *.mit.edu User foobaz 这么做的好处是，使用 ~/.ssh/config 文件来创建别名，类似 scp、rsync 和 mosh 的这些命令都可以读取这个配置并将设置转换为对应的命令行选项。 服务器侧的配置通常放在 /etc/ssh/sshd_config。 杂项 Mosh（即 mobile shell ）对 ssh 进行了改进，它允许连接漫游、间歇连接及智能本地回显。 sshfs 可以将远端服务器上的一个文件夹挂载到本地，然后您就可以使用本地的编辑器了。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 05_Command-line Environment "},"docs/计算机教育中缺失的一课/07_Debugging_and_Profiling.html":{"url":"docs/计算机教育中缺失的一课/07_Debugging_and_Profiling.html","title":"07_Debugging and Profiling","keywords":"","body":" 调试及性能分析 调试代码 打印语句 使用日志 第三方日志系统 logger 调试器 专门工具 静态分析 性能分析 计时 性能分析工具 内存 事件分析 可视化 资源监控 通用监控 I/O 操作 磁盘使用 内存使用 打开文件 网络连接和配置 网络使用 专用工具 调试及性能分析 调试代码 打印语句 [!tip] “最有效的 debug 工具就是细致的分析，配合恰当位置的打印语句” — Brian Kernighan, Unix 新手入门。 使用日志 将日志写入文件、socket 或者甚至是发送到远端服务器而不仅仅是标准输出 日志可以支持严重等级（例如 INFO, DEBUG, WARN, ERROR 等） 对于新发现的问题，很可能日志中已经包含了可以帮助您定位问题的足够的信息 包含日志的例程序： $ python logger.py # Raw output as with just prints $ python logger.py log # Log formatted output $ python logger.py log ERROR # Print only ERROR levels and above $ python logger.py color # Color formatted output 以彩色文本显示终端信息时可读性更好 echo -e \"\\e[38;2;255;0;0mstring\\e[0m\"会打印红色的字符串string 可以使用支持更加广泛的 16 色，例如：”\\e[31; 1mstring\\e[0m “。 #!/usr/bin/env bash for R in $(seq 0 20 255); do for G in $(seq 0 20 255); do for B in $(seq 0 20 255); do printf \"\\e[38;2;${R};${G};${B}m█\\e[0m\"; done done done 第三方日志系统 构建大型软件系统，您很可能会使用到一些依赖，有些依赖会作为程序单独运行。如 Web 服务器、数据库或消息代理都是此类常见的第三方依赖。 系统交互的时候，阅读它们的日志是非常必要的，因为仅靠客户端侧的错误信息可能并不足以定位问题。 大多数的程序都会将日志保存在您的系统中的某个地方 UNIX 系统来说，程序的日志通常存放在 /var/log NGINX web 服务器就将其日志存放于 /var/log/nginx 系统开始使用 system log，您所有的日志都会保存在这里 大多数（但不是全部的）Linux 系统都会使用 systemd，这是一个系统守护进程 控制您系统中的很多东西，例如哪些服务应该启动并运行。 systemd 会将日志以某种特殊格式存放于 /var/log/journal，您可以使用 journalctl 命令显示这些消息。 logger 如果您希望将日志加入到系统日志中，您可以使用 logger 这个 shell 程序。 多数的编程语言都支持向系统日志中写日志。 logger \"Hello Logs\" # On macOS log show --last 1m | grep Hello # On Linux journalctl --since \"1m ago\" | grep Hello 需要对 journalctl 和 log show 的结果进行大量的过滤，那么此时可以考虑使用它们自带的选项对其结果先过滤一遍再输出 像 lnav 这样的工具，它为日志文件提供了更好的展现和浏览方式 调试器 [!note] 调试器是一种可以允许我们和正在执行的程序进行交互的程序，它可以做到： 当到达某一行时将程序暂停； 一次一条指令地逐步执行程序； 程序崩溃后查看变量的值； 满足特定条件时暂停程序； 其他高级功能。 Python 的调试器是 pdb. pdb 支持的命令进行简单的介绍： l(ist) - 显示当前行附近的 11 行或继续执行之前的显示； s(tep) - 执行当前行，并在第一个可能的地方停止； n(ext) - 继续执行直到当前函数的下一条语句或者 return 语句； b(reak) - 设置断点（基于传入的参数）； p(rint) - 在当前上下文对表达式求值并打印结果。还有一个命令是 pp ，它使用 pprint 打印； r(eturn) - 继续执行直到当前函数返回； q(uit) - 退出调试器。 ipdb 是一种增强型的 pdb ，它使用 IPython 作为 REPL 并开启了 tab 补全、语法高亮、更好的回溯和更好的内省，同时还保留了 pdb 模块相同的接口。 解一下 gdb ( 以及它的改进版 pwndbg) 和 lldb。 专门工具 程序需要执行一些只有操作系统内核才能完成的操作时，它需要使用 系统调用。有一些命令可以帮助您追踪您的程序执行的系统调用。 在 Linux 中可以使用 strace ，在 macOS 和 BSD 中可以使用 dtrace。 对 stat 系统调用进行追踪对结果。若需要深入了解 strace，这篇文章 值得一读。 # On Linux sudo strace -e lstat ls -l > /dev/null 4 # On macOS sudo dtruss -t lstat64_extended ls -l > /dev/null [!tip] 有些情况下，我们需要查看网络数据包才能定位问题。像 tcpdump 和 Wireshark 这样的网络数据包分析工具可以帮助您获取网络数据包的内容并基于不同的条件进行过滤。 静态分析 静态分析 工具就可以帮我们找到问题。静态分析会将程序的源码作为输入然后基于编码规则对其进行分析并对代码的正确性进行推理。 下面这段 Python 代码中存在几个问题。 首先，我们的循环变量 foo 覆盖了之前定义的函数 foo。最后一行，我们还把 bar 错写成了 baz，因此当程序完成 sleep (一分钟)后，执行到这一行的时候便会崩溃。 import time def foo(): return 42 for foo in range(5): print(foo) bar = 1 bar *= 0.2 time.sleep(60) print(baz) 使用 pyflakes 分析代码的时候，我们会得到与这两处 bug 相关的错误信息。mypy 则是另外一个工具，它可以对代码进行类型检查。 对于shell 介绍了 shellcheck，这是一个类似的工具，但它是应用于 shell 脚本的。 在 vim 中，有 ale 或 syntastic 可以帮助您做同样的事情。 在 Python 中， pylint 和 pep8 是两种用于进行风格检查的工具，而 bandit 工具则用于检查安全相关的问题。 [!tip] 对于风格检查和代码格式化，还有以下一些工具可以作为补充：用于 Python 的 black、用于 Go 语言的 gofmt、用于 Rust 的 rustfmt 或是用于 JavaScript, HTML 和 CSS 的 prettier 。这些工具可以自动格式化您的代码，这样代码风格就可以与常见的风格保持一致。 性能分析 鉴于 过早的优化是万恶之源，您需要学习性能分析和监控工具，它们会帮助您找到程序中最耗时、最耗资源的部分，这样您就可以有针对性的进行性能优化。 计时 打印两处代码之间的时间即可发现问题。下面这个例子中，我们使用了 Python 的 time 模块。 import time, random n = random.randint(1, 10) * 100 # 获取当前时间 start = time.time() # 执行一些操作 print(\"Sleeping for {} ms\".format(n)) time.sleep(n/1000) # 比较当前时间和起始时间 print(time.time() - start) # Output # Sleeping for 500 ms # 0.5713930130004883 [!tip] 执行时间（wall clock time）也可能会误导您，因为您的电脑可能也在同时运行其他进程，也可能在此期间发生了等待。 对于工具来说，需要区分真实时间、用户时间和系统时间。 用户时间 + 系统时间代表了您的进程所消耗的实际 CPU 真实时间 Real - 从程序开始到结束流失掉的真实时间，包括其他进程的执行时间以及阻塞消耗的时间（例如等待 I/O 或网络）； 用户时间 User - CPU 执行用户代码所花费的时间； 系统时间 Sys - CPU 执行系统内核代码所花费的时间。 例如，试着执行一个用于发起 HTTP 请求的命令并在其前面添加 time 前缀。 $ time curl https://missing.csail.mit.edu &> /dev/null real 0m2.561s user 0m0.015s sys 0m0.012s 性能分析工具 提及性能分析工具的时候，通常指的是 CPU 性能分析工具。 CPU 性能分析工具有两种： 追踪分析器（tracing）及采样分析器（sampling）。 追踪分析器 会记录程序的每一次函数调用，而采样分析器则只会周期性的监测（通常为每毫秒）您的程序并记录程序堆栈。 python 在 Python 中，使用 cProfile 模块来分析每次函数调用所消耗的时间。 在下面的例子中，我们实现了一个基础的 grep 命令： #!/usr/bin/env python import sys, re def grep(pattern, file): with open(file, 'r') as f: print(file) for i, line in enumerate(f.readlines()): pattern = re.compile(pattern) match = pattern.search(line) if match is not None: print(\"{}: {}\".format(i, line), end=\"\") if __name__ == '__main__': times = int(sys.argv[1]) pattern = sys.argv[2] for i in range(times): for file in sys.argv[3:]: grep(pattern, file) $ python -m cProfile -s tottime grep.py 1000 '^(import|\\s*def)[^,]*$' *.py [omitted program output] ncalls tottime percall cumtime percall filename:lineno(function) 8000 0.266 0.000 0.292 0.000 {built-in method io.open} 8000 0.153 0.000 0.894 0.000 grep.py:5(grep) 17000 0.101 0.000 0.101 0.000 {built-in method builtins.print} 8000 0.100 0.000 0.129 0.000 {method 'readlines' of '_io._IOBase' objects} 93000 0.097 0.000 0.111 0.000 re.py:286(_compile) 93000 0.069 0.000 0.069 0.000 {method 'search' of '_sre.SRE_Pattern' objects} 93000 0.030 0.000 0.141 0.000 re.py:231(compile) 17000 0.019 0.000 0.029 0.000 codecs.py:318(decode) 1 0.017 0.017 0.911 0.911 grep.py:3() [omitted lines] 通过它的输出我们可以知道，IO 消耗了大量的时间，编译正则表达式也比较耗费时间。 正则表达式只需要编译一次，可以将其移动到 for 循环外面来改进性能。 更加符合直觉的显示分析信息的方式是包括每行代码的执行时间，这也是 行分析器 的工作。 #!/usr/bin/env python import requests from bs4 import BeautifulSoup # 这个装饰器会告诉行分析器 # 我们想要分析这个函数 @profile def get_urls(): response = requests.get('https://missing.csail.mit.edu') s = BeautifulSoup(response.content, 'lxml') urls = [] for url in s.find_all('a'): urls.append(url['href']) if __name__ == '__main__': get_urls() 使用 line_profiler，它会基于行来显示时间： $ kernprof -l -v a.py Wrote profile results to urls.py.lprof Timer unit: 1e-06 s Total time: 0.636188 s File: a.py Function: get_urls at line 5 Line # Hits Time Per Hit % Time Line Contents ============================================================== 5 @profile 6 def get_urls(): 7 1 613909.0 613909.0 96.5 response = requests.get('https://missing.csail.mit.edu') 8 1 21559.0 21559.0 3.4 s = BeautifulSoup(response.content, 'lxml') 9 1 2.0 2.0 0.0 urls = [] 10 25 685.0 27.4 0.1 for url in s.find_all('a'): 11 24 33.0 1.4 0.0 urls.append(url['href']) 内存 C 或者 C++ 这样的语言，内存泄漏会导致您的程序在使用完内存后不去释放它 使用类似 Valgrind 这样的工具来检查内存泄漏问题。 对于python Python 这类具有垃圾回收机制的语言，内存分析器也是很有用的，因为对于某个对象来说，只要有指针还指向它，那它就不会被回收。 memory-profiler 是如何工作的（注意装饰器和 line-profiler 类似）。 @profile def my_func(): a = [1] * (10 ** 6) b = [2] * (2 * 10 ** 7) del b return a if __name__ == '__main__': my_func() $ python -m memory_profiler example.py Line # Mem usage Increment Line Contents ============================================== 3 @profile 4 5.97 MB 0.00 MB def my_func(): 5 13.61 MB 7.64 MB a = [1] * (10 ** 6) 6 166.20 MB 152.59 MB b = [2] * (2 * 10 ** 7) 7 13.61 MB -152.59 MB del b 8 13.61 MB 0.00 MB return a 事件分析 使用 strace 调试代码的时候，您可能会希望忽略一些特殊的代码并希望在分析时将其当作黑盒处理。perf 命令将 CPU 的区别进行了抽象，它不会报告时间和内存的消耗，而是报告与您的程序相关的系统事件。 例如，perf 可以报告不佳的缓存局部性（poor cache locality）、大量的页错误（page faults）或活锁（livelocks）。下面是关于常见命令的简介： perf list - 列出可以被 pref 追踪的事件； perf stat COMMAND ARG1 ARG2 - 收集与某个进程或指令相关的事件； perf record COMMAND ARG1 ARG2 - 记录命令执行的采样信息并将统计数据储存在 perf.data 中； perf report - 格式化并打印 perf.data 中的数据。 可视化 对于采样分析器来说，常见的显示 CPU 分析数据的形式是 火焰图，火焰图会在 Y 轴显示函数调用关系，并在 X 轴显示其耗时的比例。 火焰图同时还是可交互的，您可以深入程序的某一具体部分，并查看其栈追踪 调用图和控制流图可以显示子程序之间的关系，它将函数作为节点并把函数调用作为边。将它们和分析器的信息（例如调用次数、耗时等）放在一起使用时，调用图会变得非常有用，它可以帮助我们分析程序的流程。 在 Python 中您可以使用 pycallgraph 来生成这些图片。 资源监控 通用监控 最流行的工具要数 htop, 了，它是 top 的改进版。htop 可以显示当前运行进程的多种统计信息。htop 有很多选项和快捷键，常见的有： 进程排序、 t 显示树状结构和 h 打开或折叠线程。 glances ，它的实现类似但是用户界面更好。 如果需要合并测量全部的进程， dstat 是也是一个非常好用的工具，它可以实时地计算不同子系统资源的度量数据，例如 I/O、网络、 CPU 利用率、上下文切换等等； I/O 操作 iotop 可以显示实时 I/O 占用信息而且可以非常方便地检查某个进程是否正在执行大量的磁盘读写操作； 磁盘使用 df 可以显示每个分区的信息，而 du 则可以显示当前目录下每个文件的磁盘使用情况（ d isk u sage）。-h 选项可以使命令以对人类（h uman）更加友好的格式显示数据；ncdu 是一个交互性更好的 du ，它可以让您在不同目录下导航、删除文件和文件夹； 内存使用 free 可以显示系统当前空闲的内存。内存也可以使用 htop 这样的工具来显示； 打开文件 lsof 可以列出被进程打开的文件信息。 当我们需要查看某个文件是被哪个进程打开的时候，这个命令非常有用； 网络连接和配置 ss 能帮助我们监控网络包的收发情况以及网络接口的显示信息。ss 常见的一个使用场景是找到端口被进程占用的信息。如果要显示路由、网络设备和接口信息，您可以使用 ip 命令。 注意，netstat 和 ifconfig 这两个命令已经被前面那些工具所代替了。 网络使用 nethogs 和 iftop 是非常好的用于对网络占用进行监控的交互式命令行工具。 专用工具 只需要对黑盒程序进行基准测试，并依此对软件选择进行评估。 类似 hyperfine 这样的命令行可以帮您快速进行基准测试。例如，我们在 shell 工具和脚本那一节课中我们推荐使用 fd 来代替 find。我们这里可以用 hyperfine 来比较一下它们。 例如，下面的例子中，我们可以看到 fd 比 find 要快 20 倍。 $ hyperfine --warmup 3 'fd -e jpg' 'find . -iname \"*.jpg\"' Benchmark #1: fd -e jpg Time (mean ± σ): 51.4 ms ± 2.9 ms [User: 121.0 ms, System: 160.5 ms] Range (min … max): 44.2 ms … 60.1 ms 56 runs Benchmark #2: find . -iname \"*.jpg\" Time (mean ± σ): 1.126 s ± 0.101 s [User: 141.1 ms, System: 956.1 ms] Range (min … max): 0.975 s … 1.287 s 10 runs Summary 'fd -e jpg' ran 21.89 ± 2.33 times faster than 'find . -iname \"*.jpg\"' ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 07_Debugging and Profiling "},"docs/计算机教育中缺失的一课/08_Metaprogramming.html":{"url":"docs/计算机教育中缺失的一课/08_Metaprogramming.html","title":"08_Metaprogramming","keywords":"","body":" 元编程 构建系统 make 依赖管理 版本控制 持续集成系统 测试简介 课后练习 元编程 学习构建系统、代码测试以及依赖管理 “元编程” 也有 “用于操作程序的程序” 之含义 构建系统 对于大多数系统来说，不论其是否包含代码，都会包含一个 “构建过程”。通常，这一过程包含了很多步骤，很多分支。执行一些命令来生成图表，然后执行另外的一些命令生成结果，然后再执行其他的命令来生成最终的论文。 有很多工具可以帮助我们完成这些操作。这些工具通常被称为 “构建系统” [!note] 如何选择工具完全取决于您当前手头上要完成的任务以及项目的规模。 需要定义 依赖、目标 和 规则。您必须告诉构建系统您具体的构建目标，系统的任务则是找到构建这些目标所需要的依赖，并根据规则构建所需的中间产物，直到最终目标被构建出来。 理想的情况下，如果目标的依赖没有发生改动，并且我们可以从之前的构建中复用这些依赖，那么与其相关的构建规则并不会被执行。 make make 是最常用的构建系统之一，您会发现它通常被安装到了几乎所有基于 UNIX 的系统中。 执行 make 时，它会去参考当前目录下名为 Makefile 的文件。所有构建目标、相关依赖和规则都需要在该文件中定义，它看上去是这样的： paper.pdf: paper.tex plot-data.png pdflatex paper.tex plot-%.png: %.dat plot.py ./plot.py -i $*.dat -o $@ 这个文件中的指令，即如何使用右侧文件构建左侧文件的规则。 冒号左侧的是构建目标，冒号右侧的是构建它所需的依赖。缩进的部分是从依赖构建目标时需要用到的一段命令。 在 make 中，第一条指令还指明了构建的目的，如果您使用不带参数的 make，这便是我们最终的构建结果。 [!tip] 规则中的 % 是一种模式，它会匹配其左右两侧相同的字符串。 例如，如果目标是 plot-foo.png， make 会去寻找 foo.dat 和 plot.py 作为依赖。 依赖管理 就您的项目来说，它的依赖可能本身也是其他的项目。 项目会依赖某些程序（例如 python）、系统包（例如 openssl）或相关编程语言的库（例如 matplotlib）。 现在，大多数的依赖可以通过某些 软件仓库 来获取，这些仓库会在一个地方托管大量的依赖，我们则可以通过一套非常简单的机制来安装依赖 Ubuntu 系统下面有 Ubuntu 软件包仓库，您可以通过 apt 这个工具来访问， RubyGems 则包含了 Ruby 的相关库，PyPi 包含了 Python 库， Arch Linux 用户贡献的库则可以在 Arch User Repository 中找到。 版本控制 大多数被其他项目所依赖的项目都会在每次发布新版本时创建一个 版本号。 版本号有很多用途，其中最重要的作用是保证软件能够运行 版本控制可以指定当前项目需要基于某个版本，甚至某个范围内的版本，或是某些项目来构建。这么做的话，即使某个被依赖的库发生了变化，依赖它的软件可以基于其之前的版本进行构建 [!note] 一个相对比较常用的标准是 语义版本号，这种版本号具有不同的语义，它的格式是这样的：主版本号.次版本号.补丁号。相关规则有： 如果新的版本没有改变 API，请将补丁号递增； 如果您添加了 API 并且该改动是向后兼容的，请将次版本号递增； 如果您修改了 API 但是它并不向后兼容，请将主版本号递增。 如果我们的项目是基于您的项目构建的，那么只要最新版本的主版本号只要没变就是安全的 ，次版本号不低于之前我们使用的版本即可。 例如，Python 2 和 Python 3 的代码是不兼容的 依赖管理系统的时候，您可能会遇到锁文件（lock files） 锁文件列出了您当前每个依赖所对应的具体版本号。通常，您需要执行升级程序才能更新依赖的版本。 一种极端的依赖锁定叫做 vendoring 它会把您的依赖中的所有代码直接拷贝到您的项目中，这样您就能够完全掌控代码的任何修改，同时您也可以将自己的修改添加进去，不过这也意味着如果该依赖的维护者更新了某些代码，您也必须要自己去拉取这些更新。 持续集成系统 持续集成（Continuous integration），或者叫做 CI 是一种雨伞术语（umbrella term，涵盖了一组术语的术语），它指的是那些“当您的代码变动时，自动运行的东西” 您需要在代码仓库中添加一个文件，描述当前仓库发生任何修改时，应该如何应对。目前为止，最常见的规则是：如果有人提交代码，执行测试套件。 当这个事件被触发时，CI 提供方会启动一个（或多个）虚拟机，执行您制定的规则，并且通常会记录下相关的执行结果。 测试简介 多数的大型软件都有“测试套件”。您可能已经对测试的相关概念有所了解，但是我们觉得有些测试方法和测试术语还是应该再次提醒一下： 测试套件（Test suite）：所有测试的统称。 单元测试（Unit test）：一种“微型测试”，用于对某个封装的特性进行测试。 集成测试（Integration test）：一种“宏观测试”，针对系统的某一大部分进行，测试其不同的特性或组件是否能 协同 工作。 回归测试（Regression test）：一种实现特定模式的测试，用于保证之前引起问题的 bug 不会再次出现。 模拟（Mocking）: 使用一个假的实现来替换函数、模块或类型，屏蔽那些和测试不相关的内容。例如，您可能会“模拟网络连接” 或 “模拟硬盘”。 课后练习 习题解答 大多数的 makefiles 都提供了 一个名为 clean 的构建目标，这并不是说我们会生成一个名为 clean 的文件，而是我们可以使用它清理文件，让 make 重新构建。您可以理解为它的作用是“撤销”所有构建步骤。在上面的 makefile 中为 paper.pdf 实现一个 clean 目标。您需要将构建目标设置为 phony。您也许会发现 git ls-files 子命令很有用。其他一些有用的 make 构建目标可以在 这里 找到； 指定版本要求的方法很多，让我们学习一下 Rust 的构建系统 的依赖管理。大多数的包管理仓库都支持类似的语法。对于每种语法(尖号、波浪号、通配符、比较、多个版本要求)，构建一种场景使其具有实际意义； Git 可以作为一个简单的 CI 系统来使用，在任何 git 仓库中的 .git/hooks 目录中，您可以找到一些文件（当前处于未激活状态），它们的作用和脚本一样，当某些事件发生时便可以自动执行。请编写一个 pre-commit 钩子，它会在提交前执行 make paper.pdf 并在出现构建失败的情况拒绝您的提交。这样做可以避免产生包含不可构建版本的提交信息； 基于 GitHub Pages 创建任意一个可以自动发布的页面。添加一个 GitHub Action 到该仓库，对仓库中的所有 shell 文件执行 shellcheck(方法之一)； 构建属于您的 GitHub action，对仓库中所有的 .md 文件执行 proselint 或 write-good，在您的仓库中开启这一功能，提交一个包含错误的文件看看该功能是否生效。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 08_Metaprogramming "},"docs/DataStructure_and_Algorithms/":{"url":"docs/DataStructure_and_Algorithms/","title":"DataStructure_and_Algorithms","keywords":"","body":" 数据结构与算法 数据结构与算法 本笔记汇集了数据结构与算法的入门与进阶内容，包含讲义、示例、练习和常见题解，适合自学、复习和面试准备。 数据结构与算法是写出高效程序的基础。掌握了基本的数据结构和算法思路，才可以写出更好的代码。当然不可否认算法与数据结构的内容繁琐并且难度并不小，但学习是一个长期过程，多思考多写多做。 相关资料请关注github仓库Data_Structure_and_Algorithm [!tip] 建议学习路线：Data_structure -> Algorithms 子目录： Data_structure/：常见数据结构的讲解与示例（数组、链表、树、图、排序与搜索等）。 Algorithms/：算法思想与常见算法（分治、动态规划、贪心、回溯、分支限界等），含概念解释与示例。 我的github仓库Data_Structure_and_Algorithm 欢迎在仓库内提交 Issue 或 PR 来提供建建议和见解 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - DataStructure_and_Algorithms "},"docs/DataStructure_and_Algorithms/Algorithms/":{"url":"docs/DataStructure_and_Algorithms/Algorithms/","title":"Algorithms","keywords":"","body":" 算法（Algorithms） 算法（Algorithms） 本文目录包含算法入门与常见算法思想的简明笔记，语言尽量通俗并且有许多示例代码，适合想快速理解算法思路的读者。 其中很多章节都是根据算法导论进行学习，后面三个章节则是根据学校课程编写 每一个章节有大量示例问题，我相信只要你能将每个章节的示例问题吃透，对于算法也可以做到真正入门了 章节列表与简短说明： 01_算法在计算中的作用：讲算法为什么重要，举例说明算法如何解决问题并影响效率。 02_算法基础：介绍算法常用的基础概念和常见写法，帮助你理解后续章节。 03_函数的增长：用直观方式说明算法随数据量增长时的表现，好判断算法快慢。 04_分治策略：解释把大问题拆成小问题的方法，很多高效算法都用这个思路。 15_动态规划：讲如何把重复计算的工作保存下来，避免重复劳动，从而加快程序。 16_贪心算法：介绍一步步做出局部最优选择以期得到整体可接受解的策略，适合某些问题。 17_回溯：讲试错与回退的做法，适合用于寻找所有解或满足约束的问题。 18_分支限界：说明如何在搜索时剪掉明显不可行或不优的分支，节省时间。 19_NP问题：给出 NP 问题的直观概念，说明哪些问题目前难以在短时间内解出最优解。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - Algorithms "},"docs/DataStructure_and_Algorithms/Algorithms/01_算法在计算中的作用.html":{"url":"docs/DataStructure_and_Algorithms/Algorithms/01_算法在计算中的作用.html","title":"01_算法在计算中的作用","keywords":"","body":" 1. 算法在计算中的作用 1.1 算法 1.2 作为一种技术的算法 1. 算法在计算中的作用 1.1 算法 [!note] 算法是一系列解决问题的明确指令， 也就是说，对于符合一定规范的输入，能够在有限时间内获得要求的输出。 算法 算法就是任何良定义的计算过程 算法是把输入转换成输出的计算步骤的一个序列。 算法也可以看成用于求解良说明的计算问题的工具。 问题实例由计算该问题解所必需的（满足问题陈述中强加的各种约束的）输入组成。 若对每个输入实例算法都以正确的输出停机，则称该算法是正确的 衡量算法效率的常用标准是速度。 算法问题所共有的两个特征： 存在许多候选解，但绝大多数候选解都没有解决手头的问题。 存在实际应用。 数据结构是一种存储和组织数据的方式 算法的五个特性 有穷性：算法必须在有限步骤之后终止 确定性：算法的每个步骤都必须精确定义 输入（input）：有0个或多个输入 输出（output）：有一个或多个输出 可行性：运算都是基本运算，理论上可用纸和笔在有限时间内精确完成 练习 1.1一1 给出现实生活中需要排序的一个例子或者现实生活中需要计算凸壳的一个例子。 排序：将一次考试中500名考生的成绩按分数从高到低迕行排名。 确定多矩阵相乘的最佳顺序 找出凸壳：木板上钉了21个钉子，以其中一些钉子为顶点组成的凸多边形可以包 含所有21个钉子，找出使凸多边形达到最小的所有钉子。 1.1-2 除速度外，在真实环境中还可能使用哪些其他有关效率的量度？ 占用资源（内存使用情况，资源利用率） 问题解决程度 答案精度 1.1-3 选择一种你以前巳知的数据结构，并讨论其优势和局限。 栈（LIFO) 可以严格按照后进先出顺序，非常适合如保存程序调用的返回地址类的特殊应用 无法迕行随机读写 单链表 不需要连续空间，可以以O(1)插入新元素 访问为O(n)，需要额外空间给指针域使得存储密度小。 1.1-4 前面给出的最短路径与旅行商问题有哪些相似之处？又有哪些不同？ 相似：寻求最短路 不同： 最短路线问题是找到两点间最短路，不需要经过所有的点 旅行商人问题中如果把仓库看做是图中的一个点的话，首先要满足遍历所有的点，然后在所有满足的线路中选择最短的线路，其复 杂程度要高于最短路径。 1.1-5 提供一个现实生活的间题，其中只有最佳解才行。然后提供一个问题，其中近似最佳的 一个解也足够好。 看问题需求是求出极端情况(最大化或者最小化)还是可以有误差（近似解）。 1.2 作为一种技术的算法 计算时间和存储器空间是一种有限资源，必须被有效的使用，那些时间和空间上有效的算法就有助于做到返一点 像计算机硬件一样把算法看成是一种技术，系统性能不但依赖于选择快速的硬件而且还依赖于选择有效的算法。 练习 2-1 给出在应用层需要算法内容的应用的一个例子，并讨论涉及的算法的功能。 计算平均分 算法：减少了运算量。最终大大加快了计算效率，幵且提高了计 算准确度。 2-2 假设我们正比较插入排序与归并排序在相同机器上的实现。对规模为n的输入，插入排序运行8*n^2步，而归并排序运行64nlgn步。问对哪些n值，插入排序优于归并排序？ 2-3 n 的最小值为何值时，运行时间为 100*n^2 的一个算法在相同机器上快于运行时间为 2^n 的 另一个算法？ 思考题： （运行时间的比较） 假设求解问题的算法需要f(n)毫秒，对下表中的每个函数f(n)和时间 t, 确定可以在时间 t 内求解的问题的最大规模n ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 01_算法在计算中的作用 "},"docs/DataStructure_and_Algorithms/Algorithms/02_算法基础.html":{"url":"docs/DataStructure_and_Algorithms/Algorithms/02_算法基础.html","title":"02_算法基础","keywords":"","body":" 第2章 算法基础 2.1 插入排序 2.2 分析算法 2.3 设计算法 2.3.1 分治法 2.3.2 分析分治算法 第2章 算法基础 2.1 插入排序 循环不变式 [!important] 三条性质： 初始化：循环的第一次迭代之前，它为真。 保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。 终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的。 类似于数学归纳法，这里，证明第一次迭代之前不变式成立对应于基本情况，证明从一次迭代到下一次迭代不变式成立对应于归纳步。 当前两条性质成立时，在循环的每次迭代之前循环不变式为真。 而第三条性质是最重要的，使用循环不变式来证明正确性。 练习： 2.1-1 以图 2-2 为模型，说明 INSERTION-SORT在数组A=(31, 41, 59, 26, 41, 58〉上的执行过程。 略 2.1-2 重写过程 INSERTION-SORT, 使之按非升序（而不是非降序）排序。 INSERTION-SORTCA) for j = 2 to A. length key= A[j] // Insert A[j] into the sorted sequence A[l. . j —1]. i=j-1 while i > 0 and A[i] 2.1-3 考虑以下查找问题： 输入： n个数的一个序列A=(a1, az, …, a. 〉和一个值v。 输出：下标i使得v=A[i]或者当 v不在A 中出现时， v为特殊值NIL。 写出线性查找的伪代码，它扫描整个序列来查找v。使用一个循环不变式来证明你的算法 是正确的。确保你的循环不变式满足三条必要的性质。 LINEAR-SEARCH(A,v) for i←1 to length[A] if v=A[i] return i return NIL 初始化：i=1，子数组为A[1...i]，只有一个元素，如果 v=A[1]就返回1,否则返回NIL， 算法显然是正确的。 保持：若算法对数组A[1..i]正确，则在数组增加一个元素A[i+1]时，只需要多作一次比较， 因此显然对A[1..i+1]也正确。 终止：算法如果在非最坏情况下定能返回一个值此时查找成功，如果n次查找（遍历了所有的数）都没有成功，则返回NIL。 2.1-4 考虑把两个 n位二进制整数加起来的问题，这两个整数分别存储在两个n元数组A 和B 中。这两个整数的和应按二进制形式存储在一个(n+l)元数组C中。请给出该问题的形式化描述，并写出伪代码。 BINARY-ADD(A,B,C) flag← 0 for j←1 to n do key←A[j]+B[j]+flag C[j]←key mod 2 if key>1 flag←1 if flag=1 C[n+1]←1 2.2 分析算法 分析算法的结果意味着预测算法需要的资源，主要是时间； 分析一个算法之前，必须须有一个要使用的实现技术的模型，包括描述所用资源 及其代价的模型：通用的单处理器计算模型 随机访问 机(random-access machine, RAM) 定义RAM模型的指令及其代价 RAM模型包含真实计算机中常见的指令：每条指令所需时间为常量。 数据类型有整数型和浮点实数型 不试图对当代计算机中常见的内存层次进行建模 插入排序算法的分析: 输入规模的最佳概念依赖于研究的问题。 在特定输入上的运行时间是指执行的基本操作数或步数。 最坏情况与平均情况分析: 往往只求最坏情况运行时间，即对规模为n的任何输入，算法的最长运行时间。 最坏情况运行时间给出了任何输入的运行时间的一个上界。 对某些算法，最坏情况经常出现。 \"平均情况“往往与最坏情况大致一样差。 增长量级: 只考虑的运行时间的增长率或增长量级，公式中最重要的项（高阶项） 练习： 2.2-1：用Θ形式表示表示函数n^3/1000-𝟏𝟎𝟎𝐧^𝟐-100n+3 Θ(n^3) 2.2-2:考虑对数组A中的n个数进行排序的问题：首先找出A中的最小元素，并将其与A[1] 中的元素迚行交换。接着，找出A中的次最小元素，并将其与A[2]中的元素进行交换。对 A中头n-1个元素继续这一过程。写出这个算法的伪代码，该算法称为选择排序（selection sort）。对这个算法来说，循环不变式是什么?为什么它仅需要在头n-1个元素上运行，而是在所有n个元素上运行？以𝚯形式写出选择排序的最佳和最坏情况下的运行时间。 SEECTION-SORT(A,n) for iA[j] min=j swap(A[min],A[i]) 初始化：i=1，从子数组A[1..n]里找到最小值A[j]，并不A[i]互换，此时子数组A[1..i]只有 一个元素A[1]，显然是已排序的。 保持：若A[1..i]是已排序子数组。找出A[i+1,..n]最小值与A[i+1]互换并将A[i+1]插入A[1..i]得到子数组A[1..i+1]有序。 终止：当i=n时终止，此时已得到已排序数组A[1..n-1]，而A[n]是经过n-1次比较后剩下的元素即最大元素，因此A[n]大于A[1..n-1]中任意元素 O（n^2) 2.2-3：再次考虑线性查找问题（见练习2.1-3）。在平均情况下，需要检查输入序列中的多少个元素？假定查找的元素是数组中任何一个元素的可能性都是相等的。在最坏情况下又怎么样呢？用Θ相似表示的话，线性查找的平均情况和最坏情况运行时间怎么样？对你的答案加以说明。 平均：n/2次。因为仸意一个元素大于、小于查找数的概率一样。 最坏：n次。最后一个元素才是要查找的元素。 用Θ表示都是：Θ(n) 2.2-4：应如何修改一个算法，才能使之具有较好的最佳情况运行时间？ 要对输入进行控制，使之偏向能够使得算法具有最佳运行情况的排列。 利用合适的数据结构 2.3 设计算法 2.3.1 分治法 利用递归设计算法，算法一次或多次递归地调 用其自身以解决紧密相关的若干子问题，典型地遵循分治法的思想： [!note] 将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。 分解原问题为若干子问题，这些子问题是原问题的规模较小的实例。 解决这些子问题，递归地求解各子问题。然而，若子问题的规模足够小，则直接求解。（即到达终止条件或者说退出递归的条件） 合并这些子问题的解成原问题的解。 2.3.2 分析分治算法 当一个算法包含对其自身的递归调用时，我们往往可以用递归方程或递归式来描述其运行时间，该方程根据在较小输入上的运行时间来描述在规模为n的问题上的总运行时间。 递归式：把原问题分解成a个子问题，每个子问题的规模是原问题的 1/b。 求解一个规模为n/b的子问题，，需要 T(n/b)的时间，所以需要 aT(n/b)的时间来求解a个子问题。 D(n)：分解问题成子问题需要时间。 C(n)：合并子问题的解成原问题的解需要时间。 归井排序算法的分析: 假定原问题规模是2的幂，这时每个分解步骤将产生规模刚好为n/2 的两个子序列： 分析建立归并排序n个数的最坏情况运行时间T(n)的递归式： 分解：分解步骤仅仅计算子数组的中间位置，需要常量时间，因此， D(n)=O(l)。 解决：我们递归地求解两个规模均为n/2 的子问题，将贡献2T(n/2)的运行时间。 合井：我们已经注意到在一个具有n个元素的子数组上过程MERGE需要O(n)的时间，所以 C(n)=O(n)。 练习 3-1 使用图 2-4 作为模型，说明归并排序在数组A=(3, 41, 52, 26, 38, 57, 9, 49〉上的 操作。略 3-2 重写过程MERGE, 使之不使用哨兵，而是一旦数组L或R 的所有元素均被复制回A 就 立刻停止，然后把另一个数组的剩余部分复制回A。 MERGE(A,p,q,r) n1 ←q−p+1 n2←r−q //create arrays L[1..n1] and R[1..n2] for i←1 to n1 do L[i]←A[p+i-1] for j←1 to 𝐧𝟐 do R[j]←A[q+j] i←1 j←1 for k←p to r do if i= n1 and j=n2 A[k]←L[i] i ←i +1 continue 2.3-3 使用数学归纳法证明：当n刚好是2的幕时，以下递归式的解是T(n)=nlgn。 2.3-4：插入排序可以如下改写成一个递归过程：为排序A[1..n]，先递归地排序A[1..n-1]， 然后再将A[n]插入到已排序的数组A[1..n-1]中去。对于插入排序的这一递归版本，为它的运行时间写一个递归式。 INSERTSORT(A,p,r) if r-p0 and A[i] > A[r] A[i+1] 2.3-5：回顾一下练习2.1-3中提出的查找问题，注意如果序列A是已排序的，就可以将该 序列的中点不v迚行比较。根据比较的结果，原序列中有一半就可以丌用再做迚一步的考虑 了。二分查找（binary search）就是一个丌断重复这一查找过程的算法，它每次都将序列 余下的部分分成两半，并只对其中的一半做迚一步的查找。写出二分查找算法的伪代码,以是迭代的，也可以是递归的。说明二分查找的最坏情况运行时间为什么是O(lgn) BISEARCH(A,n,target) l>1) if A[mid] target r 最坏情况运行时间为什么是O(lgn)：利用递归树深度可得最大为lgn 2.3-6：观察一下2.1节中给出的INSERTION-SORT过程，在第5~7行的while循环中， 采用了一种线性查找策略，在已排序的子数组A[1..j-1]中（反向）扫描。是否可以改为二分 查找策略（见练习2.3-5），来将揑入排序的总体最坏情况运行时间改善至O（nlgn) INSERTSORT(A,p,r) if r-p *2.3-7：请给出一个运行时间为O(nlgn)的算法，使之能在给定一个由n个整数构成的集合S和另一个整数x时，判断出中是否存在有两个其和等于x的元素。 排序后利用双指针 FINDADDTOx(S,x) nx)r-- else return true return false ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 02_算法基础 "},"docs/DataStructure_and_Algorithms/Algorithms/03_函数的增长.html":{"url":"docs/DataStructure_and_Algorithms/Algorithms/03_函数的增长.html","title":"03_函数的增长","keywords":"","body":" 函数的增长 3.1 渐进符号 渐近记号、函数与运行时间 渐近紧确界记号： Θ（big-theta） 渐近上界记号：O(big-oh) 渐近下界记号：Ω(big-omega) 非渐近紧确上界：o(小-oh) 非渐近紧确下界：ω(小-omega) 3.2 标准记号与常用函数 向下取整与向上取整 模运算 函数的增长 3.1 渐进符号 渐近记号、函数与运行时间 将主要使用渐近记号来描述算法的运行时间。 渐近记号实际上应用于函数 渐近紧确界记号： Θ（big-theta） 通俗理解为f (n) 和g(n)同阶，Θ 用来表示算法的精确阶。 渐近上界记号：O(big-oh) 通俗的说n满足一定条件范围内，函数f(n)的阶不高于函数g(n)。 [!important] 渐近下界记号：Ω(big-omega) 通俗的说n满足一定条件范围内，函数f(n)的阶不低于函数g(n)。 非渐近紧确上界：o(小-oh) 通俗理解为f (n) 低于g(n)的阶。 例子：f(n) = n^2 + n ,则f(n)=o(n^3) 非渐近紧确下界：ω(小-omega) 通俗理解为f (n) 高于g(n)的阶 ω记号与Ω的关系类似于o和O记号的关系 [!note] 即渐进确界在渐进上界和渐进下界之间 3.2 标准记号与常用函数 向下取整与向上取整 其实就是进一或者去尾 模运算 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 03_函数的增长 "},"docs/DataStructure_and_Algorithms/Algorithms/04_分治策略.html":{"url":"docs/DataStructure_and_Algorithms/Algorithms/04_分治策略.html","title":"04_分治策略","keywords":"","body":" 分支策略 递归式 递归式技术细节 最大子数组问题 暴力解法，求出所有连续子数组的和进行比较 分治策略 动态规划 矩阵乘法的Strassen算法 一般的矩阵乘法 简单的分治算法 Strassen算法 三次乘法完成复数相乘 二维极大点问题 用代入法求解递归式 用递归树方法求解递归式 用主方法求解递归式(主定理) 分支策略 分治法适用于问题规模大直接求解困难，可以分解为不同的可独立的子问题，求解子问题后可以合并 在分治策略中递归地求解一个问题，在每层递归中应用如下三个步骤 [!important] 分解(Divide)步骤将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。 解决(Conquer)步骤递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。 合井(Combine)步骤将子问题的解组合成原问题的解。 递归情况(recursive case)：子问题足够大，需要递归求解 基本情况(base case)：子问题变得足够小可以解决，不再需要递归 递归式 一个递归式(recurrence)就是一个等式或不等式，它通过更小的输入上的函数值来描述一个函数。 子问题的规模不必是原问题规模的一个固定比例。 并且分的子问题数量越大，可能分开和合并的代价大 三种求解递归式 代入法 我们猜测一个界，然后用数学归纳法证明这个界是正确的。 递归树法 将递归式转换为一棵树，其结点表示不同层次的递归调用产生的代价。然后 采用边界和技术来求解递归式。 主方法 可求解形如下面公式的递归式的界： T(n) = aT(n/b) + f(n) 其中a>=1,b>=1, f(n)是一个给定的函数。 生成a个子问题，每个子间题的规模是原问题规模的 1/b, 分解和合并步 骤总共花费时间为f(n) 递归式技术细节 递归式声明和求解的一些技术细节 子问题规模是不是n/2？进一还是去尾 边界条件是另一类我们通常忽略的细节 对于足够小的n, 表示算法运行时间的递归式一般为 T(n)=@(1) 当声明、求解递归式时，我们常常忽略向下取整、向上取整及边界条件。先忽略这些细 节，稍后再确定这些细节对结果是否有较大影响。 最大子数组问题 [!note] 寻找数组A的和最大的非空连续子数组。我们称这样的连续子数组为最大子数组(maximum subarray)。 暴力解法，求出所有连续子数组的和进行比较 int FIND-MAXIMUM-SUBARRAY(vector& nums) { int sum = INT_MIN; for(int i=0;i 分治策略 [!important] 要寻找子数组A[low.. high] 的最大子数组。使用分治技术意味着我们要将子数组划分为两个规模尽量相等的子数组 例如取中间位置划分，则所求子数组的位置必然是以下三种情况给 完全位于左区间 完全位于右区间 跨越了中点 所以最大子数组必然是完全位千 A[low.. mid]中、完全位于 A[mid+l.. high] 中或者 跨越中点的所有子数组 中和最大者。 递归地求解A[low.. mid]和 A[mid+ 1.. high]的最大子数组，因为这两个子问题仍是最大子数组问题，只是规模更小。 因此，剩下的工作就是寻找跨越中点的最大子数组，然后在三种情况中选取和最大者。 对于穿过中间线的子数组，我们可以求出「中间线左侧的最大子数组和」以及「中间线右侧的最大子数组和」，相加就得到「穿过中间线的最大子数组和」。 //返回一个下标元组划定跨越中点的最大子数组的边界，并返回最大子数组中值的和。 FIND-MAX-CROSSING-SUBARRAY(A,low,mid,high) left-sum = -inf sum = 0 //求出左半部A[low.. mid]的最大子数组 for i = mid downto low sum += A[i] if sum > left-sum left-sum = sum max-left = i//更新左边界 right-sum = -inf sum = 0 //求右半部A[mid+1. . high]的最大子数组 for j = mid + 1 to high sum += A[j] if sum > right-sum right-sum = sum max-right = j//更新右边界 return (max-left,max-right,left-sum + right-sum) 求解最大子数组问题的分治算法的伪代码: FIND-MAXIMUM-SUBARRAY(A,low,high) // base case, only one element （基本情况） if high == low return (low,high,A[low]) else //递归求解左右区间最大子数组 mid = [(low + high) / 2] (left_low,left_high,left_sum) = FIND-MAXIMUM-SUBARRAY(A,low,mid) (right_low,right_high,right_sum) = FIND-MAXIMUM-SUBARRAY(A,mid + 1,high) //穿过中间线的最大子数组 (cross_low,cross_high,cross_sum) = FIND-MAXIMUM-CROSSING-SUBARRAY(A,low,mid,high) //比较返回最大子数组 if left_sum == Max(left_sum,right_sum,cross_sum) return (left_low,left_high,left_sum) else if right_sum == Max(left_sum,right_sum,cross_sum) return (right_low,right_high,right_sum) else return (cross_low,cross_high,cross_sum) 分治算法的分析 [!tip] 建立递归式 用主方法求解此递归式，其解为 T(n) = Θ(nlgn) 。 动态规划 [!important] 状态转移方程： dp[0]=nums[0],dp[i]=((dp[i-1]+dp[i])>dp[i])?(dp[i-1]+dp[i]):dp[i] 遍历求出最大dp[i] int FIND-MAXIMUM-SUBARRAY(vector& nums) { if(nums.empty())return INT_MIN; vector dp(nums.size()); dp[0]=nums[0]; int sum = dp[0]; for(int i=1;idp[i])?(dp[i-1]+dp[i]):dp[i] if(sum 矩阵乘法的Strassen算法 一般的矩阵乘法 nXn矩阵A和B, 返回它们的乘积一nXn矩阵C。 假设每个矩阵都有一个属性rows, 给出矩阵的行数。 //O(n^3) SQUARE-MATRIX-MULTIPLY(A, B) n= A.rows let C be a new nXn matrix for i=l to n for j = 1 to n c[ij]=0 for k=1 to n c[ij]+=a[ik]*b[kj] RETURN C 简单的分治算法 当使用分治算法计算矩阵积C=A•B时，假定三个矩阵均为nXn矩阵，其中 n 为 2 的幂。 nXn矩阵都被划分为4个n/2Xn/2的子矩阵 因此可以将公式C=A•B改写成 递归分治算法： SQUARE-MATRIX-MULTIPLY-RECURSIVE(A, B) n = A.rows let C be a new nXn matrix if n==l c[11] =a[11]• b[11] else partition A, B, and C as in equations (4. 9) C11 = SQUARE-MA TRIX-MUL TIPLY-RECURSIVE(A11 , B11) + SQUARE-MATRIX-MDL TIPL Y-RECURSIVE(A12, B21) C12=SQUARE-MATRIX-MULTIPLY-RECURSIVE(A11, B12) + SQUARE-MATRIX-MULTIPLY-RECURSIVE(A12, B22) C21=SQUARE-MATRIX-MULTIPLY-RECURSIVE(A21, B11) + SQUARE-MATRIX-MULTIPLY-RECURSIVE(A22, B21) C22=SQUARE-MATRIX-MULTIPLY-RECURSIVE(A21, B12) + SQUARE-MATRIX-MULTIPLY-RECURSIVE(A22, B22) return C 对于分解矩阵：而非创建12个新的n/2*n/2矩阵，而是使用下标计算,通过矩阵的一组行下标和一组列下标指明一个子矩阵，所以分解矩阵只需要常数的时间 递归式：共八次递归调用完成完成两个n/2Xn/2 矩阵的乘法(T(n/2)，以及四次矩阵加法 Strassen算法 将输入矩阵A、 B 和输出矩阵C分解为n/2 * n/2的子矩阵。采用下标计算方法，此步骤花常数时间，与 SQUARE-MATRIX-MULTIPLY-RECURSIVE相同。 创建 10 个 n/2 * n/2 的矩阵 S1, S2, …, S10, 每个矩阵保存步骤 1 中创建的两个子矩阵的和或差。 如下创建10个 n/2 * n/2 的矩阵 S1,S2,...,S10 (花费时间 Θ(n^2) ）。 S1=B12−B22 S2=A11+A12 S3=A21+A22 S4=B21−B11 S5=A11+A22 S6=B11+B22 S7=A12−A22 S8=B21+B22 S9=A11−A21 S10=B11+B12 递归地计算 7个矩阵积P1, P2, …, p7 。每个矩阵 P都是n/2 * n/2 的(花费时间 Θ(n^2)）。 P1 = A11⋅S1 = A11⋅B12−A11⋅B22 P2 = S2⋅B22 = A11⋅B22+A12⋅B22 P3 = S3⋅B11 = A21⋅B11+A22⋅B11 P4 = A22⋅S4 = A22⋅B21−A22⋅B11 P5 = S5⋅S6 = A11⋅B11+A11⋅B22+A22⋅B11+A22⋅B22 P6 = S7⋅S8 = A12⋅B21+A12⋅B22−A22⋅B21−A22⋅B22 P7 = S9⋅S10 = A11⋅B11+A11⋅B12−A21⋅B11−A21⋅B12 注意，上述公式中只有中间一列需要计算。右边这列只是说明这些乘积与原始子矩阵的关系 . 通过Pi矩阵的不同组合进行加减运算 计算 C11,C12,C21,C22 ，花费时间 Θ(n^2) 。 C11 = P5+P4−P2+P6 C12 = P1+P2 C21 = P3+P4 C22 = P5+P1−P3−P7 得到如下描述Strassen算法运行时间 T(n)的递归式 用常数次矩阵乘法的代价减少了一次矩阵乘法的递归使得子问题规模减少一个 伪代码 If n = 1 Output A × B Else Compute A11,B11, . . . ,A22,B22 % by computing m = n/2 P1 Strassen(A11,B12 − B22) P2 Strassen(A11 + A12,B22) P3 Strassen(A21 + A22,B11) P4 Strassen(A22,B21 − B11) P5 Strassen(A11 + A22,B11 + B22) P6 Strassen(A12 − A22,B21 + B22) P7 Strassen(A11 − A21,B11 + B12) C11 P5 + P4 − P2 + P6 C12 P1 + P2 C21 P3 + P4 C22 P1 + P5 − P3 − P7 Output C End If 三次乘法完成复数相乘 有两个复数m=a+b*i,n=c+d*i,现在计算它们的乘法，设计一个只使用三次实数乘法的算法来完成m和n的计算。 [!note] 复数乘法的计算公式：m*n=（a*c-b*d）+(a*d+b*c)i C1=ad, C2=bc, C3=(a+b)(c-d)， 虚部为C1+C2，实部为C3+C1-C2，计算完毕。 二维极大点问题 问题描述 支配规则：在二维空间中，如果x1>x2，且y1>y2，那么称点(x1,y1)支配点(x2,y2) 极大点：如果一个点没有被其他点支配，则称其为极大点。 求极大点问题：已知有n个点的集合，找出其中的所有极大点。 分治策略 分：设计中位线L，将整个点集分为两个子集SL和SR ​ 中位线：垂直于X轴的中位线L，l对集合S中的所有点按x值排序(预处理)后，寻找第n/2点位置 治：分别找出SL和SR的极大点 合：基于支配规则合并SL和SR的极大点(l对于SL中的极大点p，如果yp小于SR中极大点的y值，则p被支配，舍弃掉) 递归出口：如果集合S中只有一个点，那么该点为极大点 #include #include using namespace std; struct Point { int x; int y; }; //S预处理排序 vector find_maxima(vector S) { if (S.size() == 1) { return S; } int n = S.size(); auto mid = S.begin() + n / 2; // 使用nth_element将数组分为两部分，左半部分x较小，右半部分x较大 nth_element(S.begin(), mid, S.end(), [](const Point& a, const Point& b) { return a.x SL(S.begin(), mid); vector SR(mid, S.end()); vector sl_maxima = find_maxima(SL); vector sr_maxima = find_maxima(SR); // 计算SR的极大点中的最大y值 int max_y_sr = 0; for (const auto& p : sr_maxima) { if (p.y > max_y_sr) { max_y_sr = p.y; } } // 过滤SL的极大点，保留y大于max_y_sr的点 vector merged; for (const auto& p : sl_maxima) { if (p.y > max_y_sr) { merged.push_back(p); } } // 添加SR的所有极大点 merged.insert(merged.end(), sr_maxima.begin(), sr_maxima.end()); return merged; } 用代入法求解递归式 [!note] 代入法求解递归式分为两步： L猜测解的形式。 用数学归纳法求出解中的常数，并证明解是正确的。 当将归纳假设应用于较小的值时，我们将猜测的解代入函数，因此得名“代入法”。 数学归纳法要求我们证明解在边界条件下也成立。 通常证明对于归纳证明，边界条件适合作为基本情况 对于我们所要讨论的大多数递归式来说，扩展边界条件使归纳假设对较小的n成立，例如个可以设一个常数n0 ，叧要求对n>=n0时能够得证即可。 先证明较松的上下界，然后逐步降低上界，提高下界。 [!warning] 只能用于解的形式很容易猜的情况，不存在通用的方法来猜测递归式的正式解。 在归纳假设不够强，无法证出准确的界。当遇到这种障碍时，如果修改猜测，将它减去一个低阶的项，数学证明常常能顺利进行。 使用渐近符号很容易出错。 一个小的代数运算可以将一个未知的递归式变成你所熟悉的形式。 用递归树方法求解递归式 [!note] 在递归树中，每个结点表示一个单一子问题的代价，子问题对应某次递归函数调用。 我们将树中每层中的代价求和，得到每层代价，然后将所有层的代价求和，得到 所有层次的递归调用的总代价。 递归树最适合用来生成好的猜测，然后即可用代入法来验证猜测是否正确。 用主方法求解递归式(主定理) 主方法为如下形式的递归式提供了一种”菜谱”式的求解方法 [!important] T(n) = aT(n/b) + f(n) (4. 20) 其中a>=l 和b>=l是常数， f(n)是渐近正函数。 递归式(4.20)描述的是这样一种算法的运行时间：它将规模为n的问题分解为a 个子问题， 每个子问题规模为 n/b, 其中 a 和b 都是正常数。 a个子问题递归地进行求解，每个花费时间 T(n/b) 。 函数 f(n)包含子问题分解和子间题解合并的代价 [!note] 定理4.1(主定理）: 令a>=l 和b>=l是常数， f(n)是一个函数， T(n)是定义在非负整数上的递归式：T(n) = aT(n/b) + f(n) 通俗的解释： [!note] a：归约后的子问题个数 n/b：规约后子问题的规模 O(n^d)：归约过程及组合子问题的解的工作量（多项式） ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 04_分治策略 "},"docs/DataStructure_and_Algorithms/Algorithms/15_动态规划.html":{"url":"docs/DataStructure_and_Algorithms/Algorithms/15_动态规划.html","title":"15_动态规划","keywords":"","body":" 动态规划 钢条切割 自顶向下递归实现 动态规划方法求解 子问题图 重构解 矩阵链乘法 矩阵相乘 矩阵链乘法问题 计算括号化方案数量 应用动态规划方法 1.最优括号化方案的结构特征 2. 一个递归求解方案 3.计算最优代价 4. 构造最优解 实现矩阵链最优代价乘法计算的真正计算过程 动态规划原理 最优子结构 重叠子问题 重构最优解 备忘 最长公共子序列 问题概念 步骤 1 : 刻画最长公共子序列的特征 定理14.1（LCS的最优子结构）(Theorem 14.1 (Optimal substructure of an LCS)) 步骤2: 一个递归解 步骤3: 计算LCS的长度 步骤4: 构造LCS 改进代码 最长递增子序列问题 方法一：自底向上动态规划 方法二：贪心+动态规划+二分查找 最优二叉搜索树 问题概念 步骤 1 : 最优二叉搜索树的结构 步骤2: 一个递归算法 步骤3: 计算最优二叉搜索树的期望搜索代价 构造最优解 优化 有向无环图中的最长路径问题 问题 解答 最长回文子序列 问题： 类似题目：最长回文子串 双调欧几里得旅行商问题 问题 解答 多段图问题 问题 解答 多段图向后处理递推关系式 多段图的向前处理算法 货郎担问题（欧几里得旅行商问题） 问题 解答 0/1背包问题 问题 解法一：动态规划 解法二：记忆化搜索 解法三：序偶对法 权值之和最大的兼容活动子集 方法一：动态规划（区间两个端点都不固定） 方法二：动态规划（区间一个端点固定，另一个端点不固定） 方法三：动态规划（区间一个端点固定，另一个端点不固定）二分查找优化 可靠性设计问题 问题 解答 流水线调度问题 问题 动态规划 [!note] 动态规划(dynamic programming)与分治方法相似，都是通过组合子问题的解来求解原问题（在这里， programming指的是一种表格法，并非编写计算机程序）。 动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子问题（子问题 的求解是递归进行的，将其划分为更小的子子问题） 在这种情况下，分治算法会做许多不必要的 工作，它会反复地求解那些公共子子问题。而动态规划算法对每个子子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都重新计算，避免了这种不必要的计算工作。 [!important] 动态规划方法通常用来求解最优化问题(optimization problem)。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。我们称这样的解为问题的一个最优解(an optimal solution), 四个步骤设计一个动态规划算法 刻画一个最优解的结构特征。 递归地定义最优解的值。 （动态转移方程） 计算最优解的值，通常采用自底向上的方法。 利用计算出的信息构造一个最优解。 如果我们仅仅需要一个最优解的值，而非解本身，可以忽略步骤4。例如求最大子数组的值，并不需要求出最大子数组的范围 需要在执行步骤3 的过程中维护一些额外信息，以便用来构造一个最优解。 钢条切割 钢条切割问题是这样的：给定一段长度为n英寸的钢条和一个价格表pi(i=l, 2, …, n), 求切割钢条方案，使得销售收益r最大。 注意，如果长度为n英寸的钢条的价格Pn足够大，最优解可能就是完全不需要切割。 长度为n英寸的钢条共有2^n-1种不同的切割方案，因为在距离钢条左端i(i=l, 2, …, n—1)英寸处，我们总是可以选择切割或不切割 用普通的加法符号表示切割方案：n= i1+i2+...+ik，将钢条切割为长度分别为i1,i2 , …， ik的小段 得到最大收益 rn = P(i1), + P(i2)+…+ P(ik). 更一般地，对于r.(n~l), 我们可以用更短的钢条的最优切割收益来描述它： [!note] 先求解形式完全一样，但规模更小的子问题：当完成首次切割后，我们将两段钢条看成两个独立的钢条切割问题实例 通过组合两个相关子问题的最优解，并在所有可能的两段切割方案中选取组合收益最大者，构成原问题的最优解 称钢条切割问题满足最优子结构(optimal substructure)性质：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。 自顶向下递归实现 [!tip] 钢条切割问题还存在一种相似的但更为简单的递归求解方法 问题分解的方式为：将长度为n的钢条分解为左边开始一段， 以及剩余部分继续分解的结果。 即从钢条上切下长度为 i 的一段，且这段不再分割，对剩下的长度为 n−i 进行递归求解。 自顶向下递归实现 CUT-ROD反复地用相同的参数值对自身进行递归调用，即它反复求解相同的子问题，导致CUT-ROD 的效率这么差？ //价格数组p[l.. n]和整数n为输入，返回长度为n的钢条的最大收益 CUT-ROD(p, n) if n==O return O q = -oo for i=l to n q=max(q,p[i]+CUT-ROD(p,n-i)) return q 动态规划方法求解 动态规划方法仔细安排求解顺序，对每个子问题只求解一次，并将结果保存下来 [!important] 空间换时间 动态规划方法是付出额外的内存空间来节省计算时间，是典型的时空权衡(time-memory trade-off) 的例子 动态规划有两种等价的实现方法: 第一种方法称为带备忘的自顶向下法(记忆化搜索) 按自然的递归形式编写过程，但过程会保存每个子问题的解（通常保存在一个数组或散列表中） 第二种方法称为自底向上法 一般需要恰当定义子问题”规模\" 的概念，使得任何子问题的求解都只依赖于“更小的“子问题的求解，以将子问题按规模排序，按由小至大的顺序进行求解，即求出状态转移方程 自顶向下CUT-ROD过程的伪代码，加入了备忘机制： MEMOIZED-CUT-ROD(p,n) let r[ 0 .. n]be a new array //将辅助数组 r[O.. n]的元素均初始化为MIN, 这是一种常见的表示“未知值”的方法 for j = 0 ton r[i]=-oo return MEMOIZED-CUT-ROD-AUX(p,n,r) MEMOIZED-CUT-ROD-AUX(p,n,r) if r[n]>=0 return r[n] if n==0 q = 0 else q= —oo for i=1 to n q=max(q,p[i]+MEMOIZED-CUT-ROD-AUX(p,n—i, r)) r[n]=q return q 重构解版本：通过s数组记录切割方案 MEMOIZED-CUT-ROD(p, n) let r[0 : n] and s[0 : n] be a new array for i = 0 to n r[i] = -∞ (val, s) = MEMOIZED-CUT-ROD-AUX(p, n, r, s) j = n while j > 0 print s[j] // cut location for length n j = j - s[j] // length of the remainder of the rod MEMOIZED-CUT-ROD-AUX(p, n, r, s) if r[n] ≥ 0 // already have a solution for length n ? return r[n] if n == 0 q = 0 else q = -∞ for i = 1 to n // i is the position of the first cut (val, s) = MEMOIZED-CUT-ROD-AUX(p, n - i, r, s) if q 修改CUT-ROD和MEMOIZED-CUT-ROD-AUX，使得其for循环轮数降为 ⌊n/2⌋ 而不是 n ，需要如何对过程进行修改？运行时间如何变化？ MEMOIZED-CUT-ROD(p, n) let r[0 : n] be a new array // will remember solution values in r for i = 0 to n r[i] = -∞ return MEMOIZED-CUT-ROD-AUX(p, n, r) MEMOIZED-CUT-ROD-AUX(p, n, r) if r[n] ≥ 0 // already have a solution for length n ? return r[n] if n == 0 q = 0 else q = p[n] for i = 1 to ⌊n / 2⌋ // i is the position of the first cut q = max{q, MEMOIZED-CUT-ROD-AUX(p, i, r) + MEMOIZED-CUT-ROD-AUX(p, n - i, r)} r[n] = q // remember the solution value for length n return q 自底向上版本 BOTTOM-UP-CUT-ROD(p,n) let r[O .. n]be a new array r[0]=0 for j=1 to n q= —oo for i=1 to j q=max(q,p[i]+r[j-i]) r[j]=q return r[n] 子问题图 子问题图：动态规划问题所涉及的子问题及子问题之间的依赖关系 它是一个有向图，每个顶点唯一地对应一个子问题。 若求子问题x的最优解时需要直接用到子问题y的最优解，那么在子问题图中就会有一条从子问题x的顶 点到子问题y的顶点的有向边。 可以将子问题图看做自顶向下递归调用树的“简化版”或 “收缩版“，因为树中所有对应相同子问题的结点合并为图中的单一顶点，相关的所有边都从父结点指向子结点 自底向上的动态规划方法处理子问题图中顶点的顺序 对于一个给定的子问题x, 在求解它之前求解邻接至它的子问题y 自底向上动态规划算法是按“逆拓扑序\"或“反序的拓扑序\" 来处理子问题图中的顶点 对于任何子问题，直至它依赖的所有子问题均已求解完成，才会求解它 重构解 以扩展动态规划算法，使之对每个子问题不仅保 存最优收益值，还保存对应的切割方案。利用这些信息，我们就能输出最优解。 //切割下来的每段钢条的长度 s[l.. n]，例如s[5]=1表示长度为5的钢条切割为1和s[4]继续切割 EXTENDED-BOTTOM-UP-CUT如ROD(p,n) let r[O .. n]and s[O .. n]be new arrays r[0]=0 for j=1 to n q=-oo for i=1 to j if q 对钢条切割问题进行一点修改，除了切割下的钢条段具有不同价格 pi 外，每次切割还要付出固定的成本c。 //切割下来的每段钢条的长度 s[l.. n]，例如s[5]=1表示长度为5的钢条切割为1和s[4]继续切割 EXTENDED-BOTTOM-UP-CUT如ROD(p,n) let r[O .. n]and s[O .. n]be new arrays r[0]=0 for j=1 to n q=p[j] s[j]=j for i=1 to j-1 //等于自身时不切割 if q [!note] 斐波那契数列可以用递归式(3.22)定义。设计一个 O(n)时间的动态规划算法计算第 n 个斐波那契数。 写出动态转移方程： num[0]=1,num[1]=1; i>1;num[i]=num[i-1]+num[i-2]; //求前n个斐波那契数 vector Fib(n); { vector num; if(n==1)return {1}; else num.push_back(1); if(n==2)return {1,1}; else num.push_back(1); for(int i=2;i 矩阵链乘法 矩阵相乘 给定一个n个矩阵的序列（矩阵链），我们希望计算它们的乘积A1A2...An 可以先用括号明确计算次序，由于矩阵乘法满足结合律，因此任何加括号的方法都会得到相同的计算结果，然后利用标准的矩阵相乘算法进行计算。 [!note] 们称有 如下性质的矩阵乘积链为完全括号化的(fully parenthesized) : 它是单一矩阵，或者是两个完全括号化的矩阵乘积链的积，且已外加括号。 则共有 5 种 完全括号化的矩阵乘积链： 两个矩阵A和B只有相容(compatible), 即 A 的列数等于B 的行数时，才能相乘。 A 是pXq的矩阵， B是qXr的矩阵，那么乘积C是pXr的矩阵，标量乘法的次数决定，即pqr。 对矩阵链加括号的方式会对乘积运算的代价产生巨大影响，不同加括号方式进行标量乘法的次数不同 矩阵链乘法问题 [!important] 给定 n 个矩阵的链，相邻的矩阵相容，求完全括号化方案，使得计算乘积A1A2…An所需标量乘法次数最少。 计算括号化方案数量 穷举所有可能的括号化方案： 一个相似的递归公式产生的序列为卡特兰数(Catalan numbers) , 这个 序列的增长速度为O(4^n/n^(3/2))= 0(2^n) 应用动态规划方法 刻画一个最优解的结构特征。 递归地定义最优解的值。 计算最优解的值，通常采用自底向上的方法。 利用计算出的信息构造一个最优解。 1.最优括号化方案的结构特征 动态规划方法的第一步是寻找最优子结构 本问题的最优子结构: 假设AiAi+i…Aj; 的最优括号化方案的分割点在Ak和 Ak+1之间 继续对“前缀“子链AiAi+1…Ak 进行括号化时，我们应该直接采用独立求解它时所得的最优方案。 有相似的结论： 在原问题AiAi+1...Aj的最优括号化方案中，对子链Ak+1Ak+2...Aj进行括号化的方法，就是它自身的最优括号化方案。 为了构造一个矩阵链乘法问题实例的最优解，我们可以将问题划分为两个子问题(AiAi+1...Ak 和Ak+1Ak+2…Aj的最优括号化问题），求出子问题实例的最优解，然后将子问题的最优解组合起来。 2. 一个递归求解方案 令m[i, j]表示计算矩阵Ai..Aj;所需标量乘法次数的最小值，那么，原问题的最优解计算Ai..An 所需的最低代价就 是m[1, n]。 递归定义m[i, j]: 分割点在矩阵Ak 和Ak+1之间，其中i 用s[i,j]保存AiAi+1…Aj 最优括号化方案的分割点位置k' 即使得m[i, j]=m[i, k]+ m[k+ 1, j] + Pi-1PkPj 成立的 K 值。 3.计算最优代价 每个子问题Ai:j 都需要对应 i 和 j ，且满足 1≤i≤j≤n ，可以推导出 递归算法会在递归树的多个不同分支中遇到同一个子问题。这里总结出能够运用动态规划求解的问题的两个重要特征： 该问题具有最优子结构(optimal structure)。 该问题具有重叠子问题(overlapping subproblems)。 [!important] 采用表格(tabular)法，自底向上动态规划 m[i, j]只依赖于那些少于j-i+1个矩阵链相乘的最优计算代价 p= MATRIX-CHAIN-ORDER(p, n) let m[1 : n, 1 : n] and s[1 : n - 1, 2 : n] be new tables //单一矩阵计算代价为0 for i = 1 to n m[i, i] = 0 for l = 2 to n // l is the chain length for i = 1 to n - l + 1 // chain begins at A_i j = i + l - 1 // chain ends at A_j m[i, j] = ∞ for k = i to j - 1 // try A_i:k A_k+1:j q = m[i, k] + m[k + 1, j] + p_i-1 * p_k * p_j if q 4. 构造最优解 表格s[1:n−1,2:n] 保持了构造最优解的所需信息 PRINT-OPTIMAL-PARENS(s, i, j) if i == j print \"A\"_i else print \"(\" PRINT-OPTIMAL-PARENS(s, i, s[i, j]) PRINT-OPTIMAL-PARENS(s, s[i, j] + 1, j) print \")\" 实现矩阵链最优代价乘法计算的真正计算过程 其输入序列为矩阵链 ⟨A1,A2,…,An⟩ ，表格 s 是通过调用 MATRIX-CHAIN-ORDER 计算出来的 MATRIX-CHAIN-MULTIPLY(A, s, i, j) if i == j return A[i] if i + 1 == j return A[i] · A[j] return MATRIX-CHAIN-MULTIPLY(A, s, i, s[i, j]) · MATRIX-CHAIN-MULTIPLY(A, s, s[i, j] + 1, j) MATRIX-CHAIN-MULTIPLY(A, s, 1, n) [!tip] 类似题目：1. 戳气球;2. 移除盒子 动态规划原理 [!important] 适合应用动态规划方法求解的最优化问题应该具备的两个要素： 最优子结构和子问题重叠。 最优子结构 用动态规划方法求解最优化问题的第一步就是刻画最优解的结构 如果一个问题的最优解包含其子问题的最优解，我们就称此问题具有最优子结构性质 当然，具有最优子结构性质也可能意味着适合应用贪心策略 使用动态规划方法时，我们用子问题的最优解来构造原问题的最优解，所以心确保考察了最优解中用到的所有子问题 发掘最优子结构性质的过程中，实际上遵循了如下的通用模式： [!note] 证明问题最优解的第一个组成部分是做出一个选择，做出这次选择会产生一个或多个待解的子问题。 对于一个给定问题，在其可能的第一步选择中，你假定已经知道哪种选择才会得到最优解。 给定可获得最优解的选择后，你确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间。 利用“剪切—粘贴\"(cut-and-paste)技术证明：作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。 如果原问题的最优解包含多个子问题，通常它们都很相似，我们可以将针对一个子问题的＂剪切—粘贴“论证方法稍加修改，用于其他子问题 一个刻画子问题空间的好经验是：保持子问题空间尽可能简单，只在必要时才扩展它。 对于不同问题领域，最优子结构的不同体现在两个方面： 原问题的最优解中涉及多少个子问题， 以及在确定最优解使用哪些子问题时，我们需要考察多少种选择。 [!tip] 可以用子问题的总数和每个子问题需要考察多少种选择这两个因素的乘积来粗略分析动态规划算法的运行时间 对于钢条切割问题，共有 ®(n)个子问题，每个子问题最多需要考察n种选择，因此运行时间为O(n^2)。 矩阵链乘法问题共有 ®(n^2)个子问题，每个子问 题最多需要考察n-1 种选择，因此运行时间为O(n3)。 子问题图也可用来做同样的分析。图中每个顶点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边。 在动态规划方法中，我们通常自底向上地使用最优子结构。也就是说，首先求得子问题的最优解，然后求原问题的最优解。 求解原问题过程中，我们需要在涉及的子问题中做出选择，选 出能得到原问题最优解的子问题 原问题最优解的代价通常就是子问题最优解的代价再加上由 此次选择直接产生的代价。 [!warning] 贪心算法和动态规划最大的不同在千，它并不是首先寻找子问题的最优解，然后在其中进行选择，而是首先做出一次“贪心”选择——在当时（局 部）看来最优的选择然后求解选出的子问题，从而不必费心求解所有可能相关的子问题。 [!note] 但两个最长简单路径子问题是相关的，而两个最短路径子问题是无关的(independent) 子问题无关的含义是，同一个原问题的一个子问题的解不影响另一个子问题的解。 说两个子问题是相关的：求解一个子问题时用到了某些资源（在本例中是顶点），导致这些资源在求解其他子问题时不可用。 无权最短路径和无权最长路径的根本区别： 无权最短路径问题的子问题是独立(independent)的。根本原因是子问题之间是不共享资源的。可以用反证法证明，如果从 u 到 v 的最短路径经过 w ，即 u⇝p1w⇝p2v ，除 w 外不存在别的顶点同时位于 p1 和 p2 上。 无权最长简单路径问题的子问题不是独立的。根本原因是子问题之间是可以共享资源的。 评：独立一定不相关，不相关不一定独立。 重叠子问题 适合用动态规划方法求解的最优化问题应该具备的第二个性质是子问题空间必须足够“小\"'，即问题的递归算法会反复地求解相同的子间题，而不是一直生成新的子问题 类似于递归出口，递归的基本情况，或者最小子问题 如果递归算法反复求解相同的子问题，我们就称最优化问题具有重叠子问题(overlapping subproblems)性质 与之相对的，适合用分治方法求解的问题通常在递归的每一步都生成全新的子间题。 所以动态规划算法通常这样利用重叠子问题性质： 对每个子问题求解一次，将解存入一个表中，当再次需要这个子问题时直接查表，每次查表的代价为常量时间 [!tip] 将自顶向下的递归算法（无备忘）与自底向上的动态规划算法进行比较，后者要高效得多， 因为它利用了重叠子问题性质。 重构最优解 记录选择 从实际考虑，我们通常将每个子问题所做的选择存在一个表中，这样就不必根据代价值来 重构这些信息。 按选择回溯，或者递推 对矩阵链乘法问题，利用表s[i, j], 我们重构最优解时可以节省很多时间 第一次选择：s[i,j] 第二层：左：s[i,s[i,j]]，右：s[s[i,j],j] …… 备忘 可以保持自顶向下策略，同时达到与自底向上动态规划方法相似的效率。 思路就是对自然但低效的递归算法加入备忘机制 维护一个表记录子问题的解，但仍保持递归算法的控制流程。 带备忘的递归算法为每个子问题维护一个表项来保存它的解。每个表项的初值设为一个特殊值，表示尚未填入子问题的解。 递归调用过程中第一次遇到子问题时，计算其解，并存入对 应表项。随后每次遇到同一个子问题，只是简单地查表，返回其解 矩阵链式乘法备忘版本自顶而下递归O(n^3) MEMOIZED-MATRIX-CHAIN(p, n) let m[1 : n, 1 : n] be a new table for i = 1 to n for j = i to n m[i, j] = ∞ return LOOKUP-CHAIN(m, p, 1, n) //区间左闭右开[i,j) LOOKUP_CHAIN(m, p, i, j) if m[i, j] 自底而上动态规划 def MATRIX_CHAIN_ORDER(p): n = len(p) - 1 # 矩阵的数量 m = [[0] * (n + 1) for _ in range(n + 1)] # 初始化二维表 m # 自底向上计算所有子问题 for length in range(2, n + 1): # 当前链的长度，从2到n for i in range(1, n - length + 2): # 子链的起始位置 j = i + length - 1 # 子链的结束位置 m[i][j] = float('inf') # 初始化为无穷大 for k in range(i, j): # 尝试所有可能的分割点 q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j] if q [!note] 自底向上动态规划和自顶向下动态规划的比较 如果每个子问题都必须求解一次，自底向上动态规划比自顶向下动态规划快，虽然渐近时间一致，但是自底向上动态规划的隐藏系数比自顶向下动态规划的隐藏系数小，因为自底向上动态规划没有递归调用的开销，维护表格的开销也更小。而且通过访问表格，可以进一步减少额外空间开销。 当子问题不需要完全求解时，自顶向下动态规划就比较有优势了，自顶向下动态规划可以只求解那些需要求解的子问题。 最长公共子序列 问题概念 [!tip] 相似性：如果将一个串转换为另一个串所需的操作很少，那么可以说两个串是相似的 最后一种相似度的概念命名为最长公共子序列问题： 另一种衡量串S 和S2 的相似度的方式是：寻找第三个串S3, 它的所有碱基也都出现在S1 和S2 中，且在三个串中出现的顺序都相同，但在S1 和S2 中不要求连续出现。可以找到的 S3 越长，就可以认为 S1 和 S2 的相似度越高。 [!note] 最长公共子序列问题: 简称LCS问题，给定序列 X=⟨x1,x2,…,xm⟩和 Y=⟨y1,y2,…,yn⟩ ，求 X 和 Y 的公共子序列中最长的子序列。 [!warning] 一个给定序列的子序列，就是将给定序列中零个或多个元素去掉之后得到的结果 子序列(subsequence)：给定序列X=⟨x1,x2,…,xm⟩，有子序列 Z=⟨z1,z2,…,zk⟩，那么一定存在一个严格递增序列 ⟨i1,i2,…,ik⟩ ，对于所有的 j=1,2,…,k ，都有 xij=zj。 简单说就是从序列 X 中随机选出 k 个元素按照原来顺序组成序列 Z 。或者从序列 X 中随机删除 m−k 个元素剩余元素组成序列 Z 。 子序列和子串的区别: 子序列中相邻的两个元素在原序列中不一定相邻，仅仅是相对顺序保持不变 子串是从原序列中截取连续的 k 个元素，子串中相邻的两个元素在原序列中一定相邻且相对顺序保持不变 步骤 1 : 刻画最长公共子序列的特征 可以用暴力法求解LCS问题，枚举 X 的所有子序列，逐个检查这些子序列是否是 Y 的子序列，过程中始终保存当前能够找到的最长的那一个。由于 X 有 m 个元素，所以 X 有 2^m 个，暴力法的运行时间为指数级。 LCS问题符合最优子结构特征: 子问题的自然分类对应两个输入序列的“前缀“对 前缀的严谨定义如下：给定一个序列 X=⟨x1,x2,…,xm⟩定义 X 的第i 前缀为 X=⟨x1,x2,…,xi⟩ 定理14.1（LCS的最优子结构）(Theorem 14.1 (Optimal substructure of an LCS)) 给定序列X=⟨x1,x2,…,xm⟩ 和 Y=⟨y1,y2,…,yn⟩ ，子序列 Z=⟨z1,z2,…,zk⟩是 X 和 Y 的最长子序列。 如果xm=yn，那么 zk=xm=yn ，且 Zk−1 是 Xm−1 和 Yn−1 的一个LCS。 如果xm≠yn 且 zk≠xm ，那么 Z 是 Xm−1 和 Y 的一个LCS。 如果xm≠yn且 zk≠yn，那么 Z 是 X 和 Yn−1 的一个LCS。 定理15. 1 告诉我们，两个序列的 LCS包含两个序列的前缀的 LCS。 步骤2: 一个递归解 根据定理14.1，求解序列 X=⟨x1,x2,…,xm⟩和 Y=⟨y1,y2,…,yn⟩的LCS时： 如果xm=yn，需要求解一个子问题，求 Xm−1 和 Yn−1 的一个LCS，将 xm=yn 追加在这个LCS末尾。 如果 xm≠yn ，需要求解两个子问题， Xm−1 和 Y 的一个LCS和 X 和 Yn−1 的一个LCS，取两者中较长的为 X 和 Y 的一个LCS。 所以LCS的问题具有重叠子问题性质。 定义·c[i,j] 为序列 Xi 和 Yj 的一个LCS的长度，则求解LCS问题的递归式如下： [!tip] 对比钢条切割问题，LCS问题加入了判断条件，根据判断条件求解对应的子问题，同时排除了另一部分子问题。 类似地，编辑距离问题(edit-distance problem)具有这样的特点，详见思考题14-5。 步骤3: 计算LCS的长度 LCS问题有 Θ(mn) 个不同的子问题，可以采用自底向上动态规划进行计算。 构造表格 c[0:m,0:n] 用于保存 c[i,j] ，并按照行优先顺序(行主次序)计算表项，即首先由左至右计算c的第一行，然后计算第二行。过程中维护一个表格·b[1:m,1:n]帮助构造最优解， b[i,j] 保存构造最优解 c[i,j] 的选择。 LCS-LENGTH(X, Y, m, n) let b[1 : m, 1 : n] and c[0 : m, 0 : n] be new tables for i = 1 to m c[i, 0] = 0 for j = 0 to n c[0, j] = 0 for i = 1 to m // compute table entries in row-major order for j = 1 to n if x_i == y_j c[i, j] = c[i - 1, j - 1] + 1 b[i, j] = \"↖\" else if c[i - 1, j] ≥ c[i, j - 1] c[i, j] = c[i - 1, j] b[i, j] = \"↑\" else c[i, j] = c[i, j - 1] b[i, j] = \"←\" return c and b 图14.8展示了当 X=⟨A,B,C,B,D,A,B⟩ 和 Y=⟨B,D,C,A,B,A⟩ 时LCS-LENGTH的示意图。 评：辅助表格 b[1:m,1:n] 在代码中一般用int值表示。 另，本题也可以使用记忆化自顶向下动态规划求解，过程MEMOIZED-LIS-LENGTH的伪代码如下： MEMOIZED-LCS-LENGTH-AUX(X, Y, i, j, c, b) //查表 if c[i, j] > -1 return c[i, j] if i == 0 or j == 0 c[i, j] = 0 return c[i, j] if x_i == y_j b[i, j] = \"↖\" c[i, j] = MEMOIZED-LCS-LENGTH-AUX(X, Y, i - 1, j - 1, c, b) + 1 else if MEMOIZED-LCS-LENGTH-AUX(X, Y, i - 1, j, c, b) ≥ MEMOIZED-LCS-LENGTH-AUX(X, Y, i, j - 1, c, b) b[i, j] = \"↑\" c[i, j] = MEMOIZED-LCS-LENGTH-AUX(X, Y, i - 1, j, c, b) else b[i, j] = \"←\" c[i, j] = MEMOIZED-LCS-LENGTH-AUX(X, Y, i, j - 1, c, b) return c[i, j] MEMOIZED-LCS-LENGTH(X, Y) let b[1 : m, 1 : n] and c[0 : m, 0 : n] be new tables for i = 0 to m for j = 0 to n c[i, j] = -1 MEMOIZED-LCS-LENGTH-AUX(X, Y, m, n, c, b) return c and b 不需要构造最优解时 MEMOIZED-LCS-LENGTH(c, X, Y, i, j) if c[i, j] > -1 return c[i, j] if i == 0 or j == 0 return c[i, j] = 0 if x_i == y_j return c[i, j] = LCS-LENGTH(X, Y, i - 1, j - 1) + 1 return c[i, j] = max{LCS-LENGTH(X, Y, i - 1, j), LCS-LENGTH(X, Y, i, j - 1)} LCS-LENGTH(X, Y, m, n) let c[0 : m, 0 : n] be a new table for i = 0 to m for j = 0 to n c[i, j] = -1 MEMOIZED-LCS-LENGTH(c, X, Y, m, n) return c 步骤4: 构造LCS 通过LCS-LENGTH返回的表格，从 b[m,n] 开始，在表格中按照箭头方向追踪下去，可以逆序找出构造LCS的所有元素。递归调用PRINT-LCS可以按照正确顺序打印出 X 和 Y 的一个LCS，伪代码如下： PRINT-LCS(b, X, i, j) if i == 0 or j == 0 return // the LCS has length 0 if b[i, j] == \"↖\" PRINT-LCS(b, X, i - 1, j - 1) print x_i // same as y_i else if b[i, j] == \"↑\" PRINT-LCS(b, X, i - 1, j) else PRINT-LCS(b, X, i, j - 1) PRINT-LCS(b, X, m, n) 因为每次递归调用 i 和 j 至少有一个会减少一，所以PRINT-LCS的运行时间为 O(m+n) 改进代码 对于LCS问题，我们可以去除表格 b ，由于 c[i,j] 仅由 c[i−1,j−1] 或 c[i,j−1] 或 c[i−1,j] 这三项确定，很容易在 O(1) 时间内计算出最优选择方案，这样你可以用类似PRINT-LCS的过程重构LCS代码 PRINT-LCS(c, X, Y, i, j) if c[i, j] == 0 return // the LCS has length 0 if x_i == y_j PRINT-LCS(c, X, Y, i - 1, j - 1) print x_i // same as y_i else if c[i - 1, j] > c[i, j - 1] PRINT-LCS(c, X, Y, i - 1, j) else PRINT-LCS(c, X, Y, i, j - 1) PRINT-LCS(c, X, Y, m, n) 其实表格 c 只需要两行，由于每次表格 c 中下一行的计算仅仅依赖于上一行，练习14.4-4要求实现这个方案。但如果仅仅需要求解一个LCS的长度，这个方案是可行的，但是要构造出一个LCS，那么这个表格中保存的信息不支持在 Θ(m+n) 时间内完成构造。 这里提到了用滚动数组优化空间复杂度，但是滚动数组的缺陷也是显而易见的 这里构造的两行或者两列下标分别为 0 和 1 ，因为0=¬1 1=¬0 所以直接对下标取反就行进行下标切换，相当于进行了exchange操作。 LCS-LENGTH(X, Y, m, n) if m>n{swap(m,n), swap(X,Y)} let c[0 : m, 0 : 1] be a new table c[0, 1] = 0 for i = 0 to m c[i, 0] = 0 curr = 1 // current column index prev = 0 // previous column index for j = 1 to n // compute table entries in row-major order for i = 1 to m if x_i == y_j c[i, curr] = c[i - 1, prev] + 1 else if c[i, prev] ≥ c[i - 1, curr] c[i, curr] = c[i, prev] else c[i, curr] = c[i - 1, curr] curr = ┐curr prev = ┐prev return c[m, curr] 最长递增子序列问题 简称 LIS (longest increasing subsequence problem)问题，是一道非常经典的动态规划问题。设给定序列 X=⟨x1,x2,…,xn⟩ 。求出X中最长的递增子序列 注意，这里要求出一个序列，不仅仅是序列长度。 最长递增子序列可能存在多个，这里仅求其中之一。 方法一：自底向上动态规划 构造数组 C[0:n] ，其中 ci 为以 X 第 i 数 xi 结尾的 LIS 的长度，构造数组B[1:n] ，其中 bi 为以 X 第 i 数 xi 结尾的 LIS 的前一个数的下标。构造边界 x0=−∞ 。 该LIS算法的运行时间为 O(n^2) 。 方法二：贪心+动态规划+二分查找 一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小 基于上面的贪心思路，我们维护一个数组 D ， d[i] 表示长度为 i 的最长上升子序列的末尾元素的最小值，用lis-length 记录目前最长上升子序列的长度，起始时 lis-length=1 ， d[1]=x1 。 依次遍历数组 X=⟨x1,x2,…,xn⟩ 中的每个元素，并更新数组 d 和 lis-len 的值。如果 xi>d[lis-len] ，那么更新lis-length=lis-length+1 且 d[lis-length]=xi，否则在 d[1:lis-length]二分查找到第一个大于等于 xi 的元素 d[k] ，并将 d[k] 替换为 xi 。 运行时间为 O(nlg⁡n) 最优二叉搜索树 问题概念 [!note] 最优二叉搜索树(optimal binary search tree)：给定一个由 n 个互不相同的关键字组成的序列 K=⟨k1,k2,…,kn⟩，其中 k1，用这些关键字构造一棵二叉搜索树。 对于每个关键字 ki ，查找其的的概率为 pi ，可能有些被查找的关键字不在 K 中，我们需要构造 n+1 个虚关键字d0,d1,d2,…,dn ，其中 d0kn， ki ，对于每个关键字 di ，查找其的的概率为 qi 。每个关键字 ki 对应二叉搜索树中一个内部结点，每个虚关键字 di 对应二叉搜索树中一个叶结点，这样每次查找关键字如果查找成功，那么最终落在 ki ，如果查找失败，那么最终落在 di 。 给定一棵二叉搜索树 T ，假定一次搜索代价为访问的结点数，即此次搜索找到的结点在 T中的深度再加1，那么在 T 中进行一次搜索期望的代价为： i对于一个给定的概率集合，我们希望构造一棵期望搜索代价最小的二叉搜索树，我们称这样一棵二叉搜索树为最优二叉搜索树。 最优二叉搜索树不一定是高度最矮的，最优二叉搜索树的根结点中的关键字也不一定是概率最高的关键字。 步骤 1 : 最优二叉搜索树的结构 从观察子树特征开始。考虑一棵二叉搜索树的任意子树。 给定一棵二叉搜索树，考虑其中任意一棵子树，包含关键字 ki…kj ，其中 1≤i≤jdi−1,di,…,dj的叶结点。 最优子结构：如果一棵最优二叉搜索树 T 有一棵包含关键字 ki,…,kj 的子树 T′ ，那么 T′ 一定是包含关键字 ki…kj 和虚关键字 di−1,di,…,dj 的子问题的最优解 步骤2: 一个递归算法 设最优二叉搜索树问题的子问题中包含关键字 ki…kj ，其中 i≥1,j≤n,j≥i−1 （当 j=i−1 时，只只包含虚关键字 di−1 ）。定义 e[i,j] 为在包含关键字 ki…kj 的最优二叉搜索树中进行一次关键字搜索的期望代价。最终我们的目标是求出 e[1,n] 。 当 j=i−1 时，子问题只包含虚关键字 di−1 ，搜索的期望代价为 e[i,i−1]=qi−1 。 当 j≥i 时，设子树根结点关键字为 kr ，左子树包含关键字 ki,…,kr−1 ，右子树包含关键字 kr+1,…,kj 。 当一棵树成为一个结点的一个子树时，树中所有结点的深度都要加一。 包含关键字 ki…kj 的子树，定义子树中所有关键字和虚关键字的概率和为： 步骤3: 计算最优二叉搜索树的期望搜索代价 解最优二叉搜索树和矩阵链乘法的一些相似之处。它们的子问题都由连续的下标子域组成 将 e[i,j] 保存在表格e[1:n+1,0:n] ，第一个下标到 n+1 是因为需要考虑只包含伪关键字dn 的子树 的情况，即 e[n+1,n] ，第二个下标从 0 开始是因为需要考虑于只包含伪关键字d0 的子树的情况，即 e[1,0] 。 为了避免每次计算 e[i,j] 时花费 Θ(j−i) 次加法重新计算 w(i,j) ，将 w[i,j] 保存在表格 w[1:n+1,0:n] ，递归式： 程序OPTIMAL-BST输入为概率表 p1,…,pn 和 q0,…,qn 以及规模 n ，输出表格 e 和 root ，伪代码如下： OPTIMAL-BST(p, q, n) let e[1 : n + 1, 0 : n], w[1 : n + 1, 0 : n], and root[1 : n, 1 : n] be new tables for i = 1 to n + 1 // base cases e[i, i - 1] = q_{i-1} // equation (14.14) w[i, i - 1] = q_{i-1} for l = 1 to n for i = 1 to n - l + 1 j = i + l - 1 e[i, j] = ∞ w[i, j] = w[i, j - 1] + p_j + q_j // equation (14.15) for r = i to j // try all possibles roots r t = e[i, r - 1] + e[r + 1, j] + w[i, j] //equation (14.14) if t 程序OPTIMAL-BST的运行时间为 Θ(n3) 。 构造最优解 写出程序 CONSTRUCT-OPTIMAL-BST(root,n) 的伪代码，给定表格root[1:n,1:n] ，输出最优二叉搜索树的结构。 解答： 对应第三版15.5-1。 CONSTRUCT-OPTIMAL-BST-AUX(root, i, j, r) if i == j return if r == 0 print root[i, j] + \"is the root\" else if j 优化 对所有 1≤i 解答： 对应第三版15.5-4。 仅需要修改OPTIMAL-BST第10行代码，修改后伪代码如下： OPTIMAL-BST(p, q, n) let e[1 : n + 1, 0 : n], w[1 : n + 1, 0 : n], and root[1 : n, 1 : n] be new tables for i = 1 to n + 1 // base cases e[i, i - 1] = q_{i-1} // equation (14.14) w[i, i - 1] = q_{i-1} for l = 1 to n for i = 1 to n - l + 1 j = i + l - 1 e[i, j] = ∞ w[i, j] = w[i, j - 1] + p_j + q_j // equation (14.15) for r = r[i, j - 1] to r[i + 1, j] // try all possibles roots r t = e[i, r - 1] + e[r + 1, j] + w[i, j] //equation (14.14) if t 有向无环图中的最长路径问题 问题 Longest Path in DAG 给定一个有向图(Directed Acyclic Graph)以及一个起点s，求该图中s点到其余所有点的最长路径。 解答 最长路径问题不具有最优子结构属性。事实上，最长路径问题对于一般的图来说是NP-Hard问题。然而，对于有向无环图的最长路径问题，其具有线性时间解。这个想法类似于有向无环图中最短路径的线性时间解决方案，我们使用拓扑排序 将到所有顶点的距离初始化为负无穷大，到源点的距离初始化为 0 图的拓扑排序。图的拓扑排序表示图的线性排序（图b是图a的线性表示） 按照拓扑顺序一一处理所有顶点。对于正在处理的每个顶点，我们使用当前顶点的距离更新其相邻的距离。 按拓扑顺序对每个顶点 u 执行以下作。 ..对 u 的每个相邻顶点 v 执行以下作 ……if （dist[v] ………距离[v] = 距离[u] + 权重（u， v） 使用 DP 求最长路，使时间复杂度优化到 O(m+n)。状态转移方程为dis_v = max(dis_v, dis_u + w_{u,v})。 // The function to find longest distances from a given vertex. // It uses recursive topologicalSortUtil() to get topological // sorting. void Graph::longestPath(int s) { stack Stack; int dist[V]; // Mark all the vertices as not visited bool* visited = new bool[V]; for (int i = 0; i ::iterator i; if (dist[u] != NINF) { for (i = adj[u].begin(); i != adj[u].end(); ++i){ if (dist[i->getV()] getWeight()) dist[i->getV()] = dist[u] + i->getWeight(); } } } 最长回文子序列 问题： 回文(palindrome)是正序与逆序相同的非空字符串。 设计高效算法，求给定输入字符串的最长回文子序列。 最优子结构：是回文子序列，并且长度大于 2，那么将它首尾的两个字符去除之后，它仍然是个回文子序列。因此可以用动态规划的方法计算给定字符串的最长回文子序列。 dp[i][j] 表示字符串 s 的下标范围 [i,j] 内的最长回文子序列的长度。 由于任何长度为 1 的子序列都是回文子序列，因此动态规划的边界情况是，对任意 0≤in，都有 dp[i][i]=1。 当 ij 时，计算 dp[i][j] 需要分别考虑 s[i] 和 s[j] 相等和不相等的情况 如果 s[i]=s[j]，则首先得到 s 的下标范围 [i+1,j−1] 内的最长回文子序列，然后在该子序列的首尾分别添加 s[i] 和 s[j]，即可得到 s 的下标范围 [i,j] 内的最长回文子序列，因此 dp[i][j]=dp[i+1][j−1]+2； 如果 s[i]!=s[j]，则 s[i] 和 s[j] 不可能同时作为同一个回文子序列的首尾，因此 dp[i][j]=max(dp[i+1][j],dp[i][j−1]) class Solution { public: int longestPalindromeSubseq(string s) { int n=s.size(); if(n==0)return 0; vector m(n,vector(n,0)); for(int i=0;i=0;i--) for(int j=i+1;j 类似题目：最长回文子串 给你一个字符串 s，找到 s 中最长的 回文 子串。 对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。这样就有了最优子结构 依次构造动态转移方程 首先每个字符为最小回文子串长度为一 P(i,j) 表示字符串 s 的第 i 到 j 个字母组成的串（下文表示成 s[i:j]）是否为回文串 长度大于3时：P(i,j)=P(i+1,j−1)∧(Si==Sj) 只有 s[i+1:j−1] 是回文串，并且 s 的第 i 和 j 个字母相同时，s[i:j] 才会是回文串。 长度为2或者3时：对于长度为 2 的子串，只要它的两个字母相同，它就是一个回文串 最终的答案即为所有 P(i,j)=true 中 j−i+1（即子串长度）的最大值 其实这道题就是回文子序列的基础上增加了约束条件，即必须是连续字串 直接考虑自底而上的动态规划 class Solution { public: string longestPalindrome(string s) { int n=s.size(); vector> m(n,vector(n,false)); //长度为一的回文字串 for(int i=0;i=0;i--) for(int j=i+1;j 双调欧几里得旅行商问题 问题 旅行商问题描述：平面上n个点，确定一条连接各点的最短闭合旅程。这个解的一般形式为NP的（在多项式时间内可以求出） J.L. Bentley 建议通过只考虑双调旅程(bitonictour)来简化问题,这种旅程即为从最左点开始，严格地从左到右直至最右点，然后严格地从右到左直至出发点。下图(b)显示了同样的7个点的最短双调路线。在这种情况下，多项式的算法是可能的。事实上，存在确定的最优双调路线的O(n*n)时间的算法。 设计一个O(n2)时间的最优双调巡游路线算法。你可以认为任何两个点的x坐标均不 同，且所有实数运算都花费单位时间。（提示：由左至右扫描，对巡游路线的两个部分分别维护可能的最优解。） 解答 首先将各点按照x坐标从小到大排列，时间复杂度为O(nlgn)。 最优子结构：定义从Pi到Pj的路径为：从Pi开始，从右到左一直到P1，然后从左到右一直到Pj。在这个路径上，会经过P1到Pmax(i,j)之间的所有点且只经过一次。 定义d(i,j)为满足这一条件的最短路径。我们只考虑i>=j的情况 最优解：需要求的是d(n,n) 当j d(i,j) = d(i-1,j) + dist(i - 1,i)。 由定义可知，点Pi-1一定在路径Pi-Pj上，而且又由于j 当j = i - 1时，d(i,j) = d(i,i-1) = min{d(k,j) + dist(i,k)},其中1 与Pi左相邻的那个点可能是P1到Pi-1总的任何一个。因此需要递归求出最小的那个路径： 当j=i时，d(i,i) = min{d(i,1)+dist(1,i),...,d(i,i-1),dist(i-1,i)}. 路径上最后相连的两个点可能是P1-Pi、P2-Pi...Pi-1-Pi。 double DP(tagPoint *points,int n) { double b[MaxLen][MaxLen];//记录最短路径的长度 //计算所有情况下的b[i][j]，1 多段图问题 问题 设图 G =（V,E）是一个带权有向图，如果把顶点集合 V 划分成 k 个互不相交的子集 Vi（2，使得 E 中的任何一条边 ，必有 u∈Vi, v∈Vi + m(1,则称图 G 为多段图，称 s∈V1 为源点，t∈Vk 为终点。多段图的最短路径问题为从源点到终点的最小代价路径。 解答 最优子结构： [!important] 设一个多段图有且仅有一个起点 S，有且仅有一个终点 T，S->S1->S2->…Sn->T 为从起点 S 到终点 T 的最短路径。其中`Si属于Vi 设 V0->V1 的开销已经求出，则从起点 S 到终点 T 的最小开销的求解将转换为对V1 到终点 T 的最小开销进行求解。 假设 S1->S2->S3…Sn->T 不是点 S1 到终点 T 的最短路径，则必然存在另一条路径 S1->R1->R2…Rn->T 的开销小于 S1->S2->S3…Sn->T 的路径开销，进而推出起点 S 到终点 T 的最短路径为 S->S1->R1->R2…Rn->T。然而已知路径 S->S1->S2->…Sn->T 为起点 S 到终点 T 的最短路径，不可能存在其他路径的总开销比该路径的开销还要小，产生了矛盾，因此多段图的最短路径问题满足最优子结构。 多段图向后处理递推关系式 设 Cuv 为多段图有向边 的权值，源点 s 到终点 v 的最短路径长为 d(s,v)，终点为 t，则可以得到该问题的状态转移方程为： COST(j)= min{COST(l)+ c(l , j)} 这里其实类似于Dijkstra最短路径算法，因为多段图其实也是一个图，只不过是一个特殊的图，被分成k个集合，只有相邻集合的节点之间才可能有边 其实就是类似于最长递增子序列，不过这里更新的条件是更小的距离 O(n^2) //邻接矩阵g,多段图v int FGRAPH(vector>> g,vector> v) { int n=g.size(); vector cost(n,INT_MAX); vector path(n,-1);//记录前驱节点 cost[0]=0;//到自身距离为0 for(int i=1;i有边 { int now_cost=cost[u]+g[u][v]; if(cost[v]>now_cost){ cost[v]=now_cost; path[v]=u; } } } return cost[n-1]; } 多段图的向前处理算法 从后往前递推 COST(i, j)= min{ c(j, l)+ COST(i+1, l)}, l∈Vi+1 , ∈E, c(j, l)该边的成本 //邻接矩阵g,多段图v int FGRAPH(vector>> g,vector> v) { int n=g.size(); vector cost(n,INT_MAX); vector path(n,-1);//记录后驱节点 cost[n-1]=0;//到自身距离为0 for(int i=n-1;i>0;i++) { for(int j=i-1;j>=0;j++) if(g[j][i]!=INT_MAX) { int now_cost=cost[i]+g[j][i]; if(cost[j]>now_cost){ cost[j]=now_cost; path[j]=i; } } } return cost[n-1]; } [!tip] 多段图的应用 考虑把n个资源分配给r个项目的问题，要求使得总净利达到最大值 例题： 货郎担问题（欧几里得旅行商问题） 问题 有n个城市，用1，2，…，n表示，城i,j之间的距离为dij，有一个货郎从城1出发到其他城市一次且仅一次，最后回到城市1，求解经过所有点的最短巡游路线 [!tip] 经典模型 邮车收集邮件的邮路问题 假定有一辆邮车要到n个不同的地点收集邮件，最后回到起始点 邮车所行经的路线是一条周游路线，希望求出具有最小长度的周游路线。 机械手臂在装配线上的移动问题 机械手由其初始位置(该位置在第一个要紧固的螺帽的上方)开始， 依次移动到其余的每一个螺帽，最后返回到初始位置。 机械手移动的路线就是以螺帽为结点的一个图中的一条周游路线。 一条最小成本周游路线将使这机械手完成其工作所用的时间取最小值。 机械手臂在装配线上的移动问题 第三个例子是产品的生产安排问题。 假设要在同一组机器上制造n种不同的产品，生产是周期性进行的， 即在每一个生产周期这n种产品都要被制造。 要生产这些产品有两种开销，一种是制造第i种产品时所耗费的资金(1≤i≤n)，称为生产成本， 另一种是这些机器由制造第i种产品变到制造第j种产品时所耗费的开支cij称为转换成本。 显然，生产成本与生产顺序无关。 于是，我们希望找到一种制造这些产品的顺序， 使得制造这n种产品的转换成本和为最小。 由于生产是周期进行的，因此在开始下一周期生产时也要开支转换成本， 它等于由最后一种产品变到制造第一种产品的转换成本。 于是，可以把这个问题看成是一个具有n个结点，边成本为cij图的货郎担问题。 等价于求图的最短哈密尔顿回路问题）令G=(V, E)是一个带权重的有向图，顶点集V=(v0, v1, ..., vn-1)。从图中任一顶点vi出发，经图中所有其他顶点一次且只有一次，最后回到同一顶点vi的最短路径。 解答 最优子结构： [!note] 如果这条周游路线是最优的, 则这条由k到1的路径必定是通过V-{1,k}中所有结点的由k到1的最短路径 设g(i,S)是由结点i开始, 通过S中的所有结点, 在结点1终止的一条最短路径长度。 所以g(1,V-{1})是一条最优的周游路线长度 递推的时候需要遍历集合 S 中的所有节点，找到最小成本路线 初始时，集合 S 为空集，节点 i 到节点 1 的成本就是两点之间的距离 依次求出 |S|=k 的所有 g(i,S) ，k=0,1...n-1 当 ki≠1，1∉S 且 i∉S` 当 k=n−1 时，求 g(1,V−{1}) ，问题得解 |S|=k，k=0,1,…n-2时，对于k的每一种取值，g(i,S)中的结点i都有n-1种选择， 即i=2,3,..,n，对应每个i的S的个数为Ckn-2 ，S是V-{1,i}的子集 时间复杂度（n^2*2^n) 例题 deepseek代码： def tsp_dynamic_programming(dist): n = len(dist) m = 1 c++:利用掩码表示集合，而非利用vector表示集合 例如，101表示已经访问0号节点和二号节点 // 自定义哈希函数用于pair struct PairHash { template size_t operator()(const pair& p) const { auto hash1 = hash{}(p.first); auto hash2 = hash{}(p.second); return hash1 ^ (hash2 , int, PairHash> memo; // 记忆化缓存 vector> edge; // 邻接矩阵 int n; // 城市总数 public: int tsp(vector>& distances) { edge = distances; n = edge.size(); if (n == 0) return 0; // 初始状态：从0号城市出发，已访问集合只有0号城市（掩码为0b1） return dfs(0, 1 0/1背包问题 [!note] 拓展： 完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。 所以背包问题的理论基础重中之重是01背包，一定要理解透！ 问题 对于n个物品，容量为M的背包，要求物品或者整件装入背包中, 或者根本不装入，即xi限定只能取0或1值。 有N件物品和一个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 解法一：动态规划 最优子结构：首先问题具有最优子结构，对于原问题的最优解，可以分为不同的最优子问题，即及有最大收益的子集同时背包重量减去对于最优解少的那个物品重量 对于容量为WW的背包和nn个物品，考虑是否选择第nn个物品： 不选第n个物品：问题转化为前n−1个物品在容量W下的最大价值。 选第n个物品：问题转化为前n−1个物品在剩余容量W−wn下的最大价值，加上vn。 依此获取动态规划转移方程（递推式）：假设物品依照重量递增排序 设dp[i][j]表示前i个物品在容量j下的最大价值，则： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]) 初始化： 当容量为0时无论几个物品价值都为0：dp[i][0] = 0 //dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值 for (int j = weight[0]; j 最终的初始化 // 初始化 dp vector> dp(weight.size(), vector(bagweight + 1, 0)); for (int j = weight[0]; j 先遍历物品，然后遍历背包重量 for(int i=1;i 先遍历背包，再遍历物品 for(int j=0;j 完整代码（注意重量数组不需要排序） int max_value(vectorweight,vector value,int bagweight) { int n = weight.size(); vector> dp(n, vector(bagweight + 1, 0)); for (int j = weight[0]; j 解法二：记忆化搜索 在动态规划即自底而上的动态规划可以推出自顶而下的动态规划即记忆化搜索 边界条件剩余空间小于当前物品重量或者到达最后一个物品 int max_value(vector>& dp,const vector&weight,const vector& value,int i,int now_weight) { //已经记录了子问题的解 if (dp[i][now_weight] != -1)return dp[i][now_weight]; //最后一个物品能装就装 if (i == 0)return dp[i][now_weight] = weight[0] now_weight ? max_value(dp, weight, value, i - 1, now_weight) : max(max_value(dp, weight, value, i - 1, now_weight), max_value(dp, weight, value, i - 1, now_weight - weight[i]) + value[i]); } int main() { int n, bagweight; cin >> n >> bagweight; vector weight(n), value(n); for (int i = 0; i > weight[i]; for (int i = 0; i > value[i]; vector> dp(n, vector(bagweight + 1, -1)); cout 解法三：序偶对法 支配规则:已知(Pj,Wj)∈Si-1，(Pk,Wk)∈Si1，并且在Wj≥Wk&&Pj≤Pk， 那么序偶(Pj,Wj)被放弃，称为(Pk,Wk)支配(Pj,Wj)。 步骤： S0={(0,0)} Si1= {(p,w)|(p-pi,w-wi) ∈Si-1} 在支配规则下将Si-1和Si1归并成Si。 在生成Si时, 将W>M的那些序偶(p,w)去掉, 它们不能导出满足约束 条件的可行解。即装不下的序偶对 Sn中最末序偶对的P值，是问题的最优解 空间复杂度是O(2^n) 时间复杂度为 O(min{2^n, n∑1≤j≤n(Pj) , nM})，所以最坏情况为指数级 最坏情况，即集合里序偶对不可支配性，每次合并时无法通过支配规则剔除一些序偶对 例如：每阶段序偶集合大小满足 ∣Si∣=2^i，需要确保每次处理物品时，新增的序偶均不被已有序偶支配，从而无法合并。 物品数量：n 件。 重量与效益：物品 i 的重量 wi=2i−1，效益 pi=2i−1。 背包容量：M=2^n−1（足够大以容纳所有可能的组合） 权值之和最大的兼容活动子集 每个活动或者说作业ai除了开始和结束时间外，还有一个值v作为权值或者收益值,。目 求权值之和最大的兼容活动子集。也就是选择一个活动集合 A ，使得 ∑Vk(ak∈A) 最大化。设计一个多项式时间的算法求解该问题 解答：每个活动新增了权值属性，而且原问题为求权值总和最大的活动子集，我们无法再用贪心策略求解，因为即便参加活动多活动权值总和未必大，所以本题只能用动态规划求解 方法一：动态规划（区间两个端点都不固定） 所有活动已经按照结束时间从小到大排序 定义 Aij 为 Sij 中权值总和最大且相互兼容的活动子集，定义 val[i,j] 为子问题 Sij 的最大权值总和，则求解 val[i,j] 的递归式如下 构造两个虚拟活动 a0 和 an+1 ，活动 a0 的结束时间 f0=0 ，活动 an+1 的开始时间 sn+1=+∞ 原问题转化为求子问题 S0,n+1 中权值总和最大且相互兼容的活动子集 A0,n+1 。 构造 Aij 权值总和 val[i,j] 表格 val[0:n+1,0:n+1] 和对应的 act[i,j] 选择表格 act[0:n+1,0:n+1] 。 MAX-VALUE-ACTIVITY-SELECTOR伪代码如下： MAX-VALUE-ACTIVITY-SELECTOR(s, f, v, n) let val[0 : n + 1, 0 : n + 1] and act[0 : n + 1, 0 : n + 1] be new tablbs //依旧是开区间，（i，i）和（i，i+1)都没有元素 for i = 0 to n val[i, i] = 0 val[i, i + 1] = 0 val[n + 1, n + 1] = 0 //区间长度 for l = 2 to n + 1 for i = 0 to n - l + 1 j = i + l val[i, j] = 0 k = j - 1 while f[i] val[i, j] val[i, j] = val[i, k] + val[k, j] + v[k] act[i, j] = k k = k - 1 print \"A maximum-value set of mutually compatible activities has value\" val[0, n + 1] print \"The set contains\" PRINT-ACTIVITIES(val, act, 0, n + 1) PRINT-ACTIVITIES(val, act, i, j) if val[i, j] > 0 k = act[i, j] print k PRINT-ACTIVITIES(val, act, i, k) PRINT-ACTIVITIES(val, act, k, j) MAX-VALUE-ACTIVITY-SELECTOR的运行时间为 O(n^3) 。 方法二：动态规划（区间一个端点固定，另一个端点不固定） 需要从单端开始拓展就行，构造数组 val[0,n] 构造一个虚拟活动 a0 ，活动 a0 的结束时间 ，f0=0，v0=0 val[i] 表示前 i 个活动能够取得的最大权值总和，即子问题 S0,i 中权值总和最大且相互兼容的活动子集 A0,i 的权值总和，对应的活动序列为 act[i] 。 求解 val[i] 的递归式如下： 当 i≠0 时， val[i] 在选择第 i 个活动 val[k]+vi （ k 为结束时间小于等于且最接近 si 的活动下标）和不选择第 i 个活动 val[i−1] 之间取最大值 MAX-VALUE-ACTIVITY-SELECTOR伪代码如下： MAX-VALUE-ACTIVITY-SELECTOR(s, f, v, n) let val[0 : n] and act[0 : n] be new arrays //第一个虚拟活动价值为0 val[0] = 0 for i = 1 to n k = i - 1 while k > 0 if f[k] ≤ s[i] break k = k - 1 //前k活动加上活动i收益大于不选则i的收益 if val[k] + v[i] > val[i - 1] val[i] = val[k] + v[i] act[i] = act[k] act[i] = act[i] ∪ {i} else val[i] = val[i - 1] act[i] = act[i - 1] print \"A maximum-value set of mutually compatible activities has value\" val[n] print \"The set contains\" print act[n] MAX-VALUE-ACTIVITY-SELECTOR的运行时间为 O(n^2) 。 方法三：动态规划（区间一个端点固定，另一个端点不固定）二分查找优化 可以看出方法二在查找第一个结束时间小于等于且最接近 si 的活动下标类似于求左边界，即f[k] 利用二分查找或者STL中的upper_bound MAX-VALUE-ACTIVITY-SELECTOR(s, f, v, n) let val[0 : n] and act[0 : n] be new arrays val[0] = 0 for i = 1 to n l = 1 r = n - 1 while l ≤ r mid = l+((r-l)>>1) if f[mid] ≤ s[i] l = mid + 1 else r = mid - 1 k = r if val[k] + v[i] > val[i - 1] val[i] = val[k] + v[i] act[i] = act[k] act[i] = act[i] ∪ {i} else val[i] = val[i - 1] act[i] = act[i - 1] print \"A maximum-value set of mutually compatible activities has value\" val[n] print \"The set contains\" print act[n] MAX-VALUE-ACTIVITY-SELECTOR的运行时间为 O(nlg⁡n) 。 可靠性设计问题 问题 设计一个系统由若干个以串联方式连接在一起的不同设备(Di)所组成。 设ri是设备Di正常运转的概率，即可靠性。 在最大成本c的约束下，求整个系统的最大化可靠性（各个可靠性的乘积） 已知系统中每种设备至少有一台，设cj是一台设备j的成本，j允 许配置的台数至多为：uj= [c+cj-∑ck)/cj] 解答 支配规则:对于(f1,x1)和(f2,x2)，当且仅当f1≥f2而x1≤x2时， (f1,x1)支配(f2,x2)。 (f2,x2)从序偶集合中舍去。 例子 deepseek def reliability_design(n, c, c_list, phi_list, u_list): # 初始化动态规划数组 dp = [0.0] * (c + 1) dp[0] = 1.0 # 前0级，成本0的可靠性为1 for i in range(n): # 处理第1级到第n级 current_c = c_list[i] current_phi = phi_list[i] max_u = u_list[i] temp = [0.0] * (c + 1) for s_prev in range(c + 1): if dp[s_prev] == 0: continue for m in range(1, max_u + 1): cost = m * current_c s_current = s_prev + cost if s_current > c: continue reliability = dp[s_prev] * current_phi(m) if reliability > temp[s_current]: temp[s_current] = reliability dp = temp.copy() max_reliability = max(dp) return max_reliability 流水线调度问题 问题 处理一个作业通常需要若干个不同的任务。 假设有n个作业，每个作业i要求执行m个任务：T1i,T2i,…Tmi,1≤i≤n。 任务Tji只能在设备Pj上执行，1≤j≤m。 对于任一作业i，在任务Tj-1,i没完成以前，不能对任务Tji开始处理。 同一台设备在任何时刻只能处理一个任务 [!note] 假设完成任务Tji所要求的时间是tji，1≤j≤m，1≤i≤n，那么如何将 这n×m个任务分配给这m台设备，才能使这n个作业在以上要求下顺利完成呢？ 只考虑非抢先式调度：当前任务一旦被设备处理就不能被中断，直到完成 这里只讨论m=2 时，获取OFT（非抢先调度下最优时间）调度这一特殊情况。 在m=2的OFT调度问题中，每个作业只有两个任务。为简便起见，令ai表示 t1i,bi表示t2i，假定ai≠0，1≤i≤n。 每个任务都应在最早的可能时间开始执行，排列在后面的作业可以先被执行 [!note] 最优子结构：在给出了这个排列的第一个作业后，剩下的排列相对于这两台设备在完成第一个作业时所处的状态而言是最优的 令t表示设备P1完成任务后，设备P2还需要花费的执行时间，即后继任务在 P1可用后，还需要等待t时间才可以使用P2。 设g(S,t)是上述t下作业集合S的最优调度长度 min不等式 对于对于作业i和j，当ai或bj最小时，min不等式成立，即先i后j处理作业长度更短 轮换法：若一个作业调度中，每一对相邻的作业都满足min不等式关系，则获得一个最 优长度，该调度也是一个最优调度 [!important] 最后得到最优调度规则 把全部ai和bj非降次序排序后，考察该序列： 如果下一个元素是aj且作业j还没调度，那么在还没使用的最左位置调度作业j； 如果下一个元素是bj且作业j还没调度，那么在还没使用的最右位置调度作业j； 如果已经调度了作业j，则考查下一个元素，直到n个作业都分配完为止。 该规则也适用于存在ai=0的作业集合。 通俗理解：就是如果一个作业的第一个任务即a小于b则尽量往左边靠，先执行使后面的作业可以提前。相反如果a大于b，则放在后面，后执行以便减少前面作业a和b任务的间隔时间 例题： def optimal_job_scheduling(jobs): \"\"\" 根据最优调度规则生成作业顺序 :param jobs: 列表，每个元素为元组 (a_i, b_i) 表示第i个作业的参数 :return: 最优调度顺序的作业索引列表 \"\"\" n = len(jobs) elements = [] # 生成包含所有a和b元素的列表，并标记类型和作业索引 for job_id in range(n): a, b = jobs[job_id] elements.append((a, 'a', job_id)) elements.append((b, 'b', job_id)) # 按照元素值升序排序 elements.sort(key=lambda x: x[0]) schedule = [None] * n # 初始化调度结果容器 left, right = 0, n - 1 # 左右指针 scheduled = set() # 记录已调度的作业 for elem in elements: value, elem_type, job_id = elem # 跳过已调度的作业 if job_id in scheduled: continue # 处理a类型元素（放在最左可用位置） if elem_type == 'a': schedule[left] = job_id left += 1 # 处理b类型元素（放在最右可用位置） else: schedule[right] = job_id right -= 1 scheduled.add(job_id) return schedule ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 15_动态规划 "},"docs/DataStructure_and_Algorithms/Algorithms/16_贪心算法.html":{"url":"docs/DataStructure_and_Algorithms/Algorithms/16_贪心算法.html","title":"16_贪心算法","keywords":"","body":" 贪心算法 活动选择问题 活动选择问题的最优子结构 方法一：动态规划（区间两个端点都不固定） 方法二：动态规划（区间一个端点固定，另一个端点不固定） 方法三：动态规划（区间一个端点固定，另一个端点不固定）二分查找优化 贪心选择（最早结束） 定理16.1(Theorem 16.1) 递归贪心算法(A recursive greedy algorithm) 迭代贪心算法(An iterative greedy algorithm) 另一贪心选择（最晚开始） 递归贪心算法 迭代贪心算法 不合理的贪心选择 区间着色问题 方法一：优先队列 方法二：有序化 权值之和最大的兼容活动子集 方法一：动态规划（区间两个端点都不固定） 方法二：动态规划（区间一个端点固定，另一个端点不固定） 方法三：动态规划（区间一个端点固定，另一个端点不固定）二分查找优化 小数背包 问题 解答 动态规划 贪心算法 类似的模型 最佳装载 顾客等待时间问题 带有期限的作业调度问题 问题 解答 基于插入排序的带有限期的作业排序 基于集合数（并查集）的作业排序算法 最小生成树问题 问题 解答 Kruskal方法 Prim算法（加点法） 补水点选择问题 问题 解答 覆盖点问题 问题 解答 哈夫曼编码 编码问题 前缀无关编码(Prefix-free codes) 构造哈夫曼编码(Constructing a Huffman code) 哈夫曼算法的正确性(Correctness of Huffman's algorithm) 引理15.2(Lemma 15.2) 引理15.3(Lemma 15.3) 定理15.4(Theorem 15.4) 最优归并树 离线缓存 问题 解答 离线缓存的最优子结构(Optimal substructure of offline caching) 离线缓存的贪心选择性质(Greedy-choice property of offline caching) 贪心算法原理 贪心选择性质(Greedy-choice property) 最优子结构(Optimal substructure) 贪心VS动态规划(Greedy versus dynamic programming) 贪心算法 [!note] 贪心算法(greedy algorithm)就是这样的算法，每一步都做出当时看起来最佳的选择。总是做出局部最优的选择 贪心方法是一种”只顾眼前”的分级处理方法： 根据题意选取一种量度标准； 按该标准一次选中一个输入； 如果这个输入和当前的部分解加在一起满足约束条件，则将其加入到部分解中；否则舍弃掉。 [!warning] 贪心算法并不保证得到最优解，但对很多问题确实可以求得最优解。 贪心法设计求解的核心问题：选择能产生问题最优解的量度标准，即最优量度标准 活动选择问题 活动选择问题(activity-selection problem)：是一个调度多个活动问题，这些活动需要互斥竞争共享资源。从一个活动日程表中选出规模最大的相互兼容的活动(activity)的集合。 有 n 个活动构成的集合 S={a1,a2,…,an} ，这些活动都需要占用会议室，且每个时刻会议室只能给一场活动提供服务。每个活动 ai 的开始时间(start time)为 si ，结束时间(finish time)为 fi，其中 0≤si。如果活动 ai 占用的时间为左闭右开区间 [si,fi) 。如果活动 ai 和 aj 的时间区间 [si,fi) 和 [sj,fj) 没有重叠，那么活动 ai 和 aj 相互兼容 活动选择问题目标是从所有活动中选出一个总时间规模最大相互兼容的活动子集 [!tip] 假设这些活动已经按照结束时间从小到大排序，即：f1≤f2≤f3≤⋯≤fn 活动选择问题的最优子结构 [!important] 定义 Sij 为 ai 结束后 aj 开始前的活动集合，定义 Aij 为 Sij 中规模最大且相互兼容的活动子集。 Aij中包含活动 ak ，和两个子问题 Aik 和 Akj 。定义 Aik=Aij∩Sik 且 Akj=Aij∩Skj，这样有 Aik=Aik∪{ak}∪Akj ，所以有 |Aij|=|Aik|+|Akj|+1 。 剪切粘贴方法可以证明最优解 Aij 一定包含两个子问题 Sik 和 Skj 的最优解 如果你能找到一个由 Skj 相互兼容的活动组成的集合 Akj′ ，其中|Akj′|>|Akj| ，那么你就可以用 Akj′ 替换 Akj 。此时就能构造出规模为|Aik|+|Akj′|+1>|Aik|+|Akj|+1=|Aij|的相互兼容的活动集合，与 Aij 是最优解矛盾。同理也可以用于证明子问题 Sik 最优解 [!note] 定义 Sij 的最优解的规模为 c[i,j] ，运用动态规划方法可以写出递归式： c[i,j]=c[i,k]+c[k,j]+1 。 如果不知道 Sij 的最优解包含活动 ak ，就需要考察 Sij 中的所有活动，寻找哪个活动可以构造最优解: 方法一：动态规划（区间两个端点都不固定） 这个方法实际意义是找到分割点 对于子问题 Sij ，当 j−i≥2 时，我们要找到活动 ak ，使得 i。 构造两个虚拟活动 a0 和 an+1 ，活动 a0 的结束时间 f0=0 ，活动 an+1 的开始时间 sn+1=+∞ 构造 Aij 规模 c[i,j] 表格 c[0:n+1,0:n+1] 和对应的 act[i,j] 选择表格 act[0:n+1,0:n+1] 。 c[i][j] 表示在虚拟活动 i 和 j 之间（即活动 i 结束后开始、活动 j 开始前结束的活动）能选择的最大兼容活动数 DP-ACTIVITY-SELECTOR(s, f, n) { let c[0 : n + 1, 0 : n + 1] and act[0 : n + 1, 0 : n + 1] be new tables //开区间，所以（i，i)和（i，i+1)之间没有活动 for i = 0 to n c[i, i] = 0 c[i, i + 1] = 0 c[n + 1, n + 1] = 0 //区间长度（i,i+l)中间有l-1个活动 for l = 2 to n + 1 //起始点 for i = 0 to n - l + 1 //结束点 j = i + l c[i, j] = 0 //从后往前遍历分割点 k = j - 1 while f[i] c[i, j] c[i, j] = c[i, k] + c[k, j] + 1 act[i, j] = k k = k - 1 print \"A maximum size set of mutually compatible activities has size\" c[0, n + 1] print \"The set contains\" PRINT-ACTIVITIES(c, act, 0, n + 1) } PRINT-ACTIVITIES(c, act, i, j) if c[i, j] > 0 k = act[i, j] print k PRINT-ACTIVITIES(c, act, i, k) PRINT-ACTIVITIES(c, act, k, j) DP-ACTIVITY-SELECTOR的运行时间为 O(n^3) 。 方法二：动态规划（区间一个端点固定，另一个端点不固定） 这个方法则是从左到右判断是否选择该活动 假定所有活动已经按照结束时间从小到大排序。 只需要从单端开始拓展就行，构造数组 c[0,n] ，构造一个虚拟活动 a0 ，活动 a0 的结束时间 ，f0=0，v0=0 ，c[i] 表示前 i 个活动能够取得的最大规模，即子问题 S0,i 中规模最大且相互兼容的活动子集 A0,i 的规模，对应的活动序列为 act[i] 。则求解 c[i] 的递归式如下： 当 i≠0 时， c[i] 在选择第 i 个活动 c[k]+1 （ k 为结束时间小于等于且最接近 si 的活动下标）和不选择第 i 个活动 c[i−1] 之间取最大值 DP-ACTIVITY-SELECTOR伪代码如下： -ACTIVITY-SELECTOR(s, f, v, n) let c[0 : n] and act[0 : n] be new arrays c[0] = 0 for i = 1 to n k = i - 1 //找到不冲突的活动 while k > 0 if f[k] ≤ s[i] break k = k - 1 if c[k] + 1 > c[i - 1] c[i] = c[k] + 1 act[i] = act[k] act[i] = act[i] ∪ {i} else c[i] = c[i - 1] act[i] = act[i - 1] print \"A maximum size set of mutually compatible activities has size\" c[n] print \"The set contains\" print act[n] DP-ACTIVITY-SELECTOR的运行时间为 O(n^2) 。 方法三：动态规划（区间一个端点固定，另一个端点不固定）二分查找优化 方法二中查找 k 的步骤因为f[n]是有序的，可以用二分查找进一步优化： DP-ACTIVITY-SELECTOR(s, f, v, n) let c[0 : n] and act[0 : n] be new arrays c[0] = 0 for i = 1 to n l = 1 r = i while l ≤ r mid = ⌊(l + r) / 2⌋ if f[mid] ≤ s[i] l = mid + 1 else r = mid - 1 k = r if c[k] + 1 > c[i - 1] c[i] = c[k] + 1 act[i] = act[k] act[i] = act[i] ∪ {i} else c[i] = c[i - 1] act[i] = act[i - 1] print \"A maximum size set of mutually compatible activities has size\" c[n] print \"The set contains\" print act[n] DP-ACTIVITY-SELECTOR的运行时间为 O(nlg⁡n) 。 [!tip] 全源最短路径Floyd算法、单源最短路径Dijkstra算法、单源最短路径Dijkstra算法优先队列优化的运行时间依次为 O(n^3) 、 O(n^2) 、 O(nlg⁡n) 。 两者非常相似。 贪心选择（最早结束） 对于活动选择问题，我们只需要考虑一个选择，那就是贪心选择。 贪心选择一个能够尽早结束活动，这样留下尽可能多的资源供接下来的活动使用。 由于所有活动已经按照结束时间从小到大排序，贪心选择 a1 ，接下来只有一个子问题要处理，选择一个在 a1 结束后开始的活动。为什么没必要考察在 a1 开始前的活动呢？因为 s1不会有活动结束时间早于 s1 ，可以贪心选择活动 a1 令 Sk={ai∈S:si≥fk} 为在 ak 结束后开始的任务集合。当贪心选择 a1 后， S1 是唯一需要求解的子问题。 定理16.1(Theorem 16.1) [!note] 考虑任意非空子问题Sk, 令am 是Sk 中结束时间最早的活动，则 am 在sk 的某个 最大兼容活动子集中。 证明：定义 Ak 是 Sk 的最大兼容活动子集，且 aj 是 Ak 中结束时间最早的活动。 若 aj=am ，则已证明 am∈Ak 。 若 aj≠am ，令 Ak′=(Ak−{aj})∪{am}，则 |Ak|=|Ak′| 。又 aj 是 Ak 中结束时间最早的活动，am 是 Ak′ 中结束时间最早的活动， fm≤fj 。所以 Ak′ 是 Sk 的最大兼容活动子集， am∈Ak′ 。 我们每次选择结束时间最早的且与当前活动兼容的活动，重复执行这个过程直到没有剩余活动可以选择。所选择的活动的结束时间必然是严格递增的。所以我们只需要按照结束时间单调递增的顺序处理所有活动，每个活动仅需要考察一次。 由于贪心算法只有一个子问题，所以用自顶向下的方法进行求解也非常方便。 递归贪心算法(A recursive greedy algorithm) 可以增加一个虚拟活动 a0 放在所有活动之前，其结束时间 f0=0 。这样子问题 S0 就是完整的活动集合 S 。RECURSIVE-ACTIVITY-SELECTOR的伪代码如下： RECURSIVE-ACTIVITY-SELECTOR(s, f, k, n) m = k + 1 while m ≤ n and s[m] 假定所有活动已经按照结束时间从小到大排序，则递归调用 RECURSIVE-ACTIVITY-SELECTOR(s,f,0,n) 的运行时间为 Θ(n) 。 迭代贪心算法(An iterative greedy algorithm) RECURSIVE-ACTIVITY-SELECTOR几乎就是尾递归(tail recursive)， 如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。（详见思考题7-5） 将尾部递归过程转换为迭代形式通常是一项简单的任务。事实上，某些编程语言的编译器会自动执行此任务。 RECURSIVE-ACTIVITY-SELECTOR可以转化为迭代版本GREEDY-ACTIVITY-SELECTOR，伪代码如下： GREEDY-ACTIVITY-SELECTOR(s, f, n) A = {a_1} k = 1 for m = 2 to n if s[m] ≥ f[k] // is a_m in S_k A = A ∪ {a_m} // yes, so choose it k = m // and continue from there return A 变量 k 记录了最近加入集合 A 的活动下标，对应递归算法中的活动 ak ，由于我们按照结束时间单调递增处理活动。 fk 是 A 中活动的的最大结束时间，也就是说， 假定所有活动已经按照结束时间从小到大排序，则递归调用 GREEDY-ACTIVITY-SELECTOR(s,f,n) 的运行时间为 Θ(n) 。 另一贪心选择（最晚开始） 不再一直选择最早结束的活动，而是选择最晚开始的活动，前提仍然是与之前 选出的所有活动均兼容 这个策略和选择最早结束的方案是完全对称的，假设时间倒流，所有活动倒过来执行。 有 n 个活动构成的集合 S={a1,a2,…,an} ，假设这些活动已经按照开始时间从大到小排序，即：s1≥s2≥s3≥⋯≥sn。 [!tip] 令 Sk={ai∈S:fk≤si} 为在 ak 开始前结束的任务集合。当贪心选择 a1 后， S1 是唯一需要求解的子问题。 考虑任意非空子问题 Sk ，如果 am 是 Sk 中开始时间最晚的活动，那么 am 在 Sk 的某个最大兼容活动子集中。 证明：定义 Ak 是 Sk 的最大兼容活动子集，且 aj 是 Ak 中开始时间最晚的活动。 若 aj=am ，则已证明 am∈Ak 。 若 aj≠am ，令 Ak′=(Ak−{aj})∪{am}，则 |Ak|=|Ak′| 。又 aj 是 Ak 中开始时间最晚的活动，am 是 Ak′ 中开始时间最晚的活动， sm≥sj 。所以 Ak′ 是 Sk 的最大兼容活动子集， am∈Ak′ 。 我们每次选择开始时间最晚的且与当前活动兼容的活动，重复执行这个过程直到没有剩余活动可以选择。所选择的活动的开始时间必然是严格递减的。所以我们只需要按照开始时间单调递减的顺序处理所有活动，每个活动仅需要考察一次 递归贪心算法 可以增加一个虚拟活动 a0 放在所有活动之后，其开始时间 s0=f1 。这样子问题 S0 就是完整的活动集合 S 。RECURSIVE-ACTIVITY-SELECTOR的伪代码如下： RECURSIVE-ACTIVITY-SELECTOR(s, f, k, n) m = k + 1 //越往后开始时间越早，f[m]>s[k]则保证兼容 while m ≤ n and f[m] > s[k] // find the first activity in S_k to start m = m + 1 if m ≤ n return {a_m} ∪ RECURSIVE-ACTIVITY-SELECTOR(s, f, m, n) else return ∅ RECURSIVE-ACTIVITY-SELECTOR(s, f, 0, n) // call function 假定所有活动已经按照开始时间排好序，则递归调用 RECURSIVE-ACTIVITY-SELECTOR(s,f,0,n) 的运行时间为 Θ(n) 。 迭代贪心算法 迭代版本GREEDY-ACTIVITY-SELECTOR，伪代码如下： GREEDY-ACTIVITY-SELECTOR(s, f, n) A = {a_1} k = 1 for m = 2 to n if f[m] ≤ s[k] // is a_m in S_k A = A ∪ {a_m} // yes, so choose it k = m // and continue from there return A 假定所有活动已经按照开始时间排好序，则调用 GREEDY-ACTIVITY-SELECTOR(s,f,n) 的运行时间为 Θ(n) 。 不合理的贪心选择 在剩余活动中选择持续时间最短的活动不能得到最大兼容的活动子集。 在剩余活动中选择与其它活动重叠最少的活动不能得到最大兼容的活动子集。 在剩余活动中选择最早开始的活动不能得到最大兼容的活动子集。 区间着色问题 假设有一组活动，将它们安排到一些讲堂，任意活动都可以在任意讲堂进行，我们希望用最少的教室完成所有活动，设计一个贪心算法求每个活动所在讲堂进行分配。 [!note] 这个问题可以视为区间图着色问题(interval-graph coloring problem)。区间图着色问题：构造一个区间图，顶点表示给定的活动，边连接不兼容的活动。要求用最少的颜色对顶点进行着色，相邻顶点的颜色不能相同。 设活动数组为 A ，总共有 n 个活动。每个活动保存为一个结构体，包含活动id，开始时间，结束时间，讲堂id。 方法一：优先队列 朴素思想：每当有新活动时，就遍历所有讲堂，查看是否有空闲讲堂。如果没有空闲讲堂，就新开一个讲堂。为了方便选出空闲讲堂，我们可以使用优先队列。 按照开始时间对活动进行排序。 初始化一个小顶堆，按照结束时间排序，堆顶活动为最早结束的活动。 遍历检查每一个活动 如果堆为空，增加一个新讲堂，选好讲堂后将活动加入堆中，同时将该活动记录到所在讲堂举行的活动名单中。 如果堆不为空，和堆顶活动进行比较，如果堆顶活动的结束时间小于或等于当前活动的开始时间即检查当前有无空闲讲堂，将堆顶活动出队，并将当前活动放在堆顶活动所在讲堂进行，否则开辟一个新讲堂。选好讲堂后将活动加入堆中，同时将该活动记录到所在讲堂举行的活动名单中 所有活动检查结束后，输出所有讲堂举行的活动名单。 LECTURE-HALLS-SCHEDULE(A, n) sort A by start time in ascending order //A[i]={start_time,finsh_time,hall-id，activity_id} let PQ be a new min-priority queue keyed by end time let H be a new table hall-count = 0 //遍历活动 for i = 1 to n if PQ.empty() == true hall-count = hall-count + 1 A[i].hall-id = hall-count PQ.push(A[i]) H[hall-count] = H[hall-count] ∪ {A[i]} else //有空闲讲堂 if A[i].start-time ≥ PQ.top().end-time A[i].hall-id = PQ.top().hall-id H[A[i].hall-id] = H[A[i].hall-id] ∪ {A[i]} PQ.pop() else hall-count = hall-count + 1 A[i].hall-id = hall-count let h be a new array H.push_back(h) H[A[i].hall-id] = H[A[i].hall-id] ∪ {A[i]} PQ.push(A[i]) for j = 1 to hall-count print \"the activities lecture hall\" j \"will hold are: \" for k = 1 to H[j].size() print H[j][k].activity-id \", \" LECTURE-HALLS-SCHEDULE运行时间为 Θ(nlg⁡n) ，排序运行时间为 Θ(nlg⁡n) ，每个活动要检查一次，优先队列调整运行时间为 O(lg⁡n) ，总共有 n 个活动，总计 O(nlg⁡n) 。所以总的运行时间为 Θ(nlg⁡n) 。 LECTURE-HALLS-SCHEDULE需要的辅助空间大小为 Θ(n) ，最坏情况下所有活动都需要一个独立的讲堂，优先队列最大为 O(n) ，表格 H 记录所有活动，大小为 Θ(n) 。所以总的辅助空间大小为 Θ(n) 。 方法二：有序化 将活动数组分别按照开始时间和结束时间从小到大排序。按照开始时间从小到大排序的数组称为活动开始数组，按照结束时间从小到大排序的数组称为活动结束数组， 维护两个指针，活动开始数组指针 sp ，跟踪活动开始，活动结束数组 fp ，跟踪活动结束。 当考虑 sp 指向的特定活动时，检查该开始时间是否大于或等于 fp 指向的活动。若如此，则说明 fp 开始时，已经有活动结束。于是我们可以重用讲堂。否则，我们就需要开新讲堂，同时记录新开讲堂。处理结束后自增 sp ，处理下一个活动。 若有活动结束，则记录空闲讲堂（可以用栈或者队列维护所有空闲讲堂），自增 fp 重复这一过程，直到 sp 处理完所有活动。 LECTURE-HALLS-SCHEDULE(A, n) sort A by start time in ascending order A' = A sort A' by start time in ascending order let H be a new table hall-count = 0 sp = 1 fp = 1 let Q be a new queue while sp ≤ n //有空闲讲堂或者说有活动结束 if A[sp].start-time ≥ A'[fp].finish-time hall-id = Q.pop() A[sp].hall-id = hall-id H[hall-id] = H[hall-id] ∪ {A[sp]} Q.push(A'[fp].hall-id) //放入当前活动 fp = fp + 1 else hall-count = hall-count + 1 A[sp].hall-id = hall-count let h be a new array H.push_back(h) H[A[sp].hall-id] = H[A[sp].hall-id] ∪ {A[sp]} sp = sp + 1 for j = 1 to hall-count print \"the activities lecture hall\" j \"will hold are: \" for k = 1 to H[j].size() print H[j][k].activity-id \", \" LECTURE-HALLS-SCHEDULE运行时间为 Θ(nlg⁡n) ，排序运行时间为 Θ(nlg⁡n) ，每个活动要检查一次，运行时间为 Θ(1) ，总共有 n 个活动，总计 Θ(n) 。所以总的运行时间为 Θ(nlg⁡n) 。 LECTURE-HALLS-SCHEDULE需要的辅助空间大小为 Θ(n) ，复制数组 A′ 记录所有活动大小为 Θ(n) ，辅助队列 Q 大小为 O(n) ，表格 H 记录所有活动，大小为 Θ(n) 。所以总的辅助空间大小为 Θ(n) 。 权值之和最大的兼容活动子集 每个活动或者说作业ai除了开始和结束时间外，还有一个值v作为权值或者收益值,。目 求权值之和最大的兼容活动子集。也就是选择一个活动集合 A ，使得 ∑Vk(ak∈A) 最大化。设计一个多项式时间的算法求解该问题 解答：每个活动新增了权值属性，而且原问题为求权值总和最大的活动子集，我们无法再用贪心策略求解，因为即便参加活动多活动权值总和未必大，所以本题只能用动态规划求解 方法一：动态规划（区间两个端点都不固定） 所有活动已经按照结束时间从小到大排序 定义 Aij 为 Sij 中权值总和最大且相互兼容的活动子集，定义 val[i,j] 为子问题 Sij 的最大权值总和，则求解 val[i,j] 的递归式如下 构造两个虚拟活动 a0 和 an+1 ，活动 a0 的结束时间 f0=0 ，活动 an+1 的开始时间 sn+1=+∞ 原问题转化为求子问题 S0,n+1 中权值总和最大且相互兼容的活动子集 A0,n+1 。 构造 Aij 权值总和 val[i,j] 表格 val[0:n+1,0:n+1] 和对应的 act[i,j] 选择表格 act[0:n+1,0:n+1] 。 MAX-VALUE-ACTIVITY-SELECTOR伪代码如下： MAX-VALUE-ACTIVITY-SELECTOR(s, f, v, n) let val[0 : n + 1, 0 : n + 1] and act[0 : n + 1, 0 : n + 1] be new tablbs //依旧是开区间，（i，i）和（i，i+1)都没有元素 for i = 0 to n val[i, i] = 0 val[i, i + 1] = 0 val[n + 1, n + 1] = 0 //区间长度 for l = 2 to n + 1 for i = 0 to n - l + 1 j = i + l val[i, j] = 0 k = j - 1 while f[i] val[i, j] val[i, j] = val[i, k] + val[k, j] + v[k] act[i, j] = k k = k - 1 print \"A maximum-value set of mutually compatible activities has value\" val[0, n + 1] print \"The set contains\" PRINT-ACTIVITIES(val, act, 0, n + 1) PRINT-ACTIVITIES(val, act, i, j) if val[i, j] > 0 k = act[i, j] print k PRINT-ACTIVITIES(val, act, i, k) PRINT-ACTIVITIES(val, act, k, j) MAX-VALUE-ACTIVITY-SELECTOR的运行时间为 O(n^3) 。 方法二：动态规划（区间一个端点固定，另一个端点不固定） 需要从单端开始拓展就行，构造数组 val[0,n] 构造一个虚拟活动 a0 ，活动 a0 的结束时间 ，f0=0，v0=0 val[i] 表示前 i 个活动能够取得的最大权值总和，即子问题 S0,i 中权值总和最大且相互兼容的活动子集 A0,i 的权值总和，对应的活动序列为 act[i] 。 求解 val[i] 的递归式如下： 当 i≠0 时， val[i] 在选择第 i 个活动 val[k]+vi （ k 为结束时间小于等于且最接近 si 的活动下标）和不选择第 i 个活动 val[i−1] 之间取最大值 MAX-VALUE-ACTIVITY-SELECTOR伪代码如下： MAX-VALUE-ACTIVITY-SELECTOR(s, f, v, n) let val[0 : n] and act[0 : n] be new arrays //第一个虚拟活动价值为0 val[0] = 0 for i = 1 to n k = i - 1 while k > 0 if f[k] ≤ s[i] break k = k - 1 //前k活动加上活动i收益大于不选则i的收益 if val[k] + v[i] > val[i - 1] val[i] = val[k] + v[i] act[i] = act[k] act[i] = act[i] ∪ {i} else val[i] = val[i - 1] act[i] = act[i - 1] print \"A maximum-value set of mutually compatible activities has value\" val[n] print \"The set contains\" print act[n] MAX-VALUE-ACTIVITY-SELECTOR的运行时间为 O(n^2) 。 方法三：动态规划（区间一个端点固定，另一个端点不固定）二分查找优化 可以看出方法二在查找第一个结束时间小于等于且最接近 si 的活动下标类似于求左边界，即f[k] 利用二分查找或者STL中的upper_bound MAX-VALUE-ACTIVITY-SELECTOR(s, f, v, n) let val[0 : n] and act[0 : n] be new arrays val[0] = 0 for i = 1 to n l = 1 r = n - 1 while l ≤ r mid = l+((r-l)>>1) if f[mid] ≤ s[i] l = mid + 1 else r = mid - 1 k = r if val[k] + v[i] > val[i - 1] val[i] = val[k] + v[i] act[i] = act[k] act[i] = act[i] ∪ {i} else val[i] = val[i - 1] act[i] = act[i - 1] print \"A maximum-value set of mutually compatible activities has value\" val[n] print \"The set contains\" print act[n] MAX-VALUE-ACTIVITY-SELECTOR的运行时间为 O(nlg⁡n) 。 小数背包 问题 已知有n种物品和一个可容纳M重量的背包，每种物品i的重量为wi，效益值为pi ,假定将物品i的某一部分xi放入背包就会得到pi*xi(0≤xi≤1,pi>0)的效益，采用怎样的装包方法会使装入背包物品的总效益为最大 不同于0/1背包，物品无法分割只能选择放一个或者不放，而小数背包可以切割物品的一部分或者说按比例放入，同时获取比例收益 解答 动态规划 最优子结构： [!tip] 假设总容量为 W，当前选择装入某物品的 x 单位（x≤ 该物品总重量），则剩余容量 W−x 构成一个子问题。 剩余容量必须继续按照最优策略分配，即选择剩余物品中单位价值最高的装入。这一子问题的最优解与原问题的部分解结合，形成全局最优解。 若剩余容量未按最优方式分配，则整体解必然不是最优，因此子问题的最优性保证了全局最优。 贪心算法 但是对于这个问题可以利用人的思维惯性，先放入价值最高的物品，再放入价值次优的物品，直至背包被装满 [!note] 这就是贪心算法，然后选择量度标准即价值高低的定义，因为有重量的约束并且物品可分则使用单位重量的效益作为标准 将物品按单位重量效益的非增次序排序（递减） 按该次序逐一放物品，直到背包装满 //先将物品按pi/wi比值的非增次序排序(降序) int GREEDY-KNAPSACK(vector weight,vectorvalue,int bagweight) { int max_value=0; int now_weight=bagweight; vector object(weight.size());//记录物品放入比例 for(int i=0;inow_weight) { //按比例放入 object[i]=now_weight/weight[i]; max_value+=value[i]*object[i]; break; } max_value+=value[i]; now_weight-=weight[i]; object[i]=1; } return max_value; } 类似的模型 最佳装载 有编号为1,2,…,n的集装箱准备装上轮船，其中集装箱i的重量是wi , i=1,2,…,n. 已知轮船最大承重量是C，轮船对集装箱没有体积限制。如何选择装载，可使船上集装箱数量最多。 [!note] 为了使轮船上装载的集装箱数量最多，最优量度标准是：优先选择重量最小的集装箱进行装载，直到无法再装载新的集装箱为止。 船可容纳的最大重量为C 设贪心解选择的集装箱数量为 m，即 SG={wi1,wi2,...,wim}，其中 wi1≤wi2≤...≤wim} 设最优解选择的集装箱数量为 k，即 SO={wj1,wj2,...,wjk} 证明贪心解是最优解： 假设贪心解不是最优解，即 m m>k，与最优解矛盾 m 若贪心解比最优解少装了某些集装箱，即 m 又因为未被贪心选中的集装箱重量如果在最优解里那么也可以在贪心解里，所以未被贪心选中的集装箱不在最优解里，所以m>=k与m m=k，如果SO=SG，则贪心解就是最优解 如果SO!=SG，则找到第一个不相等的集装箱wia!=wjb，贪心策略按重量从小到大选择，所以wia 所以将wjb替换成wia，依旧为最优解，重复执行替换，可以将最优解变为贪心解，证明得m=k 总上m=k，即贪心解就是最优解 排序的时间复杂度为O(nlgn)，遍历weight时间复杂度为O(n)，所以总的时间复杂度为O(nlgn). int max_number(vector weight,int boat) { //使weight按非递增次序排序 sort(weight.begin(),weight.end()); int number=0; int now_weight=boat; for(int i=0;i 顾客等待时间问题 设有 n 个顾客同时等待一项服务，顾客需要的服务时间为 ti, i=1,2,...,n. 从时刻0开始计时.若在时刻 t 开始对顾客 i 服务,那么 i 的等待时间就是 t. 应该怎样安排 n 个顾客的服务次序，使得总的等待时间（每个顾客等待时间的总和）最少？ [!note] 最优量度标准：在每个步骤，总是选择 需要服务时间最短的顾客 进行服务，即 按照服务时间 ti 递增排序 进行服务。 假设给定一个任意调度方案 S，其中某两个相邻的顾客 i 和 j 满足： ti>tj，但在调度方案 S 中，顾客 i 被安排在 j 之前。 我们交换 i 和 j 的位置，新的方案 S′ 相比 S 具有： 顾客 j 的等待时间减少了 ti−tj。 顾客 i 的等待时间增加了 ti−tj。 由于 ti>tj，交换后，整体的等待时间减少了。因此，始终按从小到大排序能获得更优的调度方案。 经过有限次交换，我们可以得到一个 按照服务时间递增排序 的最优调度方案。因此，贪心策略是最优的。 排序的时间复杂度为O(nlgn)，遍历Customer时间复杂度为O(n)，所以总的时间复杂度为O(nlgn). int min_wait(vector customer) { //排序，顾客需要时间从小到大 sort(customer.begin(),customer.end()); int time=0; int wait_time=0; //最后一个顾客的服务时间不计入等待 for(int i=0;i 带有期限的作业调度问题 问题 假定只能在一台机器上处理n个作业： 每个作业均可在单位时间内完成; 又假定每个作业i都有一个截止期限di>0(di是整数), 当且仅当作业i在它的期限截止之前被完成时，方可获得pi>0的效益 求具有最大效益值的可行解（最优解） 解答 贪心算法，以目标函数∑pj作为量度标准, 将各作业按效益pi降序排列:p1≥ p2≥ …≥ pn procedure GREEDY_JOB(D, J, n) //作业按p1≥ p2≥ …≥ pn的次序输入；期限值D(1:n)≥1；J是最优解// J←{1} for i ← 2 to n do if (J ∪ {i}的所有作业都能在它们的截止期限前完成) then J ← (J ∪ {i})//最优解加上i endif repeat end GREEDY_JOB 证明：J是贪心方法求出的作业集合，I是一个最优解的作业集合 找一个属于J不属于I的元素，替换I中对应的元素，获得I’ 证明I’仍然最优 重复步骤，间接证明J最优 [!important] 定理5.3：设J是k个作业的集合, б=i1,i2,…,ik是J中作业的一种排列, 它使得di1≤di2≤…≤dik。J是一个可行解, 当且仅当J中的作业可以按照б的次序而又不违反任何一个期限的情况来处理 证明思路： 如果J中的作业可以按照б的次序而又不违反任何一个期限，则J是一个可行解 l若J是可行解，则必存在б’=r1,r2,…,rk，使得drj≥j，1≤j≤k。 假设б’≠б，令a是使得ra≠ia的最小下标；设rb=ia，显然b>a。 在б’中交换ra与rb的位置，产生新的可行排列б”，仍然是可行的。 连续使用这种方法，就将б’转换成б且不违反任何一个期限 注意如果各个作业的时间片不一样定理依旧成立，可以通过相邻交换证明 根据以上定理，可以验证可行解 假设已处理了i–1个作业, 有k个作业已存入J中, 且D[J(1)]≤D[J(2)]≤…≤D[J(k)] 在J中从后向前为作业i寻找位置r+1，插入r+1位置后，J中作业仍按照期限值从小到大排列，且不违反期限值 基于插入排序的带有限期的作业排序 作业数 n 和包含在解J中的作业数 s ，JS算法所需要的总时间为O(sn)，由于s 其中作业按收益非递增次序排序，并且从一号作业开始 void JS(std::vector& D, std::vector& J, int n, int& k) { D[0] = 0; J[0] = 0; k = 1; J[1] = 1; //处理第i个作业 for (int i = 2; i D[i] && D[J[r]] != r) { --r; } //表示找到了插入位置r if (D[J[r]] r) { //实现作业r+1到作业k依次往后移动一个位置 for (int l = k; l >= r + 1; --l) { J[l + 1] = J[l]; } //插入 J[r + 1] = i; ++k; } } } 基于集合数（并查集）的作业排序算法 对作业i分配时间时, 尽可能推迟对作业i的处理。 (在其截止期前最靠后的空时间片) 作出一些以期限值为元素的集合，且使同一集合中所有元素有相同的最大空时间片 对于每个期限值i，用F(i)表示当前最大空时间片，即 F(i)=ni 时间复杂度：O(n) [!tip] 使用集合树表示法，把每个集合表示成树。P(i)把期限值i链接到它的父节点 判断作业h的可用空时间片，即找min{n,dh}的根j，若F(j)!=0,说明有时间片可以分配，则F(j)是最接近期限值的时间片，把F(j)时间片分配给作业h并做标记。 以 j 为根的集合树必须与包含期限F(j)-1的集合树合并。 // 并查集路径压缩查找,根节点为-1 int find(std::vector& parent, int x) { return parent[x]>0?x:parent[x]=find(parent,parent[x]); } //注意parent的绝对值才是个数，这里是小树合并到大树 void UNION(std::vector& parent,int i,int j) { int x=parent[i]+parent[j]; if(parent[i]>parent[j]){ parent[i]=j; parent[j]=x; }else { parent[j]=i; parent[i]=x; } } void FJS(std::vector& D, int n, int b, std::vector& J, int& k) { int b = min(n,*max_element(D.begin(),D.end())); // 初始化F数组，F[0..b]代表时间槽的父指针 std::vector F(b + 1); for (int i = 0; i 最小生成树问题 问题 最小生成树的定义： 设G=(V,E)是一个加权无向连通图。V表示顶点集合，E表示边集合。G的一棵生成树是一棵无向树T=(V, E’)，其中E’是E的子集。生成树的权是E’的所有权之和。G的最小生成树是G的具有最小权值的生成树。 解答 Kruskal方法 考虑预排序，从边的个数入手分析，时间复杂度为O(eloge) 这里贪心算法的度量标准就是边的权值，先选择权值小的 [!tip] 证明：用e替换掉ej，获得新的可行解T ’’,证明新解也是最小生成树。反复替换，从而命题得证 从小到大选择边，如果将其加入最小生成树的集合T生成回路则放弃边否则加入T 这里判断回路则使用了并查集处理 //克鲁斯卡尔 (Kruskal)算法，可称为“加边法”，适用于稀疏图 //每次选出权值最小并且无法使现有的树形成环的边加入最小支撑树,返回一个图 std::vector MiniSpanTree_Kruskal(std::vector graph,int number) { //非连通图 if (Connected_Component(graph,number) != 1) { return{}; } std::vector MiniSpanTree; //在Edge增加了weight成员存储权值，可以直接用sort排序 std::sort(graph.begin(), graph.end(), [](const Edge& a, const Edge& b)->bool {return a.weight Vexset; Vexset.resize(number,0); //初始化,表示各顶点自成一个连通分址 for (int i = 0; i Prim算法（加点法） 选择任一点u做为起点，放入集合S，即令S={u}(u属于V)； 找最小跨集合边(u, v) ，即端点分别属于集合S和V-S且权值 最小的边，将该边加入最小支撑树，并将点v放入S； 执行②，直至S=V 如果只是需要权值和则不需要构造出最小生成树 // 普里姆算法优化，使用优先队列 Adj_Matrix MiniSpanTree_Prim(const Adj_Matrix& adj, int u = 0 /*起始点*/) { // 非连通图，返回空图 if (Connected_Component(adj) != 1) { return Adj_Matrix(0); } int n = adj.graph.size(); // 图的顶点数 Adj_Matrix MiniSpanTree(n, adj.is_direct); // 最小生成树 // 记录顶点是否已经加入生成树 std::vector vis(n, false); // 使用优先队列（最小堆）保存未加入生成树的点和其对应的最小边权值 // 队列中存储的是 (边权值, 顶点) 的 pair std::priority_queue, std::vector>, std::greater<>> pq; // 初始化：从起始点u开始，加入队列，权值为0 pq.push({0, u}); // 选择其他n-1个顶点，生成n-1条边 while (!pq.empty()) { // 取出当前权值最小的边 int current_weight = pq.top().first; int u0 = pq.top().second; pq.pop(); // 如果顶点u0已经加入生成树，则跳过 if (vis[u0]) continue; // 标记u0为已访问 vis[u0] = true; // 更新最小生成树的边 if (u0 != u) { // 排除起始点 int v0 = pq.top().second; // 顶点u0的前驱 MiniSpanTree.graph[u0][v0] = current_weight; // 无向图则增加对称边 if (!MiniSpanTree.is_direct) { MiniSpanTree.graph[v0][u0] = current_weight; } } // 更新与u0的相邻节点的最小边，并加入优先队列 for (int i = 0; i 补水点选择问题 问题 Gekko教授想横穿North Darkota州，教授在起点带着两公升水，在喝光水之前能滑行 m 英里，他还携带了一份路线图，上面标明了沿途补水点距离起点的距离。 教授的目标是最小化横穿途中的补水次数，请设计一个高效的算法，以帮助教授确定在哪些补水点进行补水。证明该算法能生成最优解，并给出该算法的运行时间。 解答 假设一定能够到达终点，并且起点也是一个补水点，假想教授在起点处进行了一次补水，若每次补水点位置为 x ，教授能够滑行的区间为 [x,x+m] 采用贪心策略，教授是需要在在喝光水之前的一个补水点进行补水就行。 设途中有 n 个补水点，起点坐标为 0 ，终点坐标为 d ，第 i 个补水点坐标为 xi ，有 0，集合 S 保存补水点编号。 GREEDY-INTERVAL-SELECTOR伪代码如下： GREEDY-INTERVAL-SELECTOR(m, d, x, n) let S be a new set i = 1 s = 0 //当前前进距离 //直到终点 while (s + m 优化为二分查找 //有n个补水点包括起点 GREEDY-INTERVAL-SELECTOR(m, d, x, n) let S be a new set i = 0//目前补水点 s = 0 //当前前进距离 //直到终点 while (s + m >1 if(x[mid] c++ //n个补水点包括终点 vector GreedyIntervalSelector(int m, int d, vector& x) { vector S; int n = x.size(); if (n == 0 || x[0] > m) return {}; // 初始位置不可达第一个点 int s = 0; // 当前已到达的最远位置 int current = 0; // 当前选中的点索引 while (s + m 覆盖点问题 问题 给定实数轴上的一个点集 {x1,x2,…,xn} ，请设计一个高效的算法，求一个能够包含所有点的单位长度的闭区间的集合，使得该集合最小，并证明该算法的正确性。 解答 设 x1,x2,…,xn 已经按照坐标从小到大排序，我们先考虑 x1 ，不存在值比 x1 更小了，我们选择闭区间 [x1,x1+1] ，设第一个大于 x1+1 的点为 xi ，剩下子问题的点集为 {xi,xi+1,…,xn}。重复执行上述步骤直到剩下子问题的点集为 ∅ 。集合 S 为单位长度的闭区间的集合。 方法一：线性查找 + 线性查找 GREEDY-INTERVAL-SELECTOR伪代码如下： GREEDY-INTERVAL-SELECTOR(x, n) //无点集 if n = 0 return ∅ let S be a new set //集合x[1:n] i = 1 while (i ≤ n) S = S ∪ {[x[i], x[i] + 1]} prev = i //找到第一个未能覆盖到的点 while (i ≤ n && x[i] ≤ x[prev] + 1) i = i + 1 return S GREEDY-INTERVAL-SELECTOR的运行时间为 Θ(n) 。 方法二：线性查找 + 二分查找 while循环中线性查找下一个区间的左端点可以用二分查找加速，修改后GREEDY-INTERVAL-SELECTOR伪代码如下： GREEDY-INTERVAL-SELECTOR伪代码如下： GREEDY-INTERVAL-SELECTOR(x, n) if n = 0 return ∅ let S be a new set i = 1 while (i ≤ n) S = S ∪ {[x[i], x[i] + 1]} prev = i l = i r = n while (l ≤ n) mid = ⌊(l + r) / 2⌋ if (x[mid] ≤ x[prev] + 1) l = mid + 1 else r = mid - 1 i = l//更新单位长度的起点 return S GREEDY-INTERVAL-SELECTOR的运行时间为 O(n) 。 哈夫曼编码 编码问题 [!important] 设计二进制字符编码(binary character code)问题：每个字符用唯一的二进制编码表示，称为码字(codeword)。 定长编码(fixed-length code)：所有字符的码字长度相同，需要使用 ⌈lg⁡n⌉ 个比特位表示 n≥2 个字符。 变长编码(variable-length code)：高频字符使用短码字，低频字符使用长码字。 前缀无关编码(Prefix-free codes) 前缀无关编码(prefix-free codes)：任何一个码字都不是其它码字的前缀的编码。在所有编码中，前缀无关编码的数据压缩效果是最优的。 [!tip] 评：第三版中称为前缀编码(prefix codes)，在第四版和《计算理论导论》第三版中都已经改成前缀无关编码(prefix-free codes)，个人认为称为前缀无关编码更加准确，充分表达出定义中“不是”的含义。当然free比较难翻译，可以翻译成自由，空闲，无关等，为了方便，本人统一翻译成无关。 编码(encoding)：任何二进制字符编码的编码很简单，直接将字符的码字按照顺序拼接。 解码(decoding)：由于任何一个码字都不是其它码字的前缀的编码，所以每个字符的编码都是无歧义的。所以可以按照顺序识别码字，并将其转换为原来字符。 [!note] 前缀无关编码可以用一棵二叉树表示，叶结点存储字符，左指针表示 0 ，右指针表示 1 (0意味着“转向左孩子\"'，1意味着“转向右孩子＂)，从根结点到某叶结点的路径表示该叶结点存储的字符的码字。 同时文件的最优编码可以用一棵满二叉树(full binary tree)表示，即每个非叶结点都有两个孩子结点。 这里的满二叉树不是数据结构上的满二叉树而是一种更广义上的满二叉树或者说严格的二叉树，即所有非叶节点的度都为2，而不是树的每层数量都达到最大 如有字符集 C ，最优前缀无关编码对应的二叉树中有 |C| 个叶结点和 |C|−1 个非叶结点。 设给定某文件的前缀无关编码，对应的二叉树为 T ，字符集 C 中每个字符 c 在该文件中出现的频率为 c.freq ，对应的叶结点在二叉树中的深度为 dT(c)>0 ， dT(c) 也是字符 c 的码字的长度。该文件的编码需要的比特位数为： 定义 B(T) 为树 T 的代价(cost)。 定长编码和变长编码的编码方案 构造哈夫曼编码(Constructing a Huffman code) 哈夫曼编码 首先目标是使编码方案对应的二叉树的代价最小，因此可以推出贪心策略对应的最优度量标准，即频率越高的字符深度越小 假定字符集 C 中包含 n 个字符，每个字符 c∈C 的频率为 c.freq ，我们采用自底向上的方法构造哈夫曼树，该算法使用了小根堆（最小优先队列） Q ，小根堆的关键字为属性 freq 。 识别两个最低频率的对象将其合并。当合并两个对象时， 得到的新对象的频率设置为原来两个对象的频率之和。 合并时顺序是任意的，交换左右孩子会生成一个不同的编码，但代价完全一样 HUFFMAN的伪代码如下： HUFFMAN(C) n = |C| //构建小根堆 let PQ be a new min-priority queue keyed by freq PQ = C for i = 1 to n - 1 allocate a new node z //选出频率最小的两颗树 x = EXTRACT-MIN(PQ) y = EXTRACT-MIN(PQ) z.left = x z.right = y z.freq = x.freq + y.freq INSERT(PQ, z) return EXTRACT-MIN(PQ) // the root of the tree is the only node left 简化 HUFFMAN(C) n = |C| //构建小根堆 let PQ be a new min-priority queue keyed by freq PQ = C for i = 1 to n - 1 allocate a new node z //选出频率最小的两颗树 z.left = EXTRACT-MIN(PQ) z.right = EXTRACT-MIN(PQ) z.freq = x.freq + y.freq INSERT(PQ, z) return EXTRACT-MIN(PQ) // the root of the tree is the only node left 需要合并 n−1 次，每次优先队列调整的运行时间为 O(lg⁡n) ，所以HUFFMAN的运行时间为 O(nlg⁡n) 。 图解过程 哈夫曼算法的正确性(Correctness of Huffman's algorithm) 为了证明贪心算法HUFFMAN是正确的，需要证明最优前缀无关编码问题具有贪心选择和最优子结构性质。 引理15.2(Lemma 15.2) 这条引理将证明构造最优前缀无关编码问题具有贪心选择性质。 [!note] 给定一个字母表 C ，每个字符 c∈C 的频率为 c.freq ，若 x 和 y 是 C 中频率最低的两个字符，则存在一个 C 的最优前缀无关编码，其中 x 和 y 的码字长度相同且只有最后一个比特位不同。 证明： 令 T 表示任一最优前缀无关编码对应的一棵二叉树，修改得到另一个最优前缀无关编码对应的二叉树，其中 x 和 y 对应的结点是深度最大的结点，且两者为兄弟结点。x 和 y 的码字长度相同且只有最后一个比特位不同。 设字符 a 和 b 在 T 中对应的结点是深度最大的结点，假设 a.freq≤b.freq 且 x.freq≤y.freq ，由于x.freq 和 y.freq 是所有字符频率中最小的两个频率，故 x.freq≤a.freq 且 y.freq≤b.freq 。 若x.freq=b.freq ，则 a.freq=b.freq=x.freq=y.freq 。此时引理成立。 假设x.freq≠b.freq ，意味着 x≠b 。 如图15-7所示，在 T 中交换 a 和 x 生成 T′ ，在 T′ 中交换 b 和 y 生成 T″ ， T 和 T′ 的代价差值为： 即 B(T)≥B(T′) ，同理可得， B(T′)≥B(T″) ，由不等式的传递性， B(T)≥B(T″) ，又 T 表示任一最优前缀无关编码对应的一棵二叉树，有 B(T)≤B(T″) ，得 B(T)=B(T″) ，故 T″ 也表示某一最优前缀无关编码对应的一棵二叉树。 引理16.2 说明，不失一般性，通过合并来构造最优树的过程，可以从合并出现频率最低的 两个字符这样一个贪心选择开始。 引理15.3(Lemma 15.3) 这条引理将证明构造最优前缀无关编码问题具有最优子结构性质 [!note] 给定一个字母表 C ，每个字符 c∈C 的频率为 c.freq ，若 x 和 y 是 C 中频率最低的两个字符，定义字符 z 且 z.freq=x.freq+y.freq ，定义字母表 C′=(C−{x,y})∪{z}，字母表 C′ 的任一最优前缀无关编码对应的一棵二叉树 T′ ，将 T′ 中的字符 z 对应的叶结点修改为一个内部结点且两个孩子结点分别为字符 x 和 y 对应的叶结点，这样可以得到字母表 C 的某一最优前缀无关编码对应的一棵二叉树 T 。 证明： 由 C′=(C−{x,y})∪{z} z.freq=x.freq+y.freq dT(x)=dT(y)=dT′(z)+1 `B(T)=∑c∈Cc.freq⋅dT(c)`` `B(T′)=∑c∈C′c.freq⋅dT′(c) ， 可得 B(T)=B(T′)+x.freq+y.freq。 用反证法可证明， 二叉树 T′ 能够表示字母表 C′ 的某一最优前缀无关编码，则二叉树 T 能够表示字母表 C 的某一最优前缀无关编码。 定理15.4(Theorem 15.4) 算法HUFFMAN能够生成一个最优前缀无关编码。 证明：由引理15.2和引理15.3可得。 最优归并树 构造一棵最优三路归并树(optimal ternary merge tree) T=(V,E) ，其中只有度为 0 的结点和度为 3 的结点，设度为 i 的结点个数为 ni ，由|V|=|E|+1，可得 n0+n3=3*n3+1。 当叶子节点数不够时，构造权值为0的虚字符节点用来构造归并树 设给定一个由 n 个字符组成的字符集 C ，设需要补充的虚字符个数为 μ ，每个虚字符的频率为 0 。 由于 n0=n+μ，解得 μ 最小为 μ=3−1−((n−1)mod(3−1))=2−((n−1)mod2) 。 同理可得：k叉归并树的μ=k−1−((n−1)mod(k−1)) 构造最优三进制编码和构造哈夫曼编码的过程类似。哈夫曼树是最优二路归并树(optimal binary merge tree)。 采用自底向上的方法构造三路归并树，该算法使用了小根堆 Q ，小根堆的关键字为属性 freq 。 设合并次数为 k，则总减少的节点数为 2k。初始总叶子数为n+μ，最终剩下1个根节点，所以循环(n+μ−1)/2 OPTIMAL-TERNARY-MERGE的伪代码如下： OPTIMAL-TERNARY-MERGE(C) n = |C| μ = 2 - ((n - 1) mod 2)//虚字符个数 let PQ be a new min-priority queue keyed by freq PQ = C //构造虚节点 for i = 1 to μ allocate a new node x x.freq = 0 INSERT(PQ, x) for i = 1 to (n + μ - 1) / 2 allocate a new node w x = EXTRACT-MIN(PQ) y = EXTRACT-MIN(PQ) z = EXTRACT-MIN(PQ) w.first = x w.second = y w.third = z w.freq = x.freq + y.freq + z.freq INSERT(PQ, w) return EXTRACT-MIN(PQ) // the root of the tree is the only node left 需要合并 (n+μ−1)/2 次，每次优先队列调整的运行时间为 O(lg⁡n) ，所以OPTIMAL-TERNARY-MERGE的运行时间为 O(nlg⁡n) 。 评：参考《数据结构（C语言版）》11.5 最佳归并树。 离线缓存 [!note] 缓存(cache)：容量比主存小，速度比主存快的存储器(memory)。计算机通过把需要访问的数据的一部分储存在缓存中，可以减少数据的访问时间。缓存将数据有组织地存放在缓存块(cache blocks)中，缓存块大小一般是 32 、 64 或 128 字节。 主存(main memory)：虚拟内存系统中，主内存可以被视为驻留在磁盘上的数据的缓存。这些主存块(blocks)被称为页(pages)，页大小一般是 4096 字节。 问题 当一个程序执行时，需要进行一系列的存储器请求。假设有 n 个访存请求，这些数据按照请求顺序分别在 b1,b2,…,bn 块中。事实上，这些请求不会完全不同，多个请求有可能需要访问同一个块。 当需要访问 bi 时，会出现以下三种情况： 情况一：由于之前访问过 bi ， bi 已经在缓存中，当需要再次访问 bi 时，可以直接访问缓存，称为缓存命中(cache hit)。 情况二：bi 不在缓存中，缓存未满，当需要访问 bi 时，直接将 bi 填充到空闲的缓存块。 情况三：bi 不在缓存中，缓存已满，当需要访问 bi 时，需要预先将某一个缓存块空出来，然后将 bi 填充到空闲的缓存块。 情况二和情况三称为缓存未命中(cache miss)。情况二称为强制未命中(compulsory miss)。 一般情况下，由于计算机无法知道未来的请求，因此缓存(caching)是一个在线问题。这里我们仅仅考虑缓存问题的离线版本，即已知完整的访存请求序列和缓存块数量，我们的目标是最小化缓存未命中，最大化缓存命中。 [!important] 我们采用称为将来最久(furthest-in-future)的贪心策略求解离线缓存问题，即如果缓存已满，那么选择已在缓存中且访存序列中将来最久到达的块进行置换。在有些情况下，我们可以提前知道完整的访存请求序列，例如，我们可以将主存视为磁盘或者固态硬盘中所有数据的缓存，即已经有一些算法可以预先计划整个读写操作集。此外，我们可以使用最优算法的缓存未命中数作为比较多种在线算法性能的基线。这些我们将在27.3节中进行说明。 离线缓存也可以用于现实生活中的问题的建模。 解答 采用称为将来最久(furthest-in-future)的贪心策略求解离线缓存问题，即如果缓存已满，那么选择已在缓存中且访存序列中将来最久到达的块进行置换。 则接下来讨论贪心策略的最优子结构和贪心选择性质 离线缓存的最优子结构(Optimal substructure of offline caching) 定义子问题 (C,i) ，缓存块集合为 C ，访存请求序列为 bi,bi+1,…,bn ，当前需要请求 bi ，设可用的缓存块数量最多为 k ， |C|≤k 。子问题 (C,i) 的最优解要求使得缓存未命中数最小 设子问题 (C,i) 的最优解为 S ，请求 bi 完成后缓存块集合为 C′ ，子问题 (C′,i+1) 的最优解为 S′ 。 定义 RC,i 为子问题 (C,i) 请求 bi 完成后可能的缓存块集合的集合，有： 情况一： RC,i={C}，对应缓存命中 情况二： RC,i={C∪{bi}}，对应缓存强制未命中 情况三： RC,i={(C−x)∪{bi}:x∈C}，对应缓存未命中且满 定义 miss(C,i) 为子问题 (C,i) 的最优解的缓存未命中数。递归式如下： 离线缓存的贪心选择性质(Greedy-choice property of offline caching) 最优离线缓存具有贪心选择性质(Optimal offline caching has the greedy-choice property) 考虑子问题 (C,i) ，缓存块集合为 C 有 k 个缓存块，即此时缓存已满，且出现缓存未命中。当前需要请求 bi ，设 z=bm 为 C 中将来最久被请求的缓存块，（如果有缓存块将来不再被访问，优先考虑这样的缓存块成为 z ，所以可以增加虚缓存块，使得 z=bm=bn+1 。）我们可以移除缓存块 z ，然后将增加缓存块 bi ，如此操作可以得到子问题 (C,i) 的某一个最优解。 证明详见算法导论（第四版）第十五章：贪心算法　第四节：离线缓存 - 知乎 贪心算法原理 [!note] 以通过贪心选择来改进最优子结构，使得选择后只留下一 个子问题 也就是优化动态规划的子问题数量 以下步骤设计贪心算法。 [!important] 最优化问题为你做出选择后只有一个子问题需要求解。 证明每次做出贪心选择后，原问题总是有最优解，所以贪心选择总是安全的。 证明做出贪心选择后的子问题和贪心选择一起构成原问题的最优解，即原问题具有最优子结构。 能够用贪心算法求解的问题具有贪心选择性质和最优子结构。 贪心选择性质(Greedy-choice property) 贪心选择性质(greedy-choice property)：可以通过作出局部最优（贪心）选择来构造全局最优解。 [!important] 贪心算法和动态规划的对比： 动态规划的选择依赖于子问题的解，所以一般采用自底向上的方法求解问题。 贪心算法不依赖于子问题的解，所以一般采用自顶向下的方法求解问题。 因此必须证明每个步骤做出贪心选择能生成全局最优解： 首先考查某个子问题的最优解，然后用贪心选择替换某个其他选择来修改此解，从而得到一个相似但更小的子问题。 如果我们进行贪心选择时不得不考虑众多选择，我们必须提高进行贪心选择的效率。通过对输入数据进行预处理或者选择合适的数据结构（通常是优先队列），我们可以快速做出贪心选择，从而得到高效的算法。 最优子结构(Optimal substructure) [!note] 如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质。 贪心算法通常采用一个非常直接的方法运用最优子结构，假定通过对原问题的贪心选择就可以得到子问题，我们只需要证明做出贪心选择后的子问题和贪心选择一起构成原问题的最优解。 该方法隐式地运用了归纳法证明了每一步贪心选择都能构成原问题的最优解。 贪心VS动态规划(Greedy versus dynamic programming) 虽然贪心和动态规划方法都对问题的最优子结构进行了研究，但是如何选择两种方法求解问题却是个难点，所以我们用下面两个问题进行举例。 0-1背包问题(0-1 knapsack problem)：商店里有 n 个商品，第 i 个商品价值为 vi ，重量为 wi ，现在有一个可容纳最大重量为 W 的背包，目标使得背包中的商品总价值最大，每个商品只能选择一次，且要不选择整个某商品要不不选择某商品，应该选择哪些商品。 分数背包问题(fractional knapsack problem)：问题场景和0-1背包问题一样，唯一区别是可以选择拿走商品的一部分，应该选择哪些商品。 可以将0-1 背包问题中的商品想象为金锭，而分数背包问题中的商品更像金砂。 两个背包问题(knapsack problem)都具有最优子结构。 分数背包问题可以用贪心策略求解，练习15.2-1要求你证明分数背包问题的贪心选择性质。首先计算每个商品的每磅价值v./w,。遵循贪心策略，小偷尽量多地拿走每磅价值最高的商品 0-1背包问题只能用动态规划求解，练习15.2-2要求你用动态规划求解0-1背包问题。因为可能无法法装满背包，空闲空间降低了案的有效每磅价值导致贪心策略失败 [!note] 给定两个集合 A 和 B ，每个集合都包含 n 个正整数，你可以按照任意顺序重排每个集合。重排后，令 ai 为集合 A 中第 i 个元素， bi 为集合 B 中第 i 个元素，请设计一个算法，使得ai^bi的和最大化，给出该算法的运行时间，并证明该算法的正确性。 将集合 A 和 B 中元素分别按值进行降序排序，此时 ai^bi的和最大。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 16_贪心算法 "},"docs/DataStructure_and_Algorithms/Algorithms/17_回溯.html":{"url":"docs/DataStructure_and_Algorithms/Algorithms/17_回溯.html","title":"17_回溯","keywords":"","body":" 回溯 一般方法 基本思想 方法适用问题特点 细分多阶段决策问题 多米诺性质 回溯求解的基本概念 解空间树 问题建模 子集和问题 动态树 动态树结点生成方式 回溯的具体算法 回溯的设计思想 回溯法的形式化描述 回溯法的非递归算法描述 回溯法的递归算法描述 回溯法的效率分析 决定回溯法效率的因素 回溯法的效率估计 蒙特卡罗方法的一般思想 n-皇后问题 子集和数问题 图着色问题 回溯 一般方法 基本思想 回溯法是一种搜索算法，是通用的解题法。 以深度优先的方式系统地搜索问题的解。 例如迷宫问题，深度优先搜索遍历迷宫路径 方法适用问题特点 方法适用于解决多阶段决策问题，也称为组合问题 问题的解向量用元组表示，元素xi通常取自于某个有穷集Si ,1≤i≤n, n表示问题规模 固定长n元组组(x1, … , xn) 可变长k元组(x1, … , xk), k 问题目标 满足约束条件的一个解或多个解；通常用限界函数表示约束条件； 满足约束条件的最优解；此时需要定义目标函数，使目标函数取极值的解是最优解。 问题满足多米诺性质 适用于求解组合数较大的问题。 细分多阶段决策问题 组合搜索：关注解的存在性 问题描述中仅存在约束条件 问题希望找到一个可行解（简单的0/1背包）/所有可行解（子集和） 组合优化：关注解的最优性 问题描述中还存在目标函数 问题希望找到一个具有极小值（最短路径）/极大值（树的路径权值最大）的可行解，即最优解，也称为极小化/极大化问题 多米诺性质 设P(x1,…,xi)是关于向量(x1,…,xi)的某种性质的判定，当P(x1,…,xi+1)为真 时，一定有P(x1,…,xi)为真，0,相反P(x1,…,xi)不成立，则P(x1,…,xi+1)亦不成立 所以对于一个满足多米诺性质的组合问题指能够根据约束条件和目标函数不断检验正在构造的部分解向量 (x1,…,xi)，0一旦发现不成立，则无需考虑后续xi+1,…,xn的取值，也就是剪枝 多米诺性质是回溯法提高算法效率的关键，可以通过剪枝去除不必要的搜索 [!note] 设限界函数B实现问题的约束条件，对于n元组(x1,…,xn), xi∈Si 回溯法利用多米诺性质：提前检验正在构造中的部分向量(x1,…,xi)，如果发现不能导致问题的解, 终止该向量继续构造 回溯求解的基本概念 显式约束：每个xi的取值集合Si ，可能与问题实例有关，也可能无关 隐式约束：描述xi彼此相关的情况，与问题实列有关，对应着限界函数 解空间：满足显式约束的所有元组 可行解：解空间内满足隐式约束的元组 解集合->解空间->可行解 解空间树 回溯法解决问题的过程就是在解空间树上搜索答案状态结点的过程 解空间树就是基于解空间画成的树形状 树中的节点对应问题状态，其中解状态就是由根到节点X的那条路径确定了这个解空间中的一个元组， 答案则是解状态中满足隐式约束的路径 答案状态 问题建模 确定元组表达形式：固定长或者不定长 确定显式和隐式约束 遍历解空间树过程中检验问题发多米诺性质，以便剪枝 确定解空间树：问题状态、解状态和答案状态 子集和问题 已知n+1个正数：wi(1≤i≤n)和M, 要求找出wi的和是M的所有子集。 即简单0/1背包的所有解 固定长元组 n元组(x1, … , xn) 显式约束：xi∈{0,1},1≤i≤n；如果选择wi，则xi=1；否则xi=0 隐式约束：∑wixi=M，1≤i≤n 多米诺性质，部分解向量大于M,剪枝 解空间共计2^n个元组 不定长元组 k-元组(x1, … , xk), k≤n 显式约束：不重复；隐式：和为M 多米诺性质，部分解向量大于M,剪枝 解空间共计2^n个元组 动态树 静态树: 即解空间树，树结构与所要解决的问题实例无关。 动态树: 树结构与实例相关, 在求解过程中生成结点 活结点：自己已经生成而其儿子结点还没有全部生成的结点 E-结点(正在扩展的结点): 当前正在生成其儿子结点的活结点。 死结点: 不再进一步扩展或者其儿子结点已全部生成的结点。 动态树结点生成方式 回溯法：基于深度优先 E-结点R一旦生成一个新的儿子结点C, 这个C结点就变成一个新的 E-结点, 当检测完了子树C后, R结点就再次成为E-结点, 生成下一个儿子 结点 分治限界法：基于广度优先 当前结点一旦成为E-结点，就一直处理到变成死结点为止。 其生成的儿子结点加入到活结点表中，然后再从活结点表中选择下一个新的E-结点。 回溯的具体算法 回溯的设计思想 定义解空间树结构：元组、显式隐式约束条件 检验问题满足多米诺性质 深度优先搜索解空间树，并通过限界函数剪枝，避免无效搜索 在解空间树中搜索, 直至找到所要求的解或解空间中已没有活结点时为止。 回溯法的形式化描述 假设要求出所有可行解，即所有答案结点 (x1,x2,…,xi-1)是状态空间树中由根出发的一条路径，到达 结点Y 对于限界函数Bi，如果路径(x1,x2,…,xi-1,xi)不可能延伸到一 个答案结点，则Bi(x1,x2,…,xi)取假值,否则取真值 回溯法的非递归算法描述 procedure BACKTRACK(n) int k, n local X(1: n) k ← 1 while (k>0) do if (还剩有没检验的X(k)使得X(k)∈T(X(1)…X(k-1)) and B(X(1)…X(k))=TRUE) then if (X(1) …X(k))是一条抵达答案结点的路径) then print ( X(1)…X(k)) endif k ← k+1 else k ← k-1 //回溯 endif repeat end BACKTRACK 回溯法的递归算法描述 procedure RBACKTRACK(k) global X(1:n); int k, n; for (满足下式的每个X(k), X(k) ∈T(X(1)…X(k-1)) and B(X(1),…X(k))=true) do if (X(1),…,X(k))是一条抵达答案结点的路径 then print (X(1)…X(k)) endif call RBACKTRACK(k+1) repeat end RBACKTRACK 回溯法的效率分析 决定回溯法效率的因素 生成下一个X(k)的时间 满足显式约束的X(k)的数目 限界函数Bj的计算函数：Bi能够大大减少生成的结点数，但在计算时间和减少程度上要进行折中 对于所有的i，满足Bi的X(k)的数目 回溯法的效率估计 解空间的结点数是2^n或n!， 易知，回溯算法最坏情况下的时间复杂度 为O(p(n)2^n)或O(q(n)n!)，其中p(n)和q(n)为n的多项式 用回溯算法处理一棵树所要生成的结点数(活结点），可以用蒙特卡罗方法估算出来 蒙特卡罗方法的一般思想 假定限界函数是固定的 状态空间中生成一条随机路径 x是这条路径上的位于第i级的一个结点 设限界函数确定x的可用儿子结点的数目为mi。 从这mi个儿子结点中随机选中一个，重复上述过程，直到当前结点是叶结点或者儿子结点都被限界为止 [!note] 不受限界结点的估计数: m=1+m1+m1*m2+m1*m2*m3+… mi表示第i级结点没受限界的儿子结点数。 n-皇后问题 问题描述： 在一个n*n棋盘上放n个皇后，使得每两个皇后都不能在同一行、同一列及同一条斜角线上。 基于回溯法求解： n-元组(x1,…xn)：表示皇后i放在i行xi列上。 显示约束：1，使得解空间为n^n 隐式约束：没有两个xi可以相同, 且没有两个皇后可以在同一条斜角线上（已经不在同一行），解空间：n! 限界函数，两个皇后被放置在(i, j )和(k, l )位置，，如果行差距=列差距， 则两个皇后在同一条斜角线上即| j – l | = | i– k | //能否放置一个新皇后 procedure PLACE(k) //若一个皇后能放在第k行和第X(k)列, 则返回true, 否则返回false。 //X是全程数组, 进入此过程时已置入了k个值, ABS是绝对值函数。 int i , k i←1 while ( i n-皇后问题的回溯算法描述 procedure NQUEENS(n) int k, n, X(1:n) X(1) ← 0 ; k ← 1 // k是当前行; X(k)是当前列 while (k>0) do // 对所有的行执行循环语句 X(k) ← X(k)+1 // 移到下一列 while ( X(k) ≤ n and not PLACE(k) ) do X(k) ← X(k)+1；repeat //当前列X(k)不能放皇后k时，放到下一列 if(X(k)≤n) //找到一个位置 then if(k=n) //若是一个完整的解则打印数组X then print (X) else k ←k+1; X(k) ←0 //准备求解下一个皇后 endif else k ←k-1; //没有合适的位置, 回溯 endif repeat end NQUEENS 8-皇后问题的不受限结点的估计值 不受限结点的估计数大约是8-皇后状态空间树的结点总数的 1625/69281=2.34% N 皇后 子集和数问题 假定有n个不同的正数W(1:n)，找出这些数中所有使得和为M的组合。 元素W(i)称为权。 用固定长的n-元组X来表示，解向量元素X(i)取1或0值，表示解中是否 包含权数W(i)。∑W(i)X(i)=M，1≤i≤n 预处理排序，按权值非递减排序 则得到限界函数： 所以得到递归回溯算法 1 procedure SUMOFSUB(s,k,r) 2 //找W（1：n）中和数为M的所有子集。进入此过程时X(1),…,X(k-1)的值已确定。W(j)按非降次序排列。// 3 //下面的变量解释：s表示已经加进来的这个序列的和；r表示还没有加入进来的所有的数的和；k表示级数// 4 global integer M,n; 5 global real W(1:n); 6 global boolean X(1:n); 7 real r, s; 8 integer k,j; 9 //生成左儿子// 10 X(k)←1 if s+W(k)=M then 12 print(X(j),j←1 to k) 13 else 14 //这里指判断了界限函数的一个条件：我们假设所有的数的和大于等于M，否则没意义了，将一定无解；还假设第一个数小于等于M// 15 if s+W(k)+W(k+1) ≤ M then//B(k)=true// 16 call SUMOFSUB(S+W(k),k+1,r-W(k)) 17 endif 18 endif 19 //生成右儿子和计算Bk的值// 20 if s+r-W(k) ≥ M and s+W(k+1) ≤ M//B(k)=true// 21 then X(k)←0 22 call SUMOFSUB(s,k+1,r-W(k)) 23 endif 24 end SUMOFSUB 相对的，如果不经过预处理排序则限界函数则是当前子集的总和小于M luogu U407992 子集和数 - 洛谷 图着色问题 图着色问题(Graph Coloring Problem, GCP) 又称着色问题，是最著名的NP-完全问 题之一 数学定义：给定无向连通图G=(V,E)，其中V为顶点集合，E为边集合，用不同的颜色给图中顶点着色，要求任何两个相邻顶点的着色不同。 用m种不同颜色给图中顶点 着色，问：是否存在任何两个相邻顶点颜色不同的着色方案？ procedure OK( k ) int i , k i ← 1 while (i cpp // 检查顶点k的颜色是否合法 bool isSafe(int k, const vector& color, const vector>& graph) { for (int i = 1; i >& graph) { vector color(n + 1, 0); // 颜色数组（1-based） int k = 1; // 当前处理的顶点 while (k >= 1) { color[k]++; // 尝试下一个颜色 // 寻找合法颜色 while (color[k] 题1042. 不邻接植花 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 17_回溯 "},"docs/DataStructure_and_Algorithms/Algorithms/18_分支限界.html":{"url":"docs/DataStructure_and_Algorithms/Algorithms/18_分支限界.html","title":"18_分支限界","keywords":"","body":" 分支限界 一般方法 分支限界使用的问题特点 分支限界的基本思想 分支限界的抽象化描述 检索方式 LC检索 LC检索的优点 成本函数c 成本函数c的量化方法 成本函数c的定义 成本函数c的问题 成本估计函数ĉ定义 总结 迷问题 问题描述 状态空间树 函数定义 检索 求最小成本的分支限界法 寻找最小成本 基于ĉ求最小成本的LC-检索算法 加速寻找最小成本 基于ĉ和U求最小成本的分支限界法基本思想 最小成本上界U 成本上界函数U(x) 界U的改值和剪枝 界函数UB 算法8.4 求最小成本的FIFO-分支限界算法 算法8.5 求最小成本的LC-分支限界法 极大化问题 总结求最优解问题的分支限界法 带有期限的作业调度问题 问题描述 解法 约束函数B 成本估计函数ĉ 成本上界U 完整实例 货郎担问题 问题描述 解 解空间 成本函数c 成本下界函数ĉ 成本上界U 总结 分支限界 一般方法 分支限界使用的问题特点 [!note] 清华大学出版社出版的屈婉玲等编著的《算法设计与分析》中认为：“分支限界是回溯算法的变种” 两者主要区别在于E-结点(即扩展结点)处理方式不同 分支限界法同样适用于求解组合数较大的问题， 特别是组合优化问题(求最优解)。 分支限界的基本思想 定义解空间树的结构：元组（等不等长），显式约束，隐式约束 检验问题的多米诺性质（可剪枝性） 假设当前寻找一个答案结点，按下列方式搜索解空间树： 如果根结点T是答案结点，输出T，操作结束；否则令T是当前扩展结点E。 生成E的所有儿子结点，判断每个儿子结点X： 如果X是答案结点，输出到根的路径，操作结束； 如果X满足限界函数B，则将X添加到活结点表中；否则舍弃X。 从活结点表中选出下一个结点成为新的E-结点，重复上述操作。如果活结点表为空，则算法以失败结束。 其中，限界函数剪枝作用：避免生成那些不包含可行解的子树。 分支限界的抽象化描述 伪代码 // ADD(X):将X添加到活结点表中 //LEAST(E):从活结点表中选中一个结点赋值给E，并从表中删除该结点 procedure BB(T) if T是答案结点then 输出T; return endif E←T 将活结点表初始化为空 loop for E的每个儿子X do if X是答案结点then 输出从X到T的那条路径; return; endif if B(X) then call ADD(X);PARENT(X)←E endif repeat if 表中不再有活结点then print(“no answer node”); return; endif call LEAST(E) repeat end BANDB 检索方式 根据活结点检索次序，分支限界策略可以分为 顺序队列：FIFO(先进先出)，活结点表采用队列实现，FIFO检索 优先队列：活结点依赖成本估计函数ĉ，ĉ最小/最大的活结点优先从活结点表中被选出。 活结点表采用极小堆/极大堆实现。LC检索 LC检索 LC检索的优点 理想状态下，对活结点表使用一个“有智力的”成本函数c来选 取下一个E-结点，从而加快到达答案结点的检索速度。 就是给每个活结点根据接近答案的程度设置优先级，但是只是适用于仅仅求可行解而不是全部解的情况 成本函数c 成本函数c的量化方法 令X是当前结点，c(X)定义为以X为根的子树中的最小成本值 方法1：寻找生成结点数目最少的答案结点 基于X在生成一个答案结点之前需要生成的结点数定义 方法2：寻找路径长度最短的答案结点 基于距离X最近的那个答案结点的路径长度定义 方法3：寻找使目标函数取极值的答案节点(最优解) 基于问题描述中的目标函数定义 本章中，问题不存在目标函数时，采用方法2定义c函数 成本函数c的定义 对状态空间树里的解状态结点X定义真实成本函数 从上帝视角对状态空间树里的任意结点X定义成本函数 [!caution] 探讨c(X)时，我们假设答案节点已经找到，检索树已经生成，一切都是在已知的情 况下进行讨论。 c(X)是节点X的真实成本函数 成本函数c的问题 c(X)基于答案结点的真实成本定义，为求出该值，需要生成状态空间树。 c的计算工作量与原问题具有相同的复杂度 转化思维，定义一个易于计算的成本估计函数ĉ，来替代c对 活结点表进行检索 成本估计函数ĉ定义 成本估计函数 ：ĉ(X)=f(h(X))+ ĝ(X） h(X)：根结点到结点X的成本 ĝ(X)：子树X中，X到最小成本答案结点的估计成本 f：为调整h和ĝ在成本估计函数ĉ中的影响比例而定义的非负函数 因此得出LC-检索和广度优先检索的关系 [!tip] ĉ(X)=f(h(X))+ ĝ(X) LC-检索(Least Cost search)：选取成本估计函数ĉ的值最小的活结点作为 下一个E-结点。 BFS-检索(广度优先)：f(h(X))=根到结点X的路径长度，ĝ(X)=0。即 BFS是LC-检索的特殊情况 总结 ĉ(X)=f(h(X))+ ĝ(X)要易于计算，且ĉ(X)≤c(X)；当叶节点X是答案节点时， c(X)=ĉ(X) 在LC-检索中，算法利用ĉ对活结点表进行检索。即优先选择更靠近答案 结点，同时又离根结点较近的结点 迷问题 问题描述 在一个分成16格的方形棋盘上放有15块编了号码的牌，如(a)所示，要求通过一系列合法的移动转换成(b)所示那样的目标排列，其中若当前牌邻接有空位置，则 可将牌移动到空位置 状态空间树 问题状态，即棋盘布局状态 其中初始排序a位初始状态，目标排序b为目标状态 对与棋牌每一次移动就会产生新的布局状态 其中当前结点X的儿子结点是X通过一次合法移动到达的布局状态 函数定义 POSITION(i)是棋牌i在初始状态时的位置号，1≤i≤16，POSITION(16)表示 空格的位置 LESS(i)是牌面上j 且 POSITION(j)>POSITION(i)的j的数目，即反序的数目 根据此有初始状态判定定理：当且仅当初始状态的∑LESS(i)+X是偶数时，图(b)所示的目标状态可由此状态到达 其中在初始状态下，如果空格在(c)的阴影 位置中，则令X=1；否则令X=0。 检索 FIFO检索:对于空格，顺序按照上右下左搜索 深度优先检索：采取由根开始的最左路径， 搜索过程中有可能远离目标 LC-检索 [!note] 定义c(X)：从初始排列到达目标排列时，棋牌最少移动次数 又ĉ(X)=f(X)+ĝ(X)， f(X)：从初始排列到X时，棋牌已经移动的次数 ĝ(X)：不在其目标位置的非空白棋牌数目（非法棋牌数） 求最小成本的分支限界法 寻找最小成本 BB算法中：算法一旦判断出儿子结点X是答案结点，则打印路径，操作结束 算法BB基于LC-检索寻找具有最小成本的答案结点，则ĉ要满足： 易于计算 对于每一个结点X，ĉ(X) ≤c(X) 对于答案结点X，有ĉ(X) = c(X) 追加：c(X) 改进算法：算法从活结点表中选出E结点时，再判断E是不是答案结点，若是则打印路径，操作结束。 基于ĉ求最小成本的LC-检索算法 procedure LC(T, ĉ)//为找出最小成本答案结点 E←T, 将活结点表初始化为空 loop if E是答案结点then 输出从E到T的那条路径; return; endif//c帽=c for E的每个儿子X do if B(X) then call ADD(X); PARENT(X)←E; endif repeat if 表中不再有活结点then print(“no answer node”); return; endif call LEAST(E)//选择最小的c帽 repeat end LC 对于活结点表中的每一个结点L，一定有ĉ(E)≤ĉ(L)。由ĉ定义知，E是答案结点时c(E)=ĉ(E)，则c(E)=ĉ(E)≤ĉ(L) ≤c(L)，也就找到最小成本节点 加速寻找最小成本 若发现结点X不能导致最小成本答案结点，也不必再搜索子树X，子树X被剪枝。 所以设置一个最小成本上界U，问题的最小成本不会大于这个上界U。如果 ĉ(X)>(/≥)U，则算法无需检索以X为根的子树。 基于ĉ和U求最小成本的分支限界法基本思想 对于极小化问题，把目标函数作为成本函数 约束条件作为约束函数B 问题转化为寻找解空间树中最小成本答案结点 设计成本估计函数ĉ(X)，ĉ(X)≤c(X) 还可以设计最小成本的上界U，c(X)≤U 基于ĉ(X)和U进行分支限界搜索，其中c帽决定遍历方向，U决定剪枝 最小成本上界U U是当前算法生成的所有状态结点对最小成本上界估计的最小值 初始无穷大，或通过启发式方法(或者贪心）得到；初值≥最小成本答案结点的成本 并随着结点访问缩小 主要作用是判断结点死活，是否剪枝 成本上界函数U(x) u(X)是对成本c(X)的上界估计 u(X)可仿照ĉ(X)定义，或其他方式 根到X的成本 子树X中，X到最小成本答案节点的成本上界估计 易于计算，C(x) [!note] 区分函数cost,ĉ,c和u cost(X)：根到答案结点X的真实成本 c(X)：子树X中所有答案结点的最小成本值， 即最小cost值 ĉ(X)和u(X)：对子树X的c值估计，满足 ĉ(X)≤c(X)≤u(X) 设图中，设当前每个结点都满足约束条件 当cost(X)>u(X)时，意味着以X为根的子树中一定有更优解。 界U的改值和剪枝 U改值：答案结点X，cost(X)时，U = cost(X);状态结点X,u(X)时，U = u(X)同时符号取值小者 U剪枝：U值来自一个真实成本，ĉ(X)≥U的活结点X都可以被杀死；U值来自一个成本上界，ĉ(X)>U的所有活结点X都可以被杀死 界函数UB 一个足够小的正常数ε：对任意结点X,Y，如果u(X) procedure UB(X,ε,U,ans) //X是当前活结点，U是当前上界估计值，ans是当前最小成本的答案结点。 //结点X满足ĉ(X)≤c(X)≤u(X)；当X是答案节点时，cost(X)表示根到X的真实成本。 if ĉ(X)≥U then return false if X是解结点 and cost(X) 算法8.4 求最小成本的FIFO-分支限界算法 假定状态空间树T至少包含一个解结点，并且不可行结点的估计值ĉ(X)=∞ procedure FIFOBB(T,ĉ,u,ε,cost) E←T; PARENT(E)←0; U←∞，ans←0 UB(E,ε,U,ans) 将队列初始化为空 loop for E的每个儿子X do if B(X) and UB(X,ε,U,ans) then call ADDQ(X); PARENT(X)←E endif repeat loop if 队列为空 then print (‘least cost = ‘, U); 输出从ans到T的路径;return endif call DELETEQ(E); if ĉ(E) 算法8.5 求最小成本的LC-分支限界法 假定状态空间树T至少包含一个解结点，不可行结点的估计值ĉ(X)=∞ 不同于FIFO，这里将活结点表的最小估计成本组织成最小堆，每次取当前活结点表中估计成本最小的处理其子节点 procedure LCBB(T,ĉ,u,ε,cost) //函数ADD：加一个结点到min-堆中；函数LEAST：从min-堆中删去堆顶结点 E←T; PARENT(E)←0; U←∞，ans←0 UB(E,ε,U,ans) 将活结点表初始化为空 loop for E的每个儿子X do if B(X) and UB(X,ε,U,ans) then call ADD(X); PARENT(X)←E endif repeat if 表中不再有活结点 or 堆顶结点ĉ值≥U then print (‘least cost = ‘ ,U); 输出从ans到T的那条路径; return endif call LEAST(E) repeat end LCBB 极大化问题 将问题转化为极小化问题：取目标函数的相反数作为成本函数c 对照极小化问题做镜像修改：把目标函数作为成本函数c，问题转化为寻找解空间树中最大成本答案结点，此时u(X)≤c(X)≤ĉ(X)。 总结求最优解问题的分支限界法 剪枝依据：约束函数B限定是否存在可行解，成本估计函数数ĉ(X)和界U界定是否存在最优解 剪枝发生点： X入活结点表时，接受B检验和U检验(判断是否可行以及是否存在最优解) X出活结点表时，接受U检验（判断是否存在最优解） 算法终止：活结点表为空；或者活结点表中再没有通过U检验的活结点 带有期限的作业调度问题 问题描述 假设有n个作业和一台处理机，每个作业i由一个三元组(pi,di,ti)表 示，表示作业需要ti个时间处理完毕，如果在期限di之前没有完成 则要交付pi的罚款。 从这n个作业中选取一个子集合J，使J中作业都能在相应的期限内完成，而不在J中的作业罚款总数最小。也就是极小化问题 解法 解空间表示：不定长的k-元组(X1,..Xk), k≤n 显示约束：作业在集合里 隐式约束：对于Xj，有sum(t0,...,tj)，即所有作业在期限前完成 目标函数：未选中的作业罚款总数最小 状态空间树：2^n个结点 其中：圆形结点表示满足约束条件的结点；方形结点表示不可行结点 约束函数B k-元组表示状态空间树 按层次遍历为结点编号 实例： (p1,d1,t1)=(5,1,1);(p2,d2,t2)=(10,3,2);(p3,d3,t3)=(6,2,1);(p4,d4,t4)=(3,1,1) 成本估计函数ĉ 定义成本估计函数ĉ(X)，使得ĉ(X)≤c(X)： Sx是根结点到达结点X时选中的作业集合 m=max{i|i∈Sx} ĉ(X)=∑pi, 1,若X是可行解 ĉ(X)=∞，若X是不可行解 实例： (p1,d1,t1)=(5,1,1);(p2,d2,t2)=(10,3,2);(p3,d3,t3)=(6,2,1);(p4,d4,t4)=(3,1,1) 成本上界U 上界估计函数u(X)=∑pi, i∉Sx 实例： (p1,d1,t1)=(5,1,1);(p2,d2,t2)=(10,3,2);(p3,d3,t3)=(6,2,1);(p4,d4,t4)=(3,1,1) 完整实例 货郎担问题 问题描述 TSP问题：某售货员要到若干个城市销售货物，已知各城市之间的距离，要 求售货员从某一城市出发并选择旅行路线，使每个城市经过一次，最后回到 原出发城市，而总路程最短。 问题形式化描述：设G(V,E)是一个有向图，|V|=n，cij>0表示边∈E的成 本。寻找一条最小成本的周游路线，不失一般性，考虑从结点1开始，在结点1结束 动态规划方法求解的时间复杂度是Θ(n^2*2^n) 分支限界法最坏情况也是O(n^2*2^n) ，但对许多具体实例，能花费较少的时间 解 解空间 问题的解是S中结点的一种排列(X1,X2,X3)，使1,X1,X2,X3,1的成本最小 固定长3-元组(X1,..Xn-1)，n=4 显式约束：Xi属于G，且互不相同 隐式约束：存在周游路线1,X1,X2,X3,1，即相邻两点有边存在 目标函数：周游路线成本最小 状态空间树：共计3!个叶结点 成本函数c 成本函数c(X)：目标函数作为成本函数 c(X)=根到X的的路径的周游路线成本，X是叶结点 c(X)=子树X中最小成本叶结点的成本，X非叶结点 成本下界函数ĉ 成本下界函数ĉ(X) ≤ c(X)，X表示(X1,..Xk)到达的结点，ĉ(X)= f(X)+ ĝ(X) f(X)表示已选定的路线X0=1,X1,…Xk的成本和 ĝ(X)表示经过剩余结点回到1的最短距离估计，具体为已选定路线最后一个点最小出边加上剩余结点出边最小值 成本上界U 成本上界U≥c(X)：当前得到的最短周游路线长度 ，其中初始值一般为贪心解 实例 总结 [!tip] 分支限界法与回溯法： 相同点： 同样适用于求解组合数较大的问题(/多阶段决策问题) 都是在解空间树上搜索答案结点 都会借助约束函数B进行剪枝 分支限界法与回溯法的不同点： 最本质的区别在于E-结点(即扩展结点)处理方式不同 存储空间上，分支限界法需要额外维护活结点表，回溯法不需要 分支限界法求极小化问题，即寻找状态空间树中最小成本的答案结点 目标函数作为成本函数c 约束条件作为约束函数B 设计成本估计函数ĉ(X)，ĉ(X)≤c(X) 设计最小成本的上界U，c(X)≤U 基于ĉ(X)和U进行分支限界搜索，也就是通过ĉ(X)>=U去活加速搜索 求极大化问题 目标函数取相反数，转化为极小化问题 或对照极小化问题做镜像修改 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 18_分支限界 "},"docs/DataStructure_and_Algorithms/Algorithms/19_NP问题.html":{"url":"docs/DataStructure_and_Algorithms/Algorithms/19_NP问题.html","title":"19_NP问题","keywords":"","body":" NP-完全问题 判定问题 优化问题可以转化为判定问题（存在性问题） 优化问题转化为判定问题的好处 不确定的判定问题 不确定算法 不确定机 检索问题不确定性 不确定算法设计 排序问题的不确定算法 不确定的判定算法 问题规模的二进制表示 NP问题与NP完全性 P和NP 归约定义 多项式时间归约 NP完全问题（NPC问题） P问题、NP问题、NP完全问题 NPC的意义 可满足性（SAT)问题 可满足性问题的不确定算法 Cook定理 小结 NP-完全问题 判定问题 优化问题可以转化为判定问题（存在性问题） 判定问题是指只需要回答“是”和“否”的问题，即是否存在某种情况 例如图着色问题 原问题：已知图G=，求对G的n个顶点 进行着色的一种方法（相邻顶点颜色不同），问最少需要多少种颜色 转为判定问题：已知图G= ，问图G是否可用k 种颜色进行着色？ 最大团问题 原：图G=(V,E)的一个完全子图叫做G的一个团(clique)。团的大小用所含的 结点数表示。 求G内最大团和它的大小。 已知图G=G=(V,E)，问图G是否存在一个大小为k的团？ 01背包问题 已知n个物品的效益值pi和重量wi， 每个物品只能整取。在背包容量M 的限定下如何选择，使选中物品的 效益值之和最大 在M限定下，对于给定效益值X，是否存在一组选择策略，使选中物品 的效益值之和大于等于X？ 优化问题转化为判定问题的好处 最大团问题可以在多项式时间内求解，当且仅当其判定问题可以在多项式 时间内求解 将优化问题转化为判定问题的好处是消除了不同优化问题的输出差异性， 通过转化为判定问题，输出统一成“是”和“否” 不确定的判定问题 不确定算法 从理论角度看，取消对运算“确定性”这一限制。 即允许运算结果受限于某个特定的集合。 包含这种不确定运算的算法称为不确定的算法 为描述不确定算法，SPARKS中引进了一个新函数和两个新语句，时间复杂 度恒为O(1) choice(S)：按题意选取集合S中的一个元素 failure：发出不成功完成的信号 success：发出成功完成的信号 不确定机 能按上述方式执行不确定算法的机器称为不确定机（实际上不存在） 检索问题不确定性 考察给定元素集A(1:n),n>=1中，元素X的检索问题。需确定下标j，使得A(j)=x，或者当x不在A中时有j=0。 j←choice(1:n) if A(j)=x then success endif j←0；print(‘0’); failure 不确定算法设计 猜想阶段：也称为不确定阶段，基于不确定函数choice猜出一个解 验证阶段：也称为确定阶段，用确定语句验证构造出的解是否是答案 不确定算法在多项式时间可验证 时间复杂度：failure时为O(1)；success不确定阶段和确定阶段的时间复杂度之和 排序问题的不确定算法 设A(1:n),1≤i≤n，是一个待排序的正整数集，要求将其按非降次序排序 procedure NSORT(A,n)//对n个正整数排序 integer A(1:n),B(1:n),n,i,j B(1:n)←0 //辅助数组 for i←1 to n do//构造 j←choice(1:n), if B(j) ≠0 then failure endif； B(j)←A(i) repeat for i←1 to n-1 do//验证B的次序 if B(i)>B(i+1) then failure endif repeat print(B) success end NSORT 不确定的判定算法 不确定的判定算法只需要回答yes或者no的问题，只产生0/1 输出 例如：最大团判定问题的不确定算法 procedure DCK(G,n,k)//n表示图G中点的个数 S 问题规模的二进制表示 统一度量不同判定问题的算法时间复杂度，不同算法的输入参数均转 换为二进制形式，算法时间复杂度基于二进制输入长度来考虑 例如： 最大团判定问题DCK(G,n,k)的输入 设图G由其邻接矩阵表示，n是点个数，k是判定值 二进制转换输出参数集，其长度和为m 算法DCK的时间复杂度：O(n^2)=O(m) NP问题与NP完全性 P和NP [!note] P问题：所有可在多项式时间内用确定算法求解的判定问题的集合 NP问题：所有可在多项式时间内用不确定算法求解的判定问题的集合，即能够用不确定算法在多项式时间里猜出一个解和验证一个解 P问题、NP问题与非P问题 P问题是NP问题的一种特例，但尚不确定是否有P=NP或者P≠NP NP≠非P问题，它是非P问题中用不确定算法能在多项式时间内求解的那部分判定问题的集合，因此NP⊂非P问题 归约定义 [!tip] 定义（归约）：令L1和L2是两个问题，如果有一确定的多项式时间算法求解L1，而这个算法使用了一个在多项式时间内求解L2的确定算法，则称L1归约为L2（L1） 可以用问题L2的解法解决问题L1，或者说，问题L1可以“变 成”问题L2 特殊的判定问题L1到判定问题L2的归约 存在一个转换函数T，可以把问题L1的输入x转换为问题L2 的输入T(x)，满足：问题L1对于输入x得到正确结果当且仅当问题L2对于输入T(x)得到正确结果。 归约具有传递性 直观意义：L1可归约为L2，则L2的时间复杂度不低于L1的时间复杂度，即L1不比L2难 多项式时间归约 T是问题L1归约到L2的转换函数，如果计算T的算法是多项式级的，则称 问题L1可以多项式时间归约到L2，记为L1 多项式时间归约具有传递性 NP完全问题（NPC问题） 问题L是NP-完全的，或NPC的，当满足： L∈NP 对于每个L’∈NP，有L’ 问题L是NP-难的，或NP-hard的，当满足：对于每个L’∈NP，有L’ 因为没限定L∈NP，NP-难问题尚未找到多项式级的不确定算法 [!note] 比较NP-完全问题与NP-难问题 NP-hard比NPC范围广， NP-Hard同样难以找到多项式算法，有可能比所有NPC的时间复杂度更高从而更难以解决 NPC不是NP-hard，但它是NP中最难的问题 P问题、NP问题、NP完全问题 [!important] NP问题的定义引出未解问题：P是否等于NP基于NP完全问题发现， 如果任意一个NP完全问题可以在多项式时间解决，即所有NP问题均可在多项式时间解决，即P=NP，如果证明任意一个NP完全问题不存在多项式时间的解，则所有NP问题均不可能在多项式时间内 解决。 NPC的意义 所有的NP问题都可以多项式时间归约到一个NPC问题，这意味着一旦一个NPC问题多项式可解，则所有NP问题都多项式可解 P=NP充要条件是存在NPC问题L∈P [!note] 证明问题L是NPC： 证明L属于NP，即问题L是NP问题 已知一个NPC-问题L’, 证明L’，一个NPC问题可以归约为L 可满足性（SAT)问题 SAT问题是第一个被发现的NPC问题，它约化出 了其他NPC问题，如果证明出SAT问题是P问题， 就能证明出P=NP。 问题：对于任意给定的一个合取范式F, F是否可满足? 可满足性问题的不确定算法 Procedure EVAL(F,n) //判定命题F是否为可满足的。变量为Xi，1≤i≤n Boolean x(1:n) for i←1 to n do//选取一组真值指派 xi←choice(true,false) repeat if F(x1,…,xn)=true then success else failure endif end EVAL Cook定理 Cook定理：SAT是NP完全的 即任何NP问题都可以在多项式时间归约为SAT问题 小结 [!tip] P-问题：已经找到多项式算法的问题 NP-问题：可能找到多项式算法的问题 证明出NPC中的某个问题是P问题，那么所有的NP问题都是P问题，即 P=NP SAT问题是第一个被发现的NPC问题，它归约出了其他NPC问题 NPC-问题：SAT问题可以多项式时间归约到的NP问题 NP-难问题：SAT问题可以多项式时间归约到的问题 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 19_NP问题 "},"docs/DataStructure_and_Algorithms/Data_structure/":{"url":"docs/DataStructure_and_Algorithms/Data_structure/","title":"Data_structure","keywords":"","body":" 数据结构（Data structure）简短说明 数据结构（Data structure）简短说明 本文件夹包含常见数据结构的简明说明和示例，适合快速回顾或入门学习。 对于每一个数据结构，章节里都有进行详细的介绍和具体的代码，不过如果你想直接在本地运行对应数据结构的代码，可以查看我的github中对应的数据结构的仓库部署到本地运行。 例如Graph,Tree等 章节列表与简短说明： 01_Introduction：概述数据结构为何重要，以及常见分类。 02_Linear_List：讲线性表（如数组、链表）的基本概念和常见操作。 03_Stack_and_Queue：介绍栈和队列的用途与简单实现场景。 04_Array_and_Matrix：说明数组与矩阵的表示与常见操作。 05_Character_String：讲字符串的基本操作与常见问题处理方法。 06_Tree：介绍树结构，常见的遍历与用途。 07_Graph：说明图的基本概念、表示方法和常见算法场景。 08_Sort：总结常见排序方法和适用场景。 09_Search：讲查找技巧和常见的搜索算法。 data_structure：对本章节合集的总览或深入说明。如果想保存到本地，可以直接保存这个文件即可 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - Data_structure "},"docs/DataStructure_and_Algorithms/Data_structure/01_Introduction.html":{"url":"docs/DataStructure_and_Algorithms/Data_structure/01_Introduction.html","title":"01_Introduction","keywords":"","body":" 绪论 数据结构的研究内容 数据结构主要研究**非数值计算问题 ** 基本概念和术语 数据、 数据元素、 数据项和数据对象 数据（Date) 数据元素(Data Element) 数据对象 (Data Object) 数据结构 逻辑结构 线性结构 非线性结构 存储结构 算法和算法分析 算法定义及其特性 评价算法优劣的基本标准 时间复杂度 空间复杂度 绪论 数据结构的研究内容 数据结构主要研究非数值计算问题 ​ 数据结构是一门研究非数值计算程序设计中的操作对象， 以及这些对象之间的关系和操作的学科。 例如: 学生学籍管理系统 人机对弈问题 最短路径问题。 基本概念和术语 数据、 数据元素、 数据项和数据对象 数据（Date) 数据 (Data) 是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。 数学计算中用到的整数和实数 文本编辑中用到的字符串 多媒体程序处理的图形、 图像、声音及动画等通过特殊编码定义后的数据 数据元素(Data Element) 数据元素(Data Element)是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。 在有些情况下，数据元素也称为元素、记录等 数据元素用千完整地描述一个对象 一名学生记录 树中棋盘的一个格局（状态） 及图中的一个顶点 数据对象 (Data Object) 数据对象 (Data Object) 是性质相同的数据元素的集合，是数据的一个子集。 整数数据对象是集合N= {0, 士1' 士2,…} 字母字符数据对象是集合C= {'A','B', …，'Z','a','b', …， 'z'} 学生基本信息表也可以是一个数据对象 只要集合内元素的性质均相同，都可称之为一个数据对象。 数据结构 [!note] 数据结构 (Data Structure) 是相互之间存在一种或多种特定关系的数据元素的集合。 数据结构是带 ”结构＂ 的数据元素的集合 “结构” 就是指数据元素之间存在的关系 逻辑结构 数据的逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立千计算机的。 数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。 数据的逻辑结构有两个要素 数据元素 关系 （指数据元素间的逻辑关系） 集合结构 数据元素之间除了 “属于同一集合” 的关系外，别无其他关系。例如，确定一名学生是否为 班级成员， 只需将班级看做一个集合结构。 线性结构 数据元素之间存在一对一的关系。例如，将学生信息数据按照其入学报到的时间先后顺序进 行排列，将组成一个线性结构。 树结构 数据元素之间存在一对多的关系。例如，在班级的管理体系中，班长管理多个组长，每位组长管理多名组员，从而构成树形结构。 图结构或网状结构 数据元素之间存在多对多的关系。例如，多位同学之间的朋友关系， 任何两位同学都可以是朋友，从而构成图状结构或网状结构。 线性结构 线性表（典型的线性结构，如例1.1中的学生基本信息表） 栈和队列（具有特 4 l 第1章 绪论 I 殊限制的线性表，数据操作只能在表的一端或两端进行） 字符串（也是特殊的线性表，其特殊性 表现在它的数据元素仅由一个字符组成） 数组（是线性表的推广，它的数据元素是一个线性表） 广义表（也是线性表的推广，它的数据元素是一个线性表，但不同构，即或者是单元素，或者是 线性表） 非线性结构 树（具有多个分支的层次结构） 二叉树（具有两个分支的层次结构） 有向图（一种图结构，边是顶点的有序对） 无向图（另一种图结构，边是顶点的无序对） 存储结构 存储结构是逻辑结构在计算机中的存储表示 有两类存储结构：顺序存储结构和链式存储结构。 算法和算法分析 算法定义及其特性 算法 (Algorithm) 是为了解决某类问题而规定的一个有限长的操作序列。 算法由有限条指令构成，规定了解决特定问题的一系列操作。 一个算法必须满足以下五个重要特性。 有穷性：有限个步骤之后终止。 确定性：每条指令有明确的含义。 可行性：通过已经实现的基本运算执行有限次来完成。 输入：外界提供的量。 输出：结果。 评价算法优劣的基本标准 正确性：正确结果 可读性： 健壮性（鲁棒性）：对有缺失、有噪声或有错误的输入数据，算法应具有较强的适应能力。 高效性：时空复杂度。 时间复杂度 影响算法时间代价的最主要因素是问题规模。 问题规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示。 一条语句的重复执行次数称作语句频度(FrequencyCount) 而对于时间复杂度，取决于基本运算 基本运算是指算法运行过程中起主要作用且花费时间最多的运算 空间复杂度 算法在实现时所需要的辅助空间 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 01_Introduction "},"docs/DataStructure_and_Algorithms/Data_structure/02_Linear_List.html":{"url":"docs/DataStructure_and_Algorithms/Data_structure/02_Linear_List.html","title":"02_Linear_List","keywords":"","body":" 线性表 定义(逻辑结构) 存储结构 顺序存储 链接存储 时空效率比较 空间 时间 线性表 定义(逻辑结构) 由n(n>=0)个数据特性相同的元素构成的有限序列称为线性表 或者说是数据类型相同的元素组成的有限集合 线性表中元素的个数n(n>=0)定义为线性表的长度，n=0时称为空表。 对千非空的线性表或线性结构，其特点是： 存在唯一的一个被称作“第一＂的数据元素； 存在唯一的一个被称作“最后一个＂的数据元素； 除第一个之外，结构中的每个数据元素均只有一个前驱； 除最后一个之外，结构中的每个数据元素均只有一个后继。 存储结构 顺序存储 线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，这种表示也称作线性表的顺序存储结构或顺序映像。 逻辑上相邻的数据元素，其物理次序也是相邻的 简单来说就是数组 链接存储 用任意一组存储单元存储线性表 一个存储单元除包含结点数据字段的值，还必须存放其逻辑相邻结点（前驱或 后继结点）的地址信息，即指针字段。 链表 哨兵节点： 为便于在表头进行插入、删除操作，通常在表的前端增加一个特殊的表头结点，称其为哨位（哨兵）结点。 //节点 struct ListNode{ int data; ListNode* next; ListNode(int d){ data=d; next=NULL; } }; struct List{ ListNode* headnode;//哨兵节点 } 时空效率比较 空间 顺序表空间来自于申请的数组空间，数组大小确定，当元素较少时，顺序表中的很多空间处于闲置状态，造成了空间的浪费； 链表空间是根据需要动态申请的，不存在空间浪费问题，但链表需要在每个结点上附加一个指针，从而产生额外开销 时间 基于下标的查找 插入/删除 顺序表 O(1)按下标直接查找 O(n) 需要移动若干元素 链 表 O(n) 从表头开始遍历链表 O(1) 只需修改几个指针值 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 02_Linear_List "},"docs/DataStructure_and_Algorithms/Data_structure/03_Stack_and_Queue.html":{"url":"docs/DataStructure_and_Algorithms/Data_structure/03_Stack_and_Queue.html","title":"03_Stack_and_Queue","keywords":"","body":" 栈和队列 栈 定义 应用 队列 定义 应用 栈和队列 对于栈和队列，可以理解为操作受限的线性表，只可以在线性表的表头或者表尾进行操作 栈 定义 栈(stack)是限定仅在表尾进行插入或删除操作的线性表。 因此，对栈来说，表尾端有其特殊含义，称为栈顶(top) 相应地，表头端称为栈底(bottom)。 不含元素的空表称为空栈。 栈的修改是按后进先出的原则进行的，因此，栈又称为后进先出(LastIn First Out, LIFO)的线性表， 应用 进制转换：假设十进制转换为K进制： 创建一个栈Stack 不断除以K取余数。后生成的余数先输出，先生成的余数后输出，正好符合栈的后进先出性质。 括号匹配： 从左向右扫描字符串 若遇到左括号：压栈 若遇到右括号：弹出栈顶的左括号与之匹配。 最后判断栈空 n对括号共有多少种可能的合法匹配序列：第n个卡特兰数 Cn=(2n)!/(n!*n!)/(n+1) 表达式求值：（中缀表达式转变为后缀表达式） 从左到右依次读入后缀表达式的每一个操作数/运算符/结束符 若读到的是操作数，将它压入栈。 若读到的是运算符，就从操作数栈中连续弹出两个元素（操作数），进行相应的运算，并将结果压入栈中。 读入结束符时，栈顶元素就是计算结果。 调度场算法：中缀表达式转后缀表达式 设置一个栈，存放运算符从左到右依次读入中缀表达式的每一个元素 操作数规则：直接放入后缀表达式,注意对多位数的处理 运算符规则： 栈空或栈顶是左括号：压栈 当前运算符优先级>栈顶运算符：压栈 当前运算符优先级栈顶或栈空或栈顶为左括号（期间弹出的运算符顺序依次放入后缀表达式），再把当前运算符压栈 括号规则： (1) 遇到左括号：压栈 (2) 遇到右括号：弹栈直至左括号 结束符规则：弹栈至栈空 栈混洗：给定入栈序列，模拟出栈序列 n个元素的栈混洗总数，即n对括号的匹配序列，卡特兰数*(n+1) n个元素的栈混洗合法出栈序列，即n对括号的合法匹配序列，卡特兰数*(n+1) 利用栈模拟队列: 利用两个栈模拟队列 共享栈 队列 定义 队列(queue)是一种先进先出(First In First Out, FIFO)的线性表 允许插入的一端称为队尾(rear), 允许删除的一端则称为队头(front)。 应用 BFS广度优先搜索 栈和队列都需要注意的一点是top和rear指针是指向元素还是下一个空位置，判满和判空条件不同， 双端队列 利用队列模拟栈 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 03_Stack_and_Queue "},"docs/DataStructure_and_Algorithms/Data_structure/04_Array_and_Matrix.html":{"url":"docs/DataStructure_and_Algorithms/Data_structure/04_Array_and_Matrix.html","title":"04_Array_and_Matrix","keywords":"","body":" 数组和矩阵 数组 多维数组的存储和寻址： 矩阵 矩阵的压缩存储 数组和矩阵 数组 多维数组的存储和寻址： 已知数组A[a][b][c][d],每个元素占C个存储单元 数组元素A[i] j][k][l]的存储地址： 行优先:Loc(A)+( i*b*c*d + j*b*d + k*d + l )*C 列优先:Loc(A)+( i + j*a + k*a*b + l*a*b*c )*C 矩阵 矩阵的压缩存储 压缩存储需考虑2个问题 需要多大存储空间：数组d[ ]需要多少元素 地址映射：矩阵的任意元素M(i, j)在一维数组d[ ]中的位置（下标）， 即把矩阵元素的下标映射到数组d的下标 对角矩阵的压缩存储 对于一个n*n的对角矩阵，至多只有n个非0元素，因此只需存储n个对角元素 M( i , i ) -> d[ i ] (下）三角矩阵的压缩存储 以按行优先方式压缩存放在一维数组d，d需要n(n+1)/2个元素 M(i, j)= d[k]=d[i(i−1)/2 + (j−1)] 对称矩阵M的压缩存储 对称矩阵中M(i, j)与M(j, i)的信息相同，只需存储M的下三角部分的元素信息。 对于对称矩阵中的下三角元素M(i, j) (i>=j) : i 对于上三角元素M(i, j) (i:元素值与下三角矩阵中的 元素M(j,i)相同 i 三对角矩阵M的压缩存储 方阵Mn*n中任意元素M(i, j)，当| i - j | >1时，有M(i, j) =0， 则 M称为三对角矩阵。 需要3*n-2个存储单位 对于非零元素：即| i-j | 稀疏矩阵的压缩存储 非零元素的个数远小于零元素的个数 三元组结点来存储矩阵的每个非零元素aij，其中i和j为元素的行号和列号，即node(i,j,aij) struct Triple{ int row; int col; int value; }; Triple Array[100]; 对于三元组有一个需要注意的算法：稀疏矩阵的快速转置。 预先确定矩阵M中每一列（即T中每一行）的第一个非零元的位置 求出每行非零元素个数，然后利用cpot[col]=copt[col-1]+num[col-1]，求出位置 十字链表:数据,该结点所在行 ,该结点所在列 ,指向左侧相邻非零元素的指针 ,指向上方相邻非零元素的指针,即node(row,col,value,left,up) struct ListNode{ int row; //节点所在行 int col; //节点所在列 int value; //数据 ListNode* left;//指向左侧相邻非零元素的指针 ListNode* up; //指向上方相邻非零元素的指针 }; 双向十字链表：在十字链表的基础上增加双方向的指针，并有循环链表的特点 struct ListNode{ int row; //节点所在行 int col; //节点所在列 int value; //数据 ListNode* left;//指向左侧相邻非零元素的指针 ListNode* up; //指向上方相邻非零元素的指针 ListNode* right; //指向右侧相邻非零元素的指针 ListNode* down; //指向下方相邻非零元素的指针 }; ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 04_Array_and_Matrix "},"docs/DataStructure_and_Algorithms/Data_structure/05_Character_String.html":{"url":"docs/DataStructure_and_Algorithms/Data_structure/05_Character_String.html","title":"05_Character_String","keywords":"","body":" 字符串 定义 应用 字符串 定义 串(string)(或字符串）是由零个或多个字符组成的有限序列 串中字符的数目n称为串的长度 零个字符的串称为空串(null string) , 其长度为零 应用 模式匹配： 朴素模式匹配：经典的暴力匹配算法实现（BF算法） int BF(std::string S, std::string T, int pos) { // 检查pos是否合法，pos小于0或pos+T的长度超过S的长度都返回-1 if (pos S.size()) { return -1; // pos错误 } // 初始化i为搜索起始位置，j为T中正在匹配的字符位置 int i = pos; int j = 0; // 开始匹配，直到S或T遍历完 while (i = T.size()) { return i - T.size(); // 返回匹配成功的位置 } else // 如果没有完全匹配，返回-1表示匹配失败 { return -1; } } KMP: 利用“部分匹配表”（即 next 数组）来优化暴力匹配的过程，避免了不必要的字符比较,重点就在于next数组的创建 int index(std::string S, std::string T, int pos) { // 创建一个shared_ptr动态数组用于存储T的next数组 std::shared_ptr next(new int[T.size()], std::default_delete()); // 计算T的next数组 get_next(T, next); // 初始化i, j为匹配指针，i指向S，j指向T int i = 0; int j = 0; // 获取S和T的长度 int sl = S.size(); int tl = T.size(); // KMP匹配过程：若字符匹配成功（S[i] == T[j]），或者j == -1（表示跳过不匹配的字符），则继续比较下一个字符 while (i & next) { next[0] = -1; // next数组的第一个位置默认是-1 int k = -1; // k表示当前最长前后缀的长度 int j = 0; // j用于遍历T字符串的字符 // 计算T字符串的next数组，构建部分匹配表 while (j 注意next数组的意义以及和失败函数fail的区别: [!warning] next[j] = fail[j-1]+1 next[j]为在string[0,j-1]子字串的最大相等前后缀的长度加一，即跳转的位置 fail[j]为string[0,j]子字串的最大相等前后缀的长度。 对于next数组的优化：如果跳转位置的字符string[ next[j] ]和string[j]相同，即跳转后依旧匹配失败继续跳转，所以可以将next[j]=next[ next[j] ]。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 05_Character_String "},"docs/DataStructure_and_Algorithms/Data_structure/06_Tree.html":{"url":"docs/DataStructure_and_Algorithms/Data_structure/06_Tree.html","title":"06_Tree","keywords":"","body":" 树 定义 存储结构 顺序结构 链接存储 重要操作 应用 树 定义 一棵树是结点的一个有限集合T。 若T空，则称为空树。 若T非空，则： 有一个被称为根的结点，记 为root(T)； 其余结点被分成m(m >=0) 个 不相交的非空集合T1,T,…,Tm， 且T1, T2, …, Tm也都是树，其 称为root(T)的子树。(递归结构) 相关术语 度 ：一个结点的度指该结点的子结点的数目。其中一棵树的度为各结点的度的最大值。 叶结点：度为0的结点，即没有孩子节点的结点。 分支结点 ：度大于0的结点，即非叶结点 边：树中结点间的连线 层数/深度：根结点层数为0，其余结点的层数为其父结点的层数加1。 树的高度/深度：树中结点的最大层数 结点的高度：以该结点为根的子树的高度 对于二叉树 二叉树中第i层至多有2^i个结点，i>=0 高度为k的二叉树中至多有2^(k+1)-1 (k>=0)个结点 在n个结点构成的二叉树中，若叶结点即度为零的结点个数为n0 ，度为2的结点个数为n2 ，则有：n0 = n2 ＋1 特殊二叉树 完全二叉树： 除最下一层外，每一层都是满的（达到 最大结点数）， 最后一层结点从左至右出现 对所有结点，按层次顺序从1开始编号，仅编号最大的非叶结点可以没有右孩子，其余非叶结点都有两个子结点 知道总度数可以求出各个不同度的节点数，因为度为1只可以为0或者1 满二叉树（特殊的完全二叉树）： 叶节点都在最后一层 每个非叶节点都有两个子节点 存储结构 顺序结构 将树的结点存放在数组里 或者我们这需要关注各个结点的逻辑关系而非各个结点的数据时，可用int数组,例如：对于第i个结点，父节点为tree[i]，特殊的根节点的没有父节点所以对应的值为本身或者一个负数，这个用法可用于哈夫曼树或者并查集 根节点存放在tree[0]，则tree[i]对应的左右子树分别为tree[2*i+1],tree[2*i+2]，父节点为tree[(i-1)/2](i>=1) 根节点存放在tree[1]，则tree[i]对应的左右子树分别为tree[2*i],tree[2*i+1]父节点为tree[i/2]（i>0) 比较适用于满二叉树和完全二叉树，对于普通的树未使用的空间较多 template class Complete_BiTree { public: std::vector tree; }; 链接存储 利用指针用类似链表的方式连接各个结点 template class BiTree { public: T data;//数据 BiTree* parent;//父节点,可有可无 BiTree* leftChild;//左子树 BiTree* rightChild;//右子树 //左右子树是否为线索 bool leftTag; bool rightTag; BiTree() = default; }; 重要操作 树的遍历（以链接存储为例） 二叉树的遍历：按照一定次序访问二叉树中所有结点， 并且每个结点仅被访问一次的过程 前序遍历(类似图的深度优先搜索DFS)，利用栈可以实现非递归。 //这里function不一定返回空，具体视情况而立,默认为输出data void PreOrderTraverseTree(BiTree* tree,/*处理函数*/std::function address = [](T& e)->void {std::cout data); //遍历左子树 if (tree->leftChild && !tree->leftTag) { PreOrderTraverseTree(tree->leftChild, address); } //遍历右子树 if (tree->rightChild && !tree->rightTag) { PreOrderTraverseTree(tree->rightChild, address); } return; } 非递归 // 非递归前序遍历函数，使用栈模拟递归过程 void Non_Recursive_PreOrderTraverseTree(BiTree* tree,/*处理函数*/std::function address = [](T& e)->void {std::cout *> stack; BiTree* current = tree; // 当前结点指向树的根结点 // 当前结点非空或者栈非空时，继续遍历 while (current || !stack.empty()) { // 遍历到当前结点时 if(current) { // 处理当前结点（例如打印当前结点的数据） address(current->data); // 将当前结点压入栈中，以便后续回溯 stack.push_back(current); // 转向当前结点的左子树继续遍历 current = current->leftChild; } // 当前结点为空但栈不为空时，需要回溯 else { // 从栈中弹出一个结点，恢复到上一个结点 current = stack.back(); // 弹出栈顶结点 stack.pop_back(); // 转向当前结点的右子树继续遍历 current = current->rightChild; } } } 中序遍历，利用栈实现非递归。 void InOrderTraverseTree(BiTree* tree,/*处理函数*/std::function address = [](T& e)->void {std::cout leftChild && !tree->leftTag) { InOrderTraverseTree(tree->leftChild, address); } //根节点 address(tree->data); //遍历右子树 if (tree->rightChild && !tree->rightTag) { InOrderTraverseTree(tree->rightChild, address); } return; } 非递归 // 非递归中序遍历函数，使用栈模拟递归过程 void Non_Recursive_InOrderTraverseTree(BiTree* tree, /*处理函数*/std::function address = [](T& e)->void {std::cout *> stack; BiTree* current = tree; // 当前结点指向树的根结点 // 当前结点非空或者栈非空时，继续遍历 while (current || !stack.empty()) { // 遍历到当前结点的左子树 if (current) { // 将当前结点压入栈中，以便后续回溯 stack.push_back(current); // 转向左子树继续遍历 current = current->leftChild; } // 当前结点为空但栈不为空时，需要回溯 else if (!stack.empty()) { // 从栈中弹出一个结点，恢复到上一个结点 current = stack.back(); // 弹出栈顶结点 stack.pop_back(); // 处理当前结点（例如打印当前结点的数据） address(current->data); // 转向当前结点的右子树继续遍历 current = current->rightChild; } } } 后序遍历 void PostOrderTraverseTree(BiTree* tree,/*处理函数*/std::function address = [](T& e)->void {std::cout leftChild && !tree->leftTag) { InOrderTraverseTree(tree->leftChild, address); } //遍历右子树 if (tree->rightChild && !tree->rightTag) { InOrderTraverseTree(tree->rightChild, address); } //根节点 address(tree->data); return; } 非递归 void Non_Recursive_PostOrderTraverseTree(BiTree* tree, /*处理函数*/ std::function address = [](T& e)->void { std::cout *> stack; BiTree* current = tree; // 当前结点指向树的根结点 BiTree* lastVisite = nullptr; // 记录上一个被访问的结点，用于判断右子树是否已访问 // 当前结点非空或者栈非空时，继续遍历 while (current || !stack.empty()) { // 遍历到当前结点的左子树 if (current) { stack.push_back(current); // 将当前结点压入栈中 current = current->leftChild; // 转向左子树 } else { // 当前结点为空，回溯到栈顶结点 BiTree* top = stack.back(); // 如果右子树存在且未访问，则遍历右子树 if (top->rightChild && lastVisite != top->rightChild) { current = top->rightChild; // 转向右子树 } else { // 右子树为空或者已访问 address(top->data); // 处理当前结点 lastVisite = top; // 更新上一个访问的结点 stack.pop_back(); // 弹出栈顶结点 } } } } - 层次遍历（类似图的广度优先搜索BFS） ```cpp void LevelOrderTraverseTree(BiTree* tree,/*处理函数*/std::function address = [](T& e)->void {std::cout *> trees; trees.push(tree); while (!trees.empty()) { BiTree* p = trees.front(); trees.pop(); address(p->data); //左子树 if (p->leftChild && !p->leftTag) { trees.push(p->leftChild); } //遍历右子树 if (p->rightChild && !p->rightTag) { trees.push(p->rightChild); } } return; } ``` 树和二叉树的转换（树使用兄弟儿子表示法） 应用 先根序列个数为n的不同二叉树的个数为卡特兰数 线索二叉树：利用节点的空指针指向结点的某个序列的前驱和后继 哈夫曼树 构造 一类带权路径长度最短的树。（用于不等长最优编码等） 在哈夫曼树中，权值越大的结点离根结点越近。 依次找到最小的两个节点组成一棵树直到所有节点都有根节点 编码： 在构造哈夫曼树之后，求哈夫曼编码的主要思想是：依次以叶子为出发点，向上回溯至根结点为止。 回溯时走左分支则生成代码 0, 走右分支则生成代码 l 译码： 初始化：从根节点开始，遍历二进制编码字符串。 遍历路径： 每个'0'表示向左子树移动，'1'表示向右子树移动。 每当到达叶子节点，就记录该节点编号即译出一个字符，并重新从根节点开始译码。 结束判断：若最终到达叶子节点，返回所有编号；否则该串无法译码为非法序列。 并查集 一种用于管理元素所属集合的数据结构，实现为一个森林 其中每棵树表示一个集合，树中的节点表示对应集合中的元素。 优化搜索 压缩路径 查询过程中经过的每个元素都属于该集合，我们可以将其直接连到根节点以加快后续查询。 size_t find(size_t x) { return pa[x] == x ? x : pa[x]=find(pa[x]); } 小树并入大树(按秩合并) // 合并两个集合，x 和 y 所在的集合进行合并，按秩合并策略 size_t unite(size_t x, size_t y) { // 找到 x 和 y 所在集合的根节点 x = find(x); y = find(y); // 如果 x 和 y 已经在同一个集合中，无需合并，直接返回 if (x == y) return; // 按秩合并，始终将小树合并到大树上 // 如果 x 的树小于 y 的树，将 x 和 y 交换，确保 x 是较大的树的根 if (size[x] 集合数：如果一个节点的根指向自己，则为整棵树的根即一个集合。 二叉查找树 AVL树 红黑树 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 06_Tree "},"docs/DataStructure_and_Algorithms/Data_structure/07_Graph.html":{"url":"docs/DataStructure_and_Algorithms/Data_structure/07_Graph.html","title":"07_Graph","keywords":"","body":" 图 定义 存储结构 应用(重要操作) 图 定义 图(Graph) G由两个集合V和E组成，记为G=(V,E) , 其中V是顶点的有穷非空集合， E是V中顶点偶对的有穷集合，这些顶点偶对称为边。 存储结构 边存储 将各个点的关系利用边存起来 struct Edge { //存储边节点的编号 //u->v int u; int v; //加入权值 int weight; Edge() = default; Edge(int _u, int _v,int weight=1) :u(_u), v(_v),weight(weight){ } }; 邻接表（稀疏图） 用顶点表将各个邻接点利用链接结构存放起来 //边结点 //边链表中边结点包括邻接点域(adjvex)、数据域(info) 和链域(nextarc) 三部分 //邻接点域指示与顶点V; 邻接的点在图中的位置；数据域存储和边相关的信息， 如权值等；链域指示与顶点v邻接的下一条边的结点。 template//默认为int class ArcNode { public: //该边所指向的顶点位置，如果为有向边则为弧头 int adjvex; //指向下一条边的指针 std::shared_ptr> nextarc; //边信息，如权值,默认无信息 T info; ArcNode() = default; ArcNode(int vex) :adjvex(vex),info(1),nextarc(nullptr){ } ArcNode(int vex,T info) :adjvex(vex),info(info), nextarc(nullptr) { } }; template class Adj_List { public: //表头结点表，此vector.size()即顶点数,所以不需要记录顶点数 std::vector> vertices; //记录边数 int arcnum; //是否为有向图 bool is_direct; }; 对于链式结构的的邻接表，可以使用变为使用数组存放边的前向星 // 边类定义，包含两个成员变量：目标节点v和权重w class edge { public: int v; // 目标节点 int w; // 边的权重 // 构造函数，初始化目标节点和边的权重 edge(int _v, int _w) :v(_v), w(_w){ } }; // 存储图的邻接表(前向星)，vextices[i]表示节点i的所有边 vector> vextices; 邻接矩阵（稠密图） 利用矩阵(即二维数组）将各个点是否存在边的信息存放起来 //使用一个二维数组 adj 来存边，其中 adj[u][v] 为 1 表示存在 u 到 v 的边，为 0 表示不存在。 //如果是带边权的图，可以在 adj[u][v] 中存储 u 到 v 的边的边权。 //默认顶点到自身没有边 //并且二维数组难以改变结构所以不考虑增加和删除节点但是可以增删边，并且二维数组空间大不适用于稀疏图 //其实无向图为对称矩阵可以压缩为一维数组存放，但是实现逻辑相似不考虑分离 //小技巧：对于有向无向图图，并且规定没有弧为0，有弧为1，则矩阵A^n[i][j]的值表示从顶点i到顶点j中路径长度为n的数目 class Adj_Matrix { public: std::vector> graph; //标志是否为有向图 bool is_direct; Adj_Matrix() = default; //顶点数量number,依旧从零开始,当weight默认时表示无权图 Adj_Matrix(int number,bool direct=false, int weight = INT_MAX):is_direct(direct) { graph.resize(number, std::vector(number,weight)); } }; 对于邻接表和邻接矩阵的比较 首先是，邻接表适用于稀疏图，邻接矩阵适用于稠密图 判断两个顶点是否存在边或者查询修改边的信息，邻接表O(n)（n表示该点的出度），邻接矩阵O(1)，所以频繁查询和修改边的信息则邻接矩阵更合适 对于需要增删顶点则邻接表更适合 应用(重要操作) 都以邻接矩阵为例 DFS:深度优先搜索，非递归时使用栈 //深度优先搜索（DFS）算法,并对节点进行处理,vis保存是否访问 void dfs(int u, std::vector& vis, const Adj_Matrix& adj, std::function address = [](int& u)->void {std::cout =vis.size()||vis[u]) { return; } //标记已访问 vis[u] = true; address(u); //递归搜索 for (int i = 0; i 非递归 //深度优先搜索（DFS）算法的非递归形式，类似于广度优先，但这里使用栈 void dfs_non_recursive(int start, std::vector& vis, const Adj_Matrix& adj, std::function address = [](int& u)->void {std::cout = vis.size())return; std::vector q;//存放当前连通分支节点 q.push_back(start);//将起始节点入栈 vis[start] = true;// 标记为已访问 //栈不为空，即当前连通分支还有未访问的节点 while (!q.empty()) { int u = q.back(); // 获取栈顶的节点 q.pop_back(); // 出栈 address(u); // 处理当前节点 // 遍历当前顶点，找到所有邻接并且未访问的节点加入队列 for (int i = 0; i BFS:广度优先搜索 非递归利用队列（类似树的层次遍历） 可用于单源无权（权值为1）最短路 //广度优先搜索（BFS）算法（非递归）,并对节点进行处理,vis保存是否访问 void bfs(int start, std::vector& vis, const Adj_Matrix& adj, std::function address = [](int& u)->void {std::cout = vis.size())return; std::queue q;//存放当前连通分支节点，并要着start节点一圈圈增加 vis[start] = true;//标记初始点访问 q.push(start);//将起始节点入队 //队列不为空，即当前连通分支还有为访问的节点 while (!q.empty()) { int u = q.front(); // 获取队列前端的节点 q.pop(); // 出队 address(u); // 处理当前节点 // 遍历当前顶点，找到所有邻接并且未访问的节点加入队列 for (int i=0;i 拓扑序列：AOV网是一个有向无环图，可以用于证明图是否有环 选择一个入度为0的顶点并输出 删除该顶点及该顶点引出的所有边 执行①②，直至所有顶点已输出，或图中剩余顶点 入度均不为0（说明存在环，无法继续拓扑排序） 对于任何无环的AOV网，其顶点均可排成拓扑序列， 其拓扑序列未必唯一 拓展：如果图存在拓扑序列，则DFS可以输出拓扑序的逆序 std::vector TopologicalSort(const Adj_Matrix& adj) { // 如果是无向图，无法进行拓扑排序 if (!adj.is_direct) { std::cerr Topo; // 存储拓扑排序结果 std::queue zero_in_degree; // 存储入度为0的节点 // 存放各个节点的入度 std::vector indegree(number, 0); // 计算每个节点的入度 for (int u = 0; u v，v的入度增加 if (adj.graph[u][v] != INT_MAX) { indegree[v]++; } } } // 将入度为0的节点放入队列 for (int i = 0; i i，i的入度减一 if (adj.graph[u][i] != INT_MAX) { indegree[i]--; // 如果i的入度为0，加入队列 if (indegree[i] == 0) { zero_in_degree.push(i); } } } } // 检查是否存在环：如果拓扑排序结果的节点数不等于图的节点数，说明图中有环 if (Topo.size() != number) { std::cerr 关键路径：完成整个工程所需的最短时间取决于从源点到汇点的最长路径长度 关键活动：活动的最早开始时间等于活动 A 的最迟开始时间， 即l(i)＝e(i),也是不可以拖延的活动 关键路径：由关键活动组成的路径，亦即源点到汇点的最长路径，可能不止一条 对AOE网求各顶点vj的最早发生时间ve(j) 求各顶点vj的最迟发生时间vl(j)； 求出各活动ai的最早开始时间e(i)和 最迟开始时间l(i)，若e(i)=l(i)，则ai是关键活动 具体算法 求出拓扑排序，若网中有环则终止算法，按拓扑序求出各顶点的最早发生时间ve 按逆拓扑序求各顶点的最迟发生时间vl 根据ve和vl的值，求各活动的最早开始时间e与最迟开始时间l，若e=l，则对应活动是关键活动，其中最晚开始时间和最早开始时间的差值为活动的时间余量。 因为拓扑序列不唯一，所以关键路径也不唯一。 //关键路径不唯一 std::vector CriticalPath(const Adj_Matrix& adj) { // 检查是否为无向图 if (!adj.is_direct) { std::cerr Topo = TopologicalSort(adj); // 如果拓扑排序为空，表示图中存在环，无法进行关键路径计算 if (Topo.empty()) { std::cout VE(number, 0); // 计算每个节点的 VE for (int u = 0; u v，更新 v 的 VE if (adj.graph[u][v] != INT_MAX) { VE[v] = std::max(VE[v], VE[u] + adj.graph[u][v]); edge_num++; // 计算边的数量 } } } // 初始化每个节点的最晚发生时间（VL），结束点的 VL 为 VE[number - 1] std::vector VL(number, VE[number - 1]); // 逆拓扑排序计算每个节点的 VL for (auto it = Topo.rbegin(); it != Topo.rend(); it++) { int u = *it; for (int i = 0; i critical_adjpath; // 遍历拓扑排序中的每个节点，检查哪些弧是关键路径 for (int u = 0; u v，计算其最早开始时间 ET 和最晚开始时间 LT if (adj.graph[u][v] != INT_MAX) { int ET = VE[u]; // 最早开始时间 int LT = VL[v] - adj.graph[u][v]; // 最晚开始时间 // 如果 ET == LT，则该弧是关键路径 if (ET == LT) { // 如果 critical_adjpath 为空，加入首尾节点 if (critical_adjpath.empty()) { critical_adjpath.push_back(u); critical_adjpath.push_back(v); } // 如果首尾节点相接，直接添加尾节点 else if (critical_adjpath.back() == u) { critical_adjpath.push_back(v); } } } } } // 输出项目的最早完成时间 std::cout 最短路径 无权图的单源最短路径问题：BFS BFS过程中，当访问某个顶点时，就确定了该点与源点的最 短距离 通过BFS，从源点开始由近及远求各顶点的最短路径v // 找到无权最短路径，图中所有边权值为1，求点v到其他各个点的最短路径和最短路径长度 // path[i] 记录从 v 到 i 的最短路径上顶点 i 的前驱结点 // dist[i] 记录从 v 到 i 的最短路径长度 void ShortestPath(const Adj_Matrix& adj, int v, std::vector& dist, std::vector& path) { // dist 和 path 的初始化由调用方完成 int number = dist.size(); // 获取图中顶点的数量 // 创建一个队列用于广度优先搜索（BFS） std::queue Q; Q.push(v); // 将起点 v 入队 // 起点到自身的距离为0 dist[v] = 0; // 求 v 到其他各个顶点的最短路径，类似于图的 BFS while (!Q.empty()) { // 处理队头的顶点 u int u = Q.front(); Q.pop(); // 遍历当前点 u 的所有边（邻接节点） for (int i = 0; i i（即图中有连接） if (adj.graph[u][i] != INT_MAX) { int k = i; // 邻接点 k // dist[k] == -1 表示未访问过该节点 if (dist[k] == -1) { // 将未访问的邻接点 k 入队 Q.push(k); // 更新 dist[k] 为 u 到 k 的距离，等于 u 到起点的距离加 1 dist[k] = dist[u] + 1; // 更新 k 的前驱节点为 u path[k] = u; } } } } } 正权图的单源最短路径问题：Dijkstra算法 找到各个局部最优路（任意最短路的前缀，也是一条最短路） 初始化起点到其他点距离 找局部最优路 从局部最优路更新到其他点的距离 重复直到所有点的最优路找到 可以利用优先队列（斐波那契堆）优化找局部最优路的步骤 //利用优先队列维护最短路长度最小的结点，适用于稀疏图 void Dijkstra_ShortestPath_optimize(const Adj_Matrix& adj, int v, std::vector& vis, std::vector& dist, std::vector& path) { //创建优先队列，利用pair分别存放距离，节点,默认T有greater std::priority_queue, std::vector>, std::greater>> pq; //初始化 dist[v] = 0; //放入队列 pq.push({ 0,v }); //直到队列为空则完成 while (!pq.empty()) { //取当前最短路长度最小的结点 std::pair node = pq.top(); pq.pop(); //如果此点已经找到最小路径即局部最优路 int u = node.second; if (vis[u])continue; ////如果有已经更新的最短路径,放弃这个记录 //if (node.first > dist[u])continue; //此操作和上面判断相同 //标记 vis[u] = true; //更新从此点出发的其他点最短路径 for(int i=0;i 正权图的多源最短路径问题 多次Dijkstra算法 Floyd算法（多用于邻接矩阵） 算法通过三重循环来更新最短路径。外层循环通过引入一个中间点 k，判断是否可以通过中间点 k 来缩短从 i 到 j 的路径。 如果通过 k 的路径更短，则更新 dist[i][j]，并且更新前驱节点 path[i][j] 为通过 k 到达 j 的前驱节点。 void Floyd_ShortestPath(const Adj_Matrix& adj) { // 将从Vi到Vj的最短路径长度初始化为邻接矩阵中的值 std::vector> dist, path; // 初始化dist和path，大小与邻接矩阵相同 dist.resize(adj.graph.size(), std::vector(adj.graph.size(), 0)); path.resize(adj.graph.size(), std::vector(adj.graph.size(), -1)); // 初始化dist和path for (int i = 0; i 最小支撑树：边权之和最小的支撑树称为G的最小支撑树 Prim算法（加点法） 选择任一点u做为起点，放入集合S，即令S={u}(u属于V)； 找最小跨集合边(u, v) ，即端点分别属于集合S和V-S且权值 最小的边，将该边加入最小支撑树，并将点v放入S； 执行②，直至S=V // 普里姆算法优化，使用优先队列 Adj_Matrix MiniSpanTree_Prim(const Adj_Matrix& adj, int u = 0 /*起始点*/) { // 非连通图，返回空图 if (Connected_Component(adj) != 1) { return Adj_Matrix(0); } int n = adj.graph.size(); // 图的顶点数 Adj_Matrix MiniSpanTree(n, adj.is_direct); // 最小生成树 // 记录顶点是否已经加入生成树 std::vector vis(n, false); // 使用优先队列（最小堆）保存未加入生成树的点和其对应的最小边权值 // 队列中存储的是 (边权值, 顶点) 的 pair std::priority_queue, std::vector>, std::greater<>> pq; // 初始化：从起始点u开始，加入队列，权值为0 pq.push({0, u}); // 选择其他n-1个顶点，生成n-1条边 while (!pq.empty()) { // 取出当前权值最小的边 int current_weight = pq.top().first; int u0 = pq.top().second; pq.pop(); // 如果顶点u0已经加入生成树，则跳过 if (vis[u0]) continue; // 标记u0为已访问 vis[u0] = true; // 更新最小生成树的边 if (u0 != u) { // 排除起始点 int v0 = pq.top().second; // 顶点u0的前驱 MiniSpanTree.graph[u0][v0] = current_weight; // 无向图则增加对称边 if (!MiniSpanTree.is_direct) { MiniSpanTree.graph[v0][u0] = current_weight; } } // 更新与u0的相邻节点的最小边，并加入优先队列 for (int i = 0; i Kruskal算法（逐边加入）所以不针对邻接矩阵为例 在G中选择权值最小的边，并将此边从G中删除 若该边加入T后不产生环（即此边的两个端点在T的不同连 通分量中），则将此边加入T中，从而使T减少一个连通分 量，否则本步骤无操作，对于是否产生环可以利用并查集 重复①②直至T中仅剩一个连通分量 //克鲁斯卡尔 (Kruskal)算法，可称为“加边法”，适用于稀疏图 //每次选出权值最小并且无法使现有的树形成环的边加入最小支撑树,返回一个图 std::vector MiniSpanTree_Kruskal(std::vector graph,int number) { //非连通图 if (Connected_Component(graph,number) != 1) { return{}; } std::vector MiniSpanTree; //在Edge增加了weight成员存储权值，可以直接用sort排序 std::sort(graph.begin(), graph.end(), [](const Edge& a, const Edge& b)->bool {return a.weight Vexset; Vexset.resize(number,0); //初始化,表示各顶点自成一个连通分址 for (int i = 0; i ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 07_Graph "},"docs/DataStructure_and_Algorithms/Data_structure/08_Sort.html":{"url":"docs/DataStructure_and_Algorithms/Data_structure/08_Sort.html","title":"08_Sort","keywords":"","body":" 排序 定义 内排序 插入排序 交换排序 快速排序 选择排序 归并排序 基于关键词比较的排序算法分析 平方阶排序算法及改进算法 线性对数阶排序算法 分布排序 外排序 排序 定义 [!important] 排序(Sorting)是按关键字的非递减或非递增顺序对一组记录重新进行排列的操作 排序的稳定性：关键字相同的记录排序前后的相对位置不变 内排序 内部排序的过程是一个逐步扩大记录的有序序列长度的过程。在排序的过程中，可以将排序记录区分为两个区域：有序序列区和无序序列区。 使有序区中记录的数目增加一个或几个的操作称为一趟排序。 插入排序 每一趟将一个待排序的记录，按其关键字的大小插入到已经排好序的一组记录的适当位置上，直到所有待排序记录全部插入为止 插入排序 直接插入排序：将一条记录插入到已排好序的有序表中，从而得到一个新的、 记录数量增1的有序表。 //直接插人排序，O(n^2) //稳定排序,更适合于初始记录基本有序（正序）的情况 //也适用千链式存储结构，只是在单链表上无需移动记录，只需修改相应的指针 template void Straight_Insertion_Sort(T a[], int n) { //对顺序表L做直接插入排序 //数组从0开始，第零个元素已经有序,所以从1开始排序 for (int i = 1; i = 0 && key 折半插入排序：在直接插入排序的基础上优化\"查找\"即找到插入位置，，这个 “查找＂ 操作可利用 “折半查找” 来实现 //折半插人排序，O(n^2) //在已经排序的有序数组里采用二分查找，提高找到插入位置的效率 //稳定排序,适合初始记录无序、n较大时的情况。 //只能用于顺序结构 template void Binary_Insertion_Sort(T a[], int n) { //对顺序表L做折半插入排序 for (int i = 1; i = high + 1; j--)a[j + 1] = a[j]; //插入 a[high + 1] = key; } } 希尔排序（缩小增量排序） 采用分组插入的方法。先将整个待排序记录序列分割成几组，从而减少参与直接插入排序的数据量，对每组分别进行直接插入排序，然后增加每组的数据量，重新分组。 这样 当经过几次分组排序后，整个序列中的记录“基本有序” 时，再对全体记录进行一次直接插入排序。 希尔对记录的分组，不是简单地 ”逐段分割＂，而是将相隔某个 “增量” 的记录分成一组。 具体步骤 将待排序序列分为若干子序列（每个子序列的元素在原始数组中间距相同 对这些子序列进行插入排序 减小每个子序列中元素之间的间距，重复上述过程直至间距减少为1。 //记录跳跃式地移动导致排序方法是不稳定的，只能用于顺序结构 //n越大时，效果越明显。所以适合初始记录无序、n较大时的情况 template void ShellSort(T a[], int n) { //初始化间隔 h，使用 Knuth 序列计算使其小于数组长度的最大值 int h = 1; //生成最大增量 while (h = 1) { //对每一个间隔为 h 的子数组进行插入排序 for (int i = h; i = h && a[i] 可以提前生成增量序列 template void ShellSort_C(T a[], int n,int t,int dk[]) { //dk[]存放着生成好的增量序列 //有多种增量序列 //希尔增量序列（2^k - 1） //Hibbard增量序列（1, 3, 7, 15, ...） //Sedgewick增量序列（1, 5, 19, 41, ...） for (int i = 0; i void Shellinsert_C(T a[], int n,int dk) { int d = dk;//此次增量 //插入排序 for (int i = d; i = 0 && key 交换排序 两两比较待排序记录的关键字，一旦发现两个记录不满足次序要求 时则进行交换，直到整个序列全部满足要求为止。 冒泡排序 通过两两比较相邻记录的关键字， 如果发生逆序，则进行交换，从而使关键字小的记录如气泡一般逐渐往上 ＂漂浮＂ （左移），或者使关键字大的记录如石块一样逐渐向下 ＂坠落” （右移）。 //冒泡排序，O(n^2),当数组为完全逆序时最坏需要比较n*(n-1)/2次 //两两比较相邻记录的关键字，如果发生逆序，则进行交换 //稳定排序,可用于链式存储结构 //当初始记录无序，n较大时 template void Bubble_Sort(T a[], int n) { //设置交换标识,开始时假设有交换 bool flag = true; //只要一趟起泡排序有交换就继续 while (flag) { //假设无交换 flag = false; //遍历找逆序 for (int i = 0; i a[i + 1]) { std::swap(a[i], a[i + 1]); //重置标识 flag = true; } } } } 改进 //一趟比较中，当比较结束，发现从某个位置t开始不再交换，则说明t及以后的记录有序 //从而下一趟比较进行到t即可 template void Bubble_Sort_modify(T a[], int n) { if (n 双向冒泡 //双向冒泡排序，上浮和下沉交替进行 template void Double_Bubble_Sort(T* a, int n) { // 上浮和下沉的区域 int left = 0; int right = n - 1; bool swapped = true; while (left left; i--) { if (a[i] 快速排序 由冒泡排序改进而得的，能通过两个（不相邻） 记录的一次交换消除多个逆序，大大加快排序的速度。 平均情况下，快速排序的时间复杂度为O(n*log2n)。 快速排序是递归的，执行时需要有一个栈来存放相应的数据。最大递归调用次数与递归树的 深度一致，所以最好情况下的空间复杂度为O(log2n），最坏情况下为O(n)。 具体步骤： 待排序的n个记录中任取一个记录（通常取第一个记录）作为枢轴（或支点），又称为基准，经过一趟排序后，将枢轴放置在排序好的的位置，即左边比基准小，右边比基准大，结果将待排序记录分成两个子表，分别 对左、右子表重复上述过程，直至每一子表只有一个记录时 对于快速排序有多个版本，其中取基准的办法也有多种，单趟排序也有不同。 严蔚敏《数据结构》标准分割函数，取待排序的表中第一个记录作为基准，但这样的话，如果待排序的表基本有序或者已经有序，会导致快速排序进入”陷阱“，重新使得记录无序化，时间复杂度变为最坏O(n^2) //严蔚敏《数据结构》标准分割函数 template void Quick_Sort_C(T a[], int left, int right) { int low = left; int high = right; //退出递归 if (low >= high)return; //这里选择第一个作为脊椎 T pivot = a[low]; //类似左右指针 while (low = pivot) --high; //交换 a[low] = a[high]; //左指针右移直到大于基准 while (low 为了避免快排进入\"陷阱\"，对取基准进行改进 选择基准，一般选第一个或者最后一个，但是如果数组本来有序会导致效率低 可以三数取中（即选取第一个、最后一个以及中间的元素中的中位数）或者随机取数，以及中位数中的中位数 下面为取基准的方法，可以优化快速排序 三数取中 int getmid(T array[], int left, int right) { //获取中间值下标 int mid = left + (right - left) / 2; //当leftright if (array[left] > array[right]) { return left; } else { return right; } } } else { //如果mid>right if (array[mid] > array[right]) { return mid; } else { //left>right if (array[left] > array[right]) { return left; } else { return right; } } } } 中位数中的中位数 算法的流程如下： 将整个序列划分为n/5组，每组元素数不超过 5 个； 寻找每组元素的中位数（因为元素个数较少，可以直接使用 插入排序 等算法）。 找出这n/5组元素中位数中的中位数。将该元素作为前述算法中每次划分时的分界值即可。 不考虑实现 随机取数法 //随机法 int getrandom(T array[], int left, int right) { std::random_device rd; // 获取随机设备 std::mt19937 gen(rd()); // 使用 Mersenne Twister 随机数生成器 std::uniform_int_distribution<> size_dis(left, right); return size_dis; } 处理完基准问题，这里给出快排的模板 //进行多趟排序相同一起实现,递归实现 void Sort(T array[], int left, int right) { //退出递归条件 if (left >= right)return; int idxkey = Partion(array, left, right); //继续排序左区间 Sort(array, left, idxkey - 1); //排序右区间 Sort(array, idxkey + 1, right); } //进行多趟排序相同一起实现,非递归实现 //一个栈来保存需要处理的数组区间, //如果某个子数组的元素数量少于等于1，则不需要入栈处理 void SortNoR(T a[], int left, int right) { //工作栈存放左右边界 std::vector> stack; //存放开始左右边界 stack.push_back({ left,right }); //当栈不空 while (!stack.empty()) { //取出左右边界 auto p = stack.back(); stack.pop_back(); ////使用一次单趟的快排得到第一次的基准值 int key = Partion(a, left, right); //将基准值的左右边界入栈 if (key + 1 其中Partion有多个版本，利用多态实现。 前后指针法，现在最常用的方法。 但是在数组中间有大量相同数时效率低下，详见数组中的第K个最大元素 //可以先三数取中交换后，再选取数组的第一个元素作为基准数key template class FroandBack :public QuickSort { //返回左右区间的分界处，此处区间为左右闭区间即[left,right] int Partion(T array[], int left, int right) { int prev = left; int cur = left + 1; //三数取中选定基准后与第一个数交换 int key = QuickSort::getmid(array, left, right); std::swap(array[key], array[left]); int idxkey = left;//当前排序基准位置 while (cur 霍尔快排，最经典的快速排序，多用于教材。 template class Hoare :public QuickSort { int Partion(T array[], int left, int right) { //用三数取中法得到key的位置 int key = QuickSort::getmid(array, left, right); std::swap(array[key], array[left]); //当前排序基准位置 int idxkey = left; while (left = array[idxkey]) --right; //左边右移找较大值 while (left 挖坑法，最容易理解的办法 template class Hole : public QuickSort { int Partion(T* array, int left, int right)//类似于Hoare { //用三数取中法得到key的位置 int idxkey = QuickSort::getmid(array, left, right); std::swap(array[idxkey], array[left]); T key = array[left];//储存基准值 int hole = left;//第一个坑 while (left = key) { --right; } array[hole] = array[right];//填坑 hole = right;//新坑 //左边右移找较大值 while (left 快速排序的改进 三路划分法: 为了解决当数组中存在大量重复元素时，传统的快速排序算法会导致不必要的比较和交换操作数组中存在大量重复元素问题 小的甩到左边，大的甩到右边，与 key 值相等的值则推到中间 最后记录表变为[ begin , left-1 ] [ left , right ] [ right + 1 , end ] template void Quick_Sort_Threeroad(T a[], const int n) { if (n 小区间改造法： 当子区间的大小足够小时，可以考虑使用插入排序来代替递归调用提高效率，并通过设置一个阈值来决定是否使用插入排序 //Insertion_Sort为插入排序 template void Quick_Insert_Sort(T *a, int n) { if (n 10) { Quick_Insert_Sort(a + right, n - right); } else { Insertion_Sort(a + right, n - right); } if (left > 10) { Quick_Sort_Threeroad(a, left); } else { Insertion_Sort(a, left); } return; } 内省排序： 快速排序和 堆排序 的结合 内省排序将快速排序的最大递归深度限制为[log2_n]，超过限制时就转换为堆排序。 这样既保留了快速排序内存访问的局部性，又可以防止快速排序在某些情况下性能退化为 O(n^2)， 快速排序在某些情况下性能退化为 O(n^2)又称为快速排序落入陷阱 //Heap_Sort为堆排序。 template void Introspective_Sort(T* a, int n,int deep) { if (n = 2 * log2(n)) { Heap_Sort(a,n); return; } //类似三路划分 //随机法取基准 const T pivot = a[rand() % n]; // i：当前操作的元素下标 int i = 0; // arr[0, left)：存储小于 pivot 的元素 int left = 0; // arr[right, len)：存储大于 pivot 的元素 int right = n; // 完成一趟三路快排，将序列分为： // 小于 pivot 的元素 | 等于 pivot 的元素 | 大于 pivot 的元素 while (i 选择排序 每一趟从待排序的记录中选出关键字最小的记录，按顺序放在已排 序的记录序列的最后，直到全部排完为止 由于 swap（交换两个元素）操作的存在，选择排序是一种不稳定的排序算法。 简单选择排序（直接选择排序），每趟排序在未排序的记录中找到关键词最小的记录加入有序子表里。 //简单选择排序 (SimpleSelection Sort)也称作直接选择排序。O(n^2) //移动记录次数较少，当每一记录占用的空间较多时，此方法比直接插入排序快。 template void Simple_Selection_Sort(T* a, int n) { //找到n-1次最小值就已经有序了， for (int i = 0; i 堆排序： 利用 二叉堆 这种数据结构所设计的一种排序算法 堆排序的本质是建立在堆上的选择排序 或者说是将待排序的记录a[l..n]看成是一棵完全二叉树的顺序存储结构 具体步骤： 调整数组变为大根堆，自下而上建堆 依次取最大值并重新调整数组为大根堆 ```cpp //首先建立大顶堆,小数往下筛,大数往上浮 template void sift_down(T* a, int start, int end) { //父节点 int parent = start; //子节点，因为从零开始，所以子节点为parent*2+1，parent*2+2（完全二叉树性质 int child = parent * 2 + 1; //存在child,即子节点编号在区间[start,end]内（完全二叉树性质） while (child } //这里为堆排序完整实现 template void Heap_Sort(T* a, int n) { if (n //从最后一个节点的父节点完成堆化，因为数组从零开始，所以最后一个节点为n-1-1，即自下而上建堆。 for (int i = (n - 1 - 1) / 2; i >= 0; i--) { sift_down(a, i, n - 1); } //建完堆 //将第一个元素和已排序的前一位交换，接着重新调整， //将大数往上，小数往下，即重新找到下一个要排序的大数 for (int i = n - 1; i > 0; i--) { //i为要交换的位置，即第n-i大的数 std::swap(a[0], a[i]); //重新调整，但是结束区间不包括已排序值 sift_down(a, 0, i - 1); } } ### 归并排序 两个或两个以上的有序表合并成一个有序表 归并排序的时间复杂度为O(nlog2n)，稳定排序。 具体步骤： > 假设初始序列含有n个记录，则可看成是 n个有序的子序列 > > 每个子序列的长度为1,然后两两归并，得到`[n/2]`个长度为2或1的有序子序列； > > 如此重复，直至得到一个长度为n 的有序序列为止 ```cpp //归并排序最核心的部分是合并（merge）过程： //将两个有序的数组 a[i] 和 b[j] 合并为一个有序数组 c[k]。 template void merge(const T* a, size_t alen, const T* b, size_t blen, T* c) { //三个数组的工作指针 size_t i = 0, j = 0, k = 0; //遍历比较 while (i void merge(const T* a, const T* a_end, const T* b, const T* b_end, T* c) { //三个数组的工作指针 size_t i = 0, j = 0, k = 0; int alen = a_end - a; int blen = b_end - b; //遍历比较 while (i void Merge_Sort(T* a, int l, int r) { //当数组长度为 1 时，该数组就已经是有序的，不用再分解 if (r - l > 1); //分治左右区间 Merge_Sort(a, l, mid); Merge_Sort(a, mid , r); //创建临时数组 T* temp = new T[r - l]; //合并 merge(a + l, a + mid, a + mid, a + r, temp); //返回 for (int i = 0; i 非递归 //倍增法实现非递归的归并排序 template void Merge_sort(T* a, size_t n) { //临时数组 T* temp = new T[n]; //seg表示要合并的段的大小，每次翻倍 for (size_t seg = 1; seg 基于关键词比较的排序算法分析 以上的排序算法是建立在记录关键词比较的基础上，即根据关键词比较结果，变换记录位置实现排序。 平方阶排序算法及改进算法 最坏情况下时间复杂度为平方阶的排序算法称为简单排序算法，包括直接插入、冒泡、交替冒泡、直接选择、对半插入 希尔(Shell)等排序算法 简单排序算法都是通过两层循环实现的。 线性对数阶排序算法 合并排序、快速排序和堆排序算法 结论：基于关键词比较的排序算法下界：O(nlog2n)。即任何基于关键词比较的排序算法在最坏情况下的比较次数都大于等于nlog2n. 分布排序 非基于关键词比较的排序算法，而是基于分配、收集的排序算法，其中分配排序的基本思想为：排序过程无须比较关键字，而是通过\"分配\"和\"收集\"过程来实现排序 时间复杂度可达到线性阶：O(n) 基数排序 元素的关键词由多个域构成，即K=Kd,Kd-1,…,K2,K1 若每个域为英文字母，则关键词即英文单词 若每个域为1位十进制数字(0~9),则关键词即d位十进制数 自K1至Kd（自低位向高位），依次以各域为序进行稳定排序 计数排序 //计数排序,只适用于元素集中于一个范围的排序 template void Counting_Sort(T* elem,int n) { //求最大值和最小值 T max = elem[0]; T min = elem[0]; for (int i = 0; i max)max = elem[i]; if (elem[i] = 0; i--) { //如果有重复元素则位置减一 int idx = --count_a[elem[i] - min]; sorted_a[idx] = elem[i]; } //返回 for (int i = 0; i 桶排序 template void Bucket_Sort(T* elem, int n) { if (n max)max = elem[i]; if (elem[i] > buckets(cnt); //放入桶中 for (int i = 0; i 外排序 排序过程既需要内存储器又需要外存储器 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 08_Sort "},"docs/DataStructure_and_Algorithms/Data_structure/09_Search.html":{"url":"docs/DataStructure_and_Algorithms/Data_structure/09_Search.html","title":"09_Search","keywords":"","body":" 查找 定义 线性结构查找 顺序查找 二分查找 对半查找 斐波那契查找 插值查找 分块查找 树形结构的查找 二叉查找树 AVLTree(高度平衡树) 红黑树（Red Black Tree） Splay 树 B树（B-Tree） B+ 树 散列查找 散列（Hash, 亦称哈希、杂凑） 哈希函数 冲突 散列表的删除 查找 定义 [!note] 查找亦称检索。给定一个文件包含n个记录（或称元 素、结点），每个记录都有一个关键词域。一个查找算法， 就是对给定的值K，在文件中找关键词等于K的那个记录。 查找结果：成功或者失败 平均查找长度：查找一个元素所作的关键词平均比较次数 线性结构查找 顺序查找 从表的一端开始，依次将记录的关键字和给定值进行比较，寻找关键字 既适用于线性表的顺序存储结构，又适用于线性表的链式存储结构 实现简单，仅实现其中数组查找 template int Search_Seq(T* ST,int n, T key) { for (int i = 0; i 改进 //通过为表引入一个“虚拟＂记录key即设置监视哨，并且每次前进步长为二 //通过设置监视哨， 免去查找过程中每一步都要检测整个表是否查找完毕从而减少比较次数，能提高算法S的查找效率 template int Search_Seq_modify(std::vector& ST, T key) { // 放入虚拟记录 ST.push_back(key); int i = 0; while (ST[i] != key) { if (ST[i + 1] != key) { i += 2; // 步长为2 } else { i++; // 步长为1 } } // 返回结果 if (i == ST.size() - 1) { // 查找失败 return -1; } else { // 查找成功，返回索引 return i; } } 二分查找 二分查找要求线性表必须采用顺序存储结构， 而且表中元素按关键字有序排列 有序表Rlow ,Rlow+1 ,…, Rhigh 按照关键词递增有序。 选取一个 位置 mid (low 若: K K > Rmid，[K只可能在Rmid右侧] K = Rmid ，[查找成功结束] 使用不同的规则确定mid，可得到不同的二分查找方法：对半查找、斐波那契查找、插值查找等 对半查找 K与待查表的中间记录进行比较，即mid == (low+high)/2 每次迭代可将查找范围缩小一半。 左闭右闭 // target 是在一个在左闭右闭的区间里，也就是[left, right] //闭区间里，while (left target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target template int Binary_Search(T* a, int left,int right, T key) { int mid; //循坏搜索 while (left > 1); if (key 左闭右开 //定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。 //while (left target) right 更新为 middle，因为当前nums[middle]不等于target template int Binary_Search(T* a, int n, T key) { int left = 0; int right = n; //循坏搜索 while (left > 1); if (key 递归写法 //闭区间递归实现二分查找 template int Binary_Search_Recursive(T* a, int left, int right, T key) { if (left > right) { return -1; // 区间为空，未找到 } int mid = left + ((right - left) >> 1); // 计算中间索引，防止溢出 if (key int Binary_Search_Recursive_Open(T* a, int left, int right, T key) { if (left >= right) { return -1; // 区间为空，未找到 } int mid = left + ((right - left) >> 1); // 防止溢出 if (key 扩展：二叉判定树 便于分析算法的时间效率，采用二叉树表示查找过程 对于 有序表Rlow , Rlow+1 ,…, Rhigh ，对半查找的二叉判定树T(low,high) 的是按如下递归定义的扩充二叉树： 当high-low+1 当high-low+1 > 0时，令mid=(low+high)/2 T(low, high)的根结点是mid ； 根结点的左子树是Rlow ,…,Rmid-1 对应的二叉判定树； 根结点的右子树是Rmid+1 ,…,Rhigh 对应的二叉判定树。 在二叉树中空指针的位置，都增加特殊的结点（空叶结点）， 由此生成的二叉树称为扩充二叉树。称空叶结点为外结点，其余结点为内结点 对半查找算法的每次 成功查找对应判定树 的一个内结点，元素 比较次数为该结点的深度加1，用于计算查找成功的平均查找长度。 每次不成功的查找对应判定树的一个外结 点，关键词的比较次 数为该结点的深度。用于计算查找失败的平均查找长度。 对于对半查找的优化或者改进 一致查找 //一致对半查找， //譬如仅使用三个指针(s、门和e)中的两个。 //其具体思路是，使用当前位置i和它的变化率x,在每次不相等的比较之后，可置i cal_delta(int n) { std::vector delta; // 保存步长 int k = int(log2(n)) + 1; // 计算层数 int temp = 1; for (int i = 0; i int cbiSearch(T* a, int n, int key) { if (n Delta = cal_delta(n); // 生成步长数组 int i = n / 2; int j = 1; // 当前步长索引 while (key != a[i]) // 循环直到找到 key { if (key = Delta.size()|| Delta[j] == 0 ) return -1; // 步长为 0，无法再分割 else { i -= Delta[j]; // 左移 j++; // 步长递减 } } if (a[i] = Delta.size() || Delta[j] == 0)return -1; // 步长为 0，无法再分割 else { i += Delta[j]; // 右移 j++; // 步长递减 } } } return i; // 找到目标，返回下标 } 斐波那契查找 在二分搜索的基础上，根据斐波那契数列分割，而不是简单的二分 前提是待查找的查找表必须顺序存储并且有序 平均和最坏情况下的时间复杂性为O(log2n)。 总体运行时间略快于对半查找算法。 因为算法不涉及乘除法，而只涉及加减法。 //数列从坐标1开始计数 //构造辅助数组，即斐波那契数列，数列生成到大于等于n std::vector Fib_arr(int n) { std::vector Fib; //初始化 Fib.push_back(0); Fib.push_back(1); for (int i = 2;; i++) { int next = Fib[i - 1] + Fib[i - 2]; Fib.push_back(next); if (next - 1 >= n) break; } return Fib; } template int Fibonacci_Search(T* a,int n,T key) { //空表 if (n F = Fib_arr(n); int k = F.size()-1; //如果a数组不足F[k]-1，则重复增加a的最后一个数直到长度等于F[k]-1 std::vector temp{ a,a+n }; //一次性调整 temp 的大小来提高效率 temp.resize(F[k] - 1, temp[n - 1]); //查找，注意这里实现查找区间左边比右边大 //即如果当前区间为F[k]-1=F[k-1]-1 + F[k-2]-1 + 1;最后一个1的位置给mid //左区间为F[k-1]-1, 右区间为F[k-2]-1 while (left 插值查找 基本原理是根据要查找的值在有序数组中的大致位置进行估计，以此来缩小搜索范围 通过数据的分布情况来预测目标值的位置，特别适用于有序且均匀分布的数据集 template int InterPolation_Search(T* a, int n, T key) { if (n right) return -1; if (key 分块查找 分块查找，又称为索引顺序查找 在此查找法中，除表本身以外，尚需建立一个 “索引表”。 对每个子表（或称块）建立一个索引项，其中包括两项内容： 关键字项（其值为该子表内的最大关键字）和指针项（指示该子表的第一个记录在表中位置）。 索引表按关键字有序，则表或者有序或者分块有序，由于块内是无序的，故插入和删除比较容易，无需进行大量移动。 过程 将大数组分成若干子数组（块），每个块中的数值都 比后一块中数值小（块内不要求有序），建一个索引表记录每个子表的起始地址和各块中的最大关键字 先将key依次和索引表中各最大关键字利用对半查找进行比较，确定待查记录所在的块（子表） 确定了关键字所在的块后，从该块的指针项（指示该子表的第一个记录在表中位置）顺序查找 树形结构的查找 [!tip] 对有序数组的二分查找，适用于静态查找场景，若元素动态变化（插入、删除元素），为了维持数组有序，需要O(n)时间调整。 所以就有了树形结构的查找结构 二叉查找树 [!note] 一棵二叉树，其各结点关键词互异，且中根序列按其关键词递增排列 二叉查找树中任一结点P，其左子树中结点的关键词都小于P的关键词，右子树中结点的关键词都大于P的关键词， 且结点P的左右子树也都是二叉查找树。 查找、插入、删除平均时间复杂度O(logn)，但最坏情况时间复杂度为O(n)（根节点为最大节点或者最小结点 template class Tree { public: //数据项 T data;//重载了==运算符和 核心操作 查找：在二叉查找树中查找关键词为K的结点 //在根指针T所指二叉排序树中递归地查找某关键字等于key的数据元素 Tree* SearchBiSortTree(Tree* root, T key) { //二叉排序树为空，则查找失败，返回空指针 if (!root)return nullptr; //key等千T->data.key, 则查找成功，返回根结点地址 if (root->data == key) { return root; } else if (key data)//key小千T->data.key, 则递归查找左子树 { return SearchBiSortTree(root->lchild, key); } else//key大千T->data.key, 则递归查找右子树 { return SearchBiSortTree(root->rchild, key); } } 插入：将关键词为K的结点插入二叉查找树，插入后仍为二 叉查找树，若K已在树中，则该节点大小加一。 //当二叉排序树T中不存在关键字等千e.key的数据元素时,则插入该元素 //注意传入二级指针 void InsertBiSortTree(Tree*& root, T key) { //空树直接将其作为根节点 if (!root) { Tree* temp = new Tree(key); root = temp; } else if (key data)//将*S插入左子树 { InsertBiSortTree(root->lchild, key); } else if (root->data rchild, key); } else//相等说明root存在相同关键字的结点,个数++ { root->count++; return; } //处理size,根的节点数等于左右子树和加上本身个数 root->size = root->count + (root->left ? root->left->size : 0) + (root->right ? root->right->size : 0); // 更新节点的子树大小 return; } 删除：删除关键词为K的结点（如果该结点大小大于一则大小减一），删除后仍为二叉查找树，采用代替法删除 //二叉排序树的删除 //被删除的结点可能是二叉排序树中的任何结点 //删除结点后，要根据其位置不同修改其双亲结点及相关结点的指针，以保持二叉排序树的特性 void DeleteBST(Tree*& root, T key)//因为可能删除根节点，所以传入二级指针 { //空树 if (!root)return; //初始化,目标结点和目标节点的父节点以便查找 Tree* p = root; Tree* pre = nullptr; //查找 while (p) { //找到关键字等于key的结点* p, 结束循环 if (p->data == key)break; //前移 pre = p; //判断往左移还是右移 p = key data ? p->lchild : p->rchild; } //找不到 if (!p)return; //count大于1 if (p->count > 1) { p->count--; } else { //考虑三种情况 //q记录s的前驱 Tree* q = p; Tree* s = p->rchild; //被删结点*p左右子树均不空 if (p->lchild && p->rchild) { //在*p的左子树中继续查找其前驱结点，即最右下结点也是左子树最大节点用以代替被删除节点 //或者找右子树最小节点代替 while (s->rchild) { q = s; s = s->rchild; } //s指向被删结点的 “前驱\",以最大节点替换被删结点 p->data = s->data; //重接*q的右子树 if (q != p)//避免q未移动 { //s左子树的值依旧大于其前驱，并且s作为最大节点一定没有右子树了 q->rchild = s->lchild; } else//重接*q的左子树,未移动则q即是被s替换的p { q->lchild = s->lchild; } delete s; return; } else if (!p->rchild)//被删结点*p无右子树， 只需重接其左子树 { q = p; p = p->lchild; } else if (p->lchild)//被删结点*p无左子树， 只需重接其右子树 { q = p; p = p->rchild; } //将p所指的子树挂接到其双亲结点*f相应的位置 //被删结点为根节点 if (!pre)root = p; else if (q == pre->lchild)//被删结点为前驱的左子树 { //挂接到*f的左子树位置 pre->lchild = p; } else //被删结点为前驱的左子树 { pre->rchild = p; } delete q; } //维护size root->size = root->count + (root->left ? root->left->size : 0) + (root->right ? root->right->size : 0); // 更新节点的子树大小 return; } //递归版本，注意传入二级指针 void remove(Tree*& root,T key) { //空树，或者找不到 if (root == nullptr) { return; } if (root->data rchild, key); } else if (key data) { remove(root->lchild, key); } else//找到 { if (root->count > 1) { root->count--; } else { //左子树为空 if (root->lchild == nullptr) { Tree* temp = root; root = root->rchild; delete temp; return; } //右子树为空 else if (root->rchild == nullptr) { Tree* temp = root; root = root->lchild; delete temp; return; } else { //找到继承者，即左子树最大节点或者右子树最小节点 Tree* successor = findMax(root->lchild); root->data = successor->data; root->count = successor->count; // 当 successor->count > 1时，也应该删除该节点，否则 // 后续的删除只会减少重复数量 successor->count = 1; remove(root->rchild, successor->data); } } } // 继续维护size，不写成 --root->size; // 是因为value可能不在树中，从而可能未发生删除 root->size = root->count + (root->left ? root->left->size : 0) +(root->right ? root->right->size : 0); return; } AVLTree(高度平衡树) 定义 [!note] 一棵满足如下条件的二叉查找树：任意结点的左子树和右子树的高度最多相差1。 即对于任意结点P，| P的左子树高度−P的右子树高度 | AVL树中任意结点P的平衡系数(平衡因子）定义为：P的左子树高度减去右子树高度。从定义可知平衡系数只可能为：-1,0,1 核心操作 [!important] 查找：与普通二叉查找树一致。 插入和删除：先使用二叉查找树的插入/删除方法，但插入/ 删除一个结点后，有可能破坏AVL树的平衡性。因此需对平衡树进行调整，恢复其平衡性，实现这种调整的操作称为“旋转（Rotation）”。 插入新结点X后，若AVL树失去平衡，应调整失去平衡的最小子树，即找从X到根结点的路径上的第一个失衡结点A， 平衡以 A为根的子树。 调整策略： ①LL型：右转 ②RR型：左转 ③LR型：左转+右转 ④RL型：右转+左转 对于插入： 如何找从插入点到根结点的路径中第一个失衡结点A？ ➢ 从根到插入点（自顶向下）：通过递归过程实现； ➢ 从插入点到根（自底向上）：通过递归函数的返回过程（ 回溯）实现。在上一层递归函数返回后，检查当前结点的平衡性。 void Insert(AVLnode* &root, int K) { if(root==NULL) root=new AVLnode(K); else if(K key) //在左子树插入 Insert(root->left, K); else if(K > root->key) //在右子树插入 Insert(root->right, K); ReBalance(root); } //调整平衡 void ReBalance(AVLnode* &t) { if(t==NULL) return; if(Height(t->left)- Height(t->right)==2){ if(Height(t->left->left) >= Height(t->left->right)) LL(t); else LR(t); }else if(Height(t->right)- Height(t->left)==2){ if(Height(t->right->right) >= Height(t->right->left)) RR(t); else RL(t); } UpdateHeight(t); } 对于删除 二叉查找树的删除算法进行删除 沿实际删除点到根结点的路径，向上找第 一个不平衡点为A，平衡以 A为根的子树。 平衡后，可能使子树A高度变小。这样可能导致A的父结点 不满足平衡性。 要继续向上考察结点的平衡性，最远可能至根结点， 即最多需要做O(logn)次旋转 void remove(AVLnode* &root, int K) { if(root==NULL) return; if(Kkey) remove(root->left, K); //在左子树删K else if(K>root->key) remove(root->right, K); //在右子树删K else if(root->left!=NULL && root->right!=NULL){ AVLnode *s=root->right; while(s->left!=NULL) s=s->left; root->key=s->key; //s为t右子树中根序列第一个结点 remove(root->right, s->key); }else{ AVLnode* oldroot=root; root=(root->left!=NULL)? root->left:root->right; delete oldroot; } ReBalance(root); } 总结 AVL树的高度为O(logn)，因此使插入、删除、查找的最坏时间复杂度均为O(logn)。 删除操作最坏情况下需要做O(logn)次旋转，即从删除节点一直维护平衡到根节点 红黑树（Red Black Tree） 红黑树是一种自平衡的二叉搜索树。每个节点额外存储了一个 color 字段 (\"RED\" or \"BLACK\")，用于确保树在插入和删除时保持平衡。 [!tip] 一棵合法的红黑树必须遵循以下五条性质： 节点为红色或黑色(非红即黑) NIL 节点（空叶子节点或者说外结点）为黑色（黑外） 红色节点的子节点为黑色（红父黑子） 从根节点到 NIL 节点的每条路径上的黑色节点数量相同 根结点为黑色； （黑根） 这条性质要求完成插入操作后若根节点为红色则将其染黑，但由于将根节点染黑的操作也可以延迟至删除操作时进行，因此，该条性质并非必须满足。 红黑树类的定义 template > class RBTreeMap { // 排序函数 Compare compare = Compare(); // 节点结构体 struct Node { std::shared_ptr parent,left,right; enum class color{BLACL,RED}; Key key; Value value; }; // 根节点指针 Node* root = nullptr; // 记录红黑树中当前的节点个数 size_t count = 0; } Splay 树 [!note] Splay 树, 或 伸展树，是一种平衡二叉查找树 它通过 Splay/伸展操作 不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，能够在均摊 时间内完成插入，查找和删除操作，并且保持平衡而不至于退化为链。 结构 Splay 树是一棵二叉搜索树，查找某个值时满足性质： 左子树任意节点的值 节点维护信息 rt tot fa[i] ch[i][0/1] val[i] cnt[i] sz[i] 根节点编号 节点个数 父亲 左右儿子编号 节点权值 权值出现次数 子树大小 旋转操作 为了使 Splay 保持平衡而进行旋转操作，旋转的本质是将某个节点上移一个位置。 旋转需要保证： 整棵 Splay 的中序遍历不变（不能破坏二叉查找树的性质）。 受影响的节点维护的信息依然正确有效。 root 必须指向旋转后的根节点。 B树（B-Tree） [!note] B树：平衡m叉查找树。 一个结点存多个关键词，形成多叉查找树来代替 二叉查找树，降低查找树高度。 B树结点结构 包含j个关键词：满足 K1。 包含j+1个指针：第i个指针pi（0 m阶B树的定义 ① 每个结点至多有m个孩子； ② 除根和叶结点外，每个结点至少有[m/2]取下界个孩子； ③ 若根结点不是叶结点，则至少有2个孩子； ④ 有k个孩子的结点恰好包含k-1个递增有序的关键词； ⑤ 所有的叶结点在同一层，不包含任何信息。 [!important] 根和叶以外的结点有[m/2]取下界～m个孩子 根结点有2 ～m个孩子 在 B 树中，有两种节点： 内部节点（internal node）：存储了数据以及指向其子节点的指针。 叶子节点（leaf node）：与内部节点不同的是，叶子节点只存储数据，并没有子节点。是虚拟的结点 指向叶结点的指针是空指针 B树的查找 ①在根结点内查找K，即在其所包含的关键词K1 ,…, Kj 中查找 K（可采用顺序查找或对半查找），找到则查找成功； ②否则，确定K在某个Ki 和Ki+1 之间，于是在指针pi 所指向的 子树里继续查找K，即将pi 所指向的结点读入内存，继续查 找；如果pi 为空，则查找失败。 B树的插入 先查找，在查找失败的位置插入。 若在结点中插入关键词后，结点包含的关键词超过m-1个， 则该结点关键词上溢，需进行分裂操作。 B树的删除 类似于二叉查找树的删除 但是当删除关键词后，若该结点目前包含的关键词个数小于[m/2]-1 称为下溢，则从左（右）兄弟结点中借最大（最小）关键词。 B+ 树 ① 每个结点至多有m个子结点； ② 除根结点外，其它每个非叶结点至少有m/2个子结点； ③ 根结点至少有两个子结点； ④ 包含n个孩子的结点有n个关键词（即每个关键词对应一棵子 树）； ⑤ 每个非叶结点仅包含各孩子的最大关键词及指向各孩子的指 针（每个非叶结点不存放实际的数据记录，可看成索引）； ⑥ 所有叶结点包含全部关键词及指向相应数据记录的指针，且 叶结点按关键词递增的顺序连成一个链表（每个叶结点的指 针指向磁盘上实际数据文件中的记录，也可看成索引）。 [!warning] B树：每个结点存储关键词及其 对应的实际数据 记录（或指针） B+树：只存关键词 散列查找 散列（Hash, 亦称哈希、杂凑） [!note] 哈希表又称散列表，一种以「key-value」形式存储数据的数据结构。 所谓以「key-value」形式存储数据，是指任意的键值 key 都唯一对应到内存中的某个位置。只需要输入查找的键值，就可以快速地找到其对应的 value。 可以把哈希表理解为一种高级的数组，这种数组的下标可以是很大的整数，浮点数，字符串甚至结构体。 哈希函数 ✓自变量K：关键词 ✓函数值h(K)：元素在散列表中的存 储地址（亦称散列地址） ✓作用：把关键词值映射到散列地址 哈希函数应当易于计算，并且尽量使计算出来的索引均匀分布。 冲突 [!warning] 多个不同的关键词具有相同的散列函数值， 即K1!=K2, h(K1)=h(K2) 一些方法来处理冲突 拉链法 拉链法也称开散列法（open hashing）。 拉链法是在每个存放数据的地方开一个链表，如果有多个键值索引到同一个地方，只用把他们都放到那个位置的链表里就行了。查询的时候需要把对应位置的链表整个扫一遍，对其中的每个数据比较其键值与查询的键值是否一致。 若链表很长，可将其替代为跳表或查找树 闭散列法 闭散列方法把所有记录直接存储在散列表中，如果发生冲突则根据某种方式继续进行探查。 线性探查（亦称线性探测）:当发生冲突时，以固定的次序查找表中的记录，直到找到一个关键词为K的结点或者找到一个空位置。 二次探查: 一旦冲突，能更快的跳离“是非之地”，避免聚集 双重探查：从h(K)开始，寻找空地址时，所前进的步长不是固定的，而与K有关， 散列表的删除 懒惰删除 并不真正的删除元素，而是将删除的位置做一个标记，其状态置为“已删除” 实时删除 将位置j清空，然后考察位置j+1到下一个空位前的每一个位置i，看将位置j清空后，是否阻碍查找T[i]的探查路 径，若是则将T[i]前移至空位。 延迟删除 每隔一段时间定期执行一次真正删除， 把标记为“已删除”的结点真正清空 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 09_Search "},"docs/DataStructure_and_Algorithms/Data_structure/data_structure.html":{"url":"docs/DataStructure_and_Algorithms/Data_structure/data_structure.html","title":"data_structure","keywords":"","body":" 绪论 数据结构的研究内容 数据结构主要研究**非数值计算问题 ** 基本概念和术语 数据、 数据元素、 数据项和数据对象 数据（Date) 数据元素(Data Element) 数据对象 (Data Object) 数据结构 逻辑结构 线性结构 非线性结构 存储结构 算法和算法分析 算法定义及其特性 评价算法优劣的基本标准 时间复杂度 空间复杂度 线性表 定义(逻辑结构) 存储结构 顺序存储 链接存储 时空效率比较 空间 时间 栈和队列 栈 定义 应用 队列 定义 应用 数组和矩阵 数组 多维数组的存储和寻址： 矩阵的压缩存储 树 定义 存储结构 顺序结构 链接存储 重要操作 应用 图 定义 存储结构 应用(重要操作) 排序 定义 内排序 插入排序 交换排序 快速排序 选择排序 归并排序 基于关键词比较的排序算法分析 平方阶排序算法及改进算法 线性对数阶排序算法 分布排序 外排序 查找 定义 线性结构查找 顺序查找 二分查找 对半查找 斐波那契查找 插值查找 分块查找 树形结构的查找 二叉查找树 AVLTree(高度平衡树) 红黑树（Red Black Tree） Splay 树 B树（B-Tree） B+ 树 散列查找 散列（Hash, 亦称哈希、杂凑） 哈希函数 冲突 散列表的删除 [TOC] 绪论 数据结构的研究内容 数据结构主要研究非数值计算问题 ​ 数据结构是一门研究非数值计算程序设计中的操作对象， 以及这些对象之间的关系和操作的学科。 例如: 学生学籍管理系统 人机对弈问题 最短路径问题。 基本概念和术语 数据、 数据元素、 数据项和数据对象 数据（Date) 数据 (Data) 是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。 数学计算中用到的整数和实数 文本编辑中用到的字符串 多媒体程序处理的图形、 图像、声音及动画等通过特殊编码定义后的数据 数据元素(Data Element) 数据元素(Data Element)是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。 在有些情况下，数据元素也称为元素、记录等 数据元素用千完整地描述一个对象 一名学生记录 树中棋盘的一个格局（状态） 及图中的一个顶点 数据对象 (Data Object) 数据对象 (Data Object) 是性质相同的数据元素的集合，是数据的一个子集。 整数数据对象是集合N= {0, 士1' 士2,…} 字母字符数据对象是集合C= {'A','B', …，'Z','a','b', …， 'z'} 学生基本信息表也可以是一个数据对象 只要集合内元素的性质均相同，都可称之为一个数据对象。 数据结构 数据结构 (Data Structure) 是相互之间存在一种或多种特定关系的数据元素的集合。 数据结构是带 ”结构＂ 的数据元素的集合 “结构” 就是指数据元素之间存在的关系 逻辑结构 数据的逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立千计算机的。 数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。 数据的逻辑结构有两个要素 数据元素 关系 （指数据元素间的逻辑关系） 集合结构 数据元素之间除了 “属于同一集合” 的关系外，别无其他关系。例如，确定一名学生是否为 班级成员， 只需将班级看做一个集合结构。 线性结构 数据元素之间存在一对一的关系。例如，将学生信息数据按照其入学报到的时间先后顺序进 行排列，将组成一个线性结构。 树结构 数据元素之间存在一对多的关系。例如，在班级的管理体系中，班长管理多个组长，每位组长管理多名组员，从而构成树形结构。 图结构或网状结构 数据元素之间存在多对多的关系。例如，多位同学之间的朋友关系， 任何两位同学都可以是朋友，从而构成图状结构或网状结构。 线性结构 线性表（典型的线性结构，如例1.1中的学生基本信息表） 栈和队列（具有特 4 l 第1章 绪论 I 殊限制的线性表，数据操作只能在表的一端或两端进行） 字符串（也是特殊的线性表，其特殊性 表现在它的数据元素仅由一个字符组成） 数组（是线性表的推广，它的数据元素是一个线性表） 广义表（也是线性表的推广，它的数据元素是一个线性表，但不同构，即或者是单元素，或者是 线性表） 非线性结构 树（具有多个分支的层次结构） 二叉树（具有两个分支的层次结构） 有向图（一种图结构，边是顶点的有序对） 无向图（另一种图结构，边是顶点的无序对） 存储结构 存储结构是逻辑结构在计算机中的存储表示 有两类存储结构：顺序存储结构和链式存储结构。 算法和算法分析 算法定义及其特性 算法 (Algorithm) 是为了解决某类问题而规定的一个有限长的操作序列。 算法由有限条指令构成，规定了解决特定问题的一系列操作。 一个算法必须满足以下五个重要特性。 有穷性：有限个步骤之后终止。 确定性：每条指令有明确的含义。 可行性：通过已经实现的基本运算执行有限次来完成。 输入：外界提供的量。 输出：结果。 评价算法优劣的基本标准 正确性：正确结果 可读性： 健壮性（鲁棒性）：对有缺失、有噪声或有错误的输入数据，算法应具有较强的适应能力。 高效性：时空复杂度。 时间复杂度 影响算法时间代价的最主要因素是问题规模。 问题规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示。 一条语句的重复执行次数称作语句频度(FrequencyCount) 而对于时间复杂度，取决于基本运算 基本运算是指算法运行过程中起主要作用且花费时间最多的运算 空间复杂度 算法在实现时所需要的辅助空间 线性表 定义(逻辑结构) 由n(n>=0)个数据特性相同的元素构成的有限序列称为线性表 或者说是数据类型相同的元素组成的有限集合 线性表中元素的个数n(n>=0)定义为线性表的长度，n=0时称为空表。 对千非空的线性表或线性结构，其特点是： 存在唯一的一个被称作“第一＂的数据元素； 存在唯一的一个被称作“最后一个＂的数据元素； 除第一个之外，结构中的每个数据元素均只有一个前驱； 除最后一个之外，结构中的每个数据元素均只有一个后继。 存储结构 顺序存储 线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，这种表示也称作线性表的顺序存储结构或顺序映像。 逻辑上相邻的数据元素，其物理次序也是相邻的 简单来说就是数组 链接存储 用任意一组存储单元存储线性表 一个存储单元除包含结点数据字段的值，还必须存放其逻辑相邻结点（前驱或 后继结点）的地址信息，即指针字段。 链表 哨兵节点： 为便于在表头进行插入、删除操作，通常在表的前端增加一个特殊的表头结点，称其为哨位（哨兵）结点。 //节点 struct ListNode{ int data; ListNode* next; ListNode(int d){ data=d; next=NULL; } }; struct List{ ListNode* headnode;//哨兵节点 } 时空效率比较 空间 顺序表空间来自于申请的数组空间，数组大小确定，当元素较少时，顺序表中的很多空间处于闲置状态，造成了空间的浪费； 链表空间是根据需要动态申请的，不存在空间浪费问题，但链表需要在每个结点上附加一个指针，从而产生额外开销 时间 基于下标的查找 插入/删除 顺序表 O(1)按下标直接查找 O(n) 需要移动若干元素 链 表 O(n) 从表头开始遍历链表 O(1) 只需修改几个指针值 栈和队列 对于栈和队列，可以理解为操作受限的线性表，只可以在线性表的表头或者表尾进行操作 栈 定义 栈(stack)是限定仅在表尾进行插入或删除操作的线性表。 因此，对栈来说，表尾端有其特殊含义，称为栈顶(top) 相应地，表头端称为栈底(bottom)。 不含元素的空表称为空栈。 栈的修改是按后进先出的原则进行的，因此，栈又称为后进先出(LastIn First Out, LIFO)的线性表， 应用 进制转换：假设十进制转换为K进制： 创建一个栈Stack 不断除以K取余数。后生成的余数先输出，先生成的余数后输出，正好符合栈的后进先出性质。 括号匹配： 从左向右扫描字符串 若遇到左括号：压栈 若遇到右括号：弹出栈顶的左括号与之匹配。 最后判断栈空 n对括号共有多少种可能的合法匹配序列：第n个卡特兰数 Cn=(2n)!/(n!*n!)/(n+1) 表达式求值：（中缀表达式转变为后缀表达式） 从左到右依次读入后缀表达式的每一个操作数/运算符/结束符 若读到的是操作数，将它压入栈。 若读到的是运算符，就从操作数栈中连续弹出两个元素（操作数），进行相应的运算，并将结果压入栈中。 读入结束符时，栈顶元素就是计算结果。 调度场算法：中缀表达式转后缀表达式 设置一个栈，存放运算符从左到右依次读入中缀表达式的每一个元素 操作数规则：直接放入后缀表达式,注意对多位数的处理 运算符规则： 栈空或栈顶是左括号：压栈 当前运算符优先级>栈顶运算符：压栈 当前运算符优先级栈顶或栈空或栈顶为左括号（期间弹出的运算符顺序依次放入后缀表达式），再把当前运算符压栈 括号规则： (1) 遇到左括号：压栈 (2) 遇到右括号：弹栈直至左括号 结束符规则：弹栈至栈空 栈混洗：给定入栈序列，模拟出栈序列 n个元素的栈混洗总数，即n对括号的匹配序列，卡特兰数*(n+1) n个元素的栈混洗合法出栈序列，即n对括号的合法匹配序列，卡特兰数*(n+1) 利用栈模拟队列: 利用两个栈模拟队列 共享栈 队列 定义 队列(queue)是一种先进先出(First In First Out, FIFO)的线性表 允许插入的一端称为队尾(rear), 允许删除的一端则称为队头(front)。 应用 BFS广度优先搜索 栈和队列都需要注意的一点是top和rear指针是指向元素还是下一个空位置，判满和判空条件不同， 双端队列 数组和矩阵 数组 多维数组的存储和寻址： 已知数组A[a][b][c][d],每个元素占C个存储单元 数组元素A[i] j][k][l]的存储地址： 行优先:Loc(A)+( i*b*c*d + j*b*d + k*d + l )*C 列优先:Loc(A)+( i + j*a + k*a*b + l*a*b*c )*C 矩阵的压缩存储 压缩存储需考虑2个问题 需要多大存储空间：数组d[ ]需要多少元素 地址映射：矩阵的任意元素M(i, j)在一维数组d[ ]中的位置（下标）， 即把矩阵元素的下标映射到数组d的下标 对角矩阵的压缩存储 对于一个n*n的对角矩阵，至多只有n个非0元素，因此只需存储n个对角元素 M( i , i ) -> d[ i ] (下）三角矩阵的压缩存储 以按行优先方式压缩存放在一维数组d，d需要n(n+1)/2个元素 M(i, j)= d[k]=d[i(i−1)/2 + (j−1)] 对称矩阵M的压缩存储 对称矩阵中M(i, j)与M(j, i)的信息相同，只需存储M的下三角部分的元素信息。 对于对称矩阵中的下三角元素M(i, j) (i>=j) : i 对于上三角元素M(i, j) (i:元素值与下三角矩阵中的 元素M(j,i)相同 i 三对角矩阵M的压缩存储 方阵Mn*n中任意元素M(i, j)，当| i - j | >1时，有M(i, j) =0， 则 M称为三对角矩阵。 需要3*n-2个存储单位 对于非零元素：即| i-j | 稀疏矩阵的压缩存储 非零元素的个数远小于零元素的个数 三元组结点来存储矩阵的每个非零元素aij，其中i和j为元素的行号和列号，即node(i,j,aij) struct Triple{ int row; int col; int value; }; Triple Array[100]; 对于三元组有一个需要注意的算法：稀疏矩阵的快速转置。 预先确定矩阵M中每一列（即T中每一行）的第一个非零元的位置 求出每行非零元素个数，然后利用cpot[col]=copt[col-1]+num[col-1]，求出位置 十字链表:数据,该结点所在行 ,该结点所在列 ,指向左侧相邻非零元素的指针 ,指向上方相邻非零元素的指针,即node(row,col,value,left,up) struct ListNode{ int row; //节点所在行 int col; //节点所在列 int value; //数据 ListNode* left;//指向左侧相邻非零元素的指针 ListNode* up; //指向上方相邻非零元素的指针 }; 双向十字链表：在十字链表的基础上增加双方向的指针，并有循环链表的特点 struct ListNode{ int row; //节点所在行 int col; //节点所在列 int value; //数据 ListNode* left;//指向左侧相邻非零元素的指针 ListNode* up; //指向上方相邻非零元素的指针 ListNode* right; //指向右侧相邻非零元素的指针 ListNode* down; //指向下方相邻非零元素的指针 }; 树 定义 一棵树是结点的一个有限集合T。 若T空，则称为空树。 若T非空，则： 有一个被称为根的结点，记 为root(T)； 其余结点被分成m(m >=0) 个 不相交的非空集合T1,T,…,Tm， 且T1, T2, …, Tm也都是树，其 称为root(T)的子树。(递归结构) 相关术语 度 ：一个结点的度指该结点的子结点的数目。其中一棵树的度为各结点的度的最大值。 叶结点：度为0的结点，即没有孩子节点的结点。 分支结点 ：度大于0的结点，即非叶结点 边：树中结点间的连线 层数/深度：根结点层数为0，其余结点的层数为其父结点的层数加1。 树的高度/深度：树中结点的最大层数 结点的高度：以该结点为根的子树的高度 对于二叉树 二叉树中第i层至多有2^i个结点，i>=0 高度为k的二叉树中至多有2^(k+1)-1 (k>=0)个结点 在n个结点构成的二叉树中，若叶结点即度为零的结点个数为n0 ，度为2的结点个数为n2 ，则有：n0 = n2 ＋1 特殊二叉树 完全二叉树： 除最下一层外，每一层都是满的（达到 最大结点数）， 最后一层结点从左至右出现 对所有结点，按层次顺序从1开始编号，仅编号最大的非叶结点可以没有右孩子，其余非叶结点都有两个子结点 知道总度数可以求出各个不同度的节点数，因为度为1只可以为0或者1 满二叉树（特殊的完全二叉树）： 叶节点都在最后一层 每个非叶节点都有两个子节点 存储结构 顺序结构 将树的结点存放在数组里 或者我们这需要关注各个结点的逻辑关系而非各个结点的数据时，可用int数组,例如：对于第i个结点，父节点为tree[i]，特殊的根节点的没有父节点所以对应的值为本身或者一个负数，这个用法可用于哈夫曼树或者并查集 根节点存放在tree[0]，则tree[i]对应的左右子树分别为tree[2*i+1],tree[2*i+2]，父节点为tree[(i-1)/2](i>=1) 根节点存放在tree[1]，则tree[i]对应的左右子树分别为tree[2*i],tree[2*i+1]父节点为tree[i/2]（i>0) 比较适用于满二叉树和完全二叉树，对于普通的树未使用的空间较多 template class Complete_BiTree { public: std::vector tree; }; 链接存储 利用指针用类似链表的方式连接各个结点 template class BiTree { public: T data;//数据 BiTree* parent;//父节点,可有可无 BiTree* leftChild;//左子树 BiTree* rightChild;//右子树 //左右子树是否为线索 bool leftTag; bool rightTag; BiTree() = default; }; 重要操作 树的遍历（以链接存储为例） 二叉树的遍历：按照一定次序访问二叉树中所有结点， 并且每个结点仅被访问一次的过程 前序遍历(类似图的深度优先搜索DFS)，利用栈可以实现非递归。 //这里function不一定返回空，具体视情况而立,默认为输出data void PreOrderTraverseTree(BiTree* tree,/*处理函数*/std::function address = [](T& e)->void {std::cout data); //遍历左子树 if (tree->leftChild && !tree->leftTag) { PreOrderTraverseTree(tree->leftChild, address); } //遍历右子树 if (tree->rightChild && !tree->rightTag) { PreOrderTraverseTree(tree->rightChild, address); } return; } 非递归 // 非递归前序遍历函数，使用栈模拟递归过程 void Non_Recursive_PreOrderTraverseTree(BiTree* tree,/*处理函数*/std::function address = [](T& e)->void {std::cout *> stack; BiTree* current = tree; // 当前结点指向树的根结点 // 当前结点非空或者栈非空时，继续遍历 while (current || !stack.empty()) { // 遍历到当前结点时 if(current) { // 处理当前结点（例如打印当前结点的数据） address(current->data); // 将当前结点压入栈中，以便后续回溯 stack.push_back(current); // 转向当前结点的左子树继续遍历 current = current->leftChild; } // 当前结点为空但栈不为空时，需要回溯 else { // 从栈中弹出一个结点，恢复到上一个结点 current = stack.back(); // 弹出栈顶结点 stack.pop_back(); // 转向当前结点的右子树继续遍历 current = current->rightChild; } } } 中序遍历，利用栈实现非递归。 void InOrderTraverseTree(BiTree* tree,/*处理函数*/std::function address = [](T& e)->void {std::cout leftChild && !tree->leftTag) { InOrderTraverseTree(tree->leftChild, address); } //根节点 address(tree->data); //遍历右子树 if (tree->rightChild && !tree->rightTag) { InOrderTraverseTree(tree->rightChild, address); } return; } 非递归 // 非递归中序遍历函数，使用栈模拟递归过程 void Non_Recursive_InOrderTraverseTree(BiTree* tree, /*处理函数*/std::function address = [](T& e)->void {std::cout *> stack; BiTree* current = tree; // 当前结点指向树的根结点 // 当前结点非空或者栈非空时，继续遍历 while (current || !stack.empty()) { // 遍历到当前结点的左子树 if (current) { // 将当前结点压入栈中，以便后续回溯 stack.push_back(current); // 转向左子树继续遍历 current = current->leftChild; } // 当前结点为空但栈不为空时，需要回溯 else if (!stack.empty()) { // 从栈中弹出一个结点，恢复到上一个结点 current = stack.back(); // 弹出栈顶结点 stack.pop_back(); // 处理当前结点（例如打印当前结点的数据） address(current->data); // 转向当前结点的右子树继续遍历 current = current->rightChild; } } } 后序遍历 void PostOrderTraverseTree(BiTree* tree,/*处理函数*/std::function address = [](T& e)->void {std::cout leftChild && !tree->leftTag) { InOrderTraverseTree(tree->leftChild, address); } //遍历右子树 if (tree->rightChild && !tree->rightTag) { InOrderTraverseTree(tree->rightChild, address); } //根节点 address(tree->data); return; } 非递归 void Non_Recursive_PostOrderTraverseTree(BiTree* tree, /*处理函数*/ std::function address = [](T& e)->void { std::cout *> stack; BiTree* current = tree; // 当前结点指向树的根结点 BiTree* lastVisite = nullptr; // 记录上一个被访问的结点，用于判断右子树是否已访问 // 当前结点非空或者栈非空时，继续遍历 while (current || !stack.empty()) { // 遍历到当前结点的左子树 if (current) { stack.push_back(current); // 将当前结点压入栈中 current = current->leftChild; // 转向左子树 } else { // 当前结点为空，回溯到栈顶结点 BiTree* top = stack.back(); // 如果右子树存在且未访问，则遍历右子树 if (top->rightChild && lastVisite != top->rightChild) { current = top->rightChild; // 转向右子树 } else { // 右子树为空或者已访问 address(top->data); // 处理当前结点 lastVisite = top; // 更新上一个访问的结点 stack.pop_back(); // 弹出栈顶结点 } } } } - 层次遍历（类似图的广度优先搜索BFS） ```cpp void LevelOrderTraverseTree(BiTree* tree,/*处理函数*/std::function address = [](T& e)->void {std::cout *> trees; trees.push(tree); while (!trees.empty()) { BiTree* p = trees.front(); trees.pop(); address(p->data); //左子树 if (p->leftChild && !p->leftTag) { trees.push(p->leftChild); } //遍历右子树 if (p->rightChild && !p->rightTag) { trees.push(p->rightChild); } } return; } ``` 树和二叉树的转换（树使用兄弟儿子表示法） 应用 先根序列个数为n的不同二叉树的个数为卡特兰数 线索二叉树：利用节点的空指针指向结点的某个序列的前驱和后继 哈夫曼树 构造 一类带权路径长度最短的树。（用于不等长最优编码等） 在哈夫曼树中，权值越大的结点离根结点越近。 依次找到最小的两个节点组成一棵树直到所有节点都有根节点 编码： 在构造哈夫曼树之后，求哈夫曼编码的主要思想是：依次以叶子为出发点，向上回溯至根结点为止。 回溯时走左分支则生成代码 0, 走右分支则生成代码 l 译码： 初始化：从根节点开始，遍历二进制编码字符串。 遍历路径： 每个'0'表示向左子树移动，'1'表示向右子树移动。 每当到达叶子节点，就记录该节点编号即译出一个字符，并重新从根节点开始译码。 结束判断：若最终到达叶子节点，返回所有编号；否则该串无法译码为非法序列。 并查集 一种用于管理元素所属集合的数据结构，实现为一个森林 其中每棵树表示一个集合，树中的节点表示对应集合中的元素。 优化搜索 压缩路径 查询过程中经过的每个元素都属于该集合，我们可以将其直接连到根节点以加快后续查询。 size_t find(size_t x) { return pa[x] == x ? x : pa[x]=find(pa[x]); } 小树并入大树(按秩合并) // 合并两个集合，x 和 y 所在的集合进行合并，按秩合并策略 size_t unite(size_t x, size_t y) { // 找到 x 和 y 所在集合的根节点 x = find(x); y = find(y); // 如果 x 和 y 已经在同一个集合中，无需合并，直接返回 if (x == y) return; // 按秩合并，始终将小树合并到大树上 // 如果 x 的树小于 y 的树，将 x 和 y 交换，确保 x 是较大的树的根 if (size[x] 集合数：如果一个节点的根指向自己，则为整棵树的根即一个集合。 图 定义 图(Graph) G由两个集合V和E组成，记为G=(V,E) , 其中V是顶点的有穷非空集合， E是V中顶点偶对的有穷集合，这些顶点偶对称为边。 存储结构 边存储 将各个点的关系利用边存起来 struct Edge { //存储边节点的编号 //u->v int u; int v; //加入权值 int weight; Edge() = default; Edge(int _u, int _v,int weight=1) :u(_u), v(_v),weight(weight){ } }; 邻接表（稀疏图） 用顶点表将各个邻接点利用链接结构存放起来 //边结点 //边链表中边结点包括邻接点域(adjvex)、数据域(info) 和链域(nextarc) 三部分 //邻接点域指示与顶点V; 邻接的点在图中的位置；数据域存储和边相关的信息， 如权值等；链域指示与顶点v邻接的下一条边的结点。 template//默认为int class ArcNode { public: //该边所指向的顶点位置，如果为有向边则为弧头 int adjvex; //指向下一条边的指针 std::shared_ptr> nextarc; //边信息，如权值,默认无信息 T info; ArcNode() = default; ArcNode(int vex) :adjvex(vex),info(1),nextarc(nullptr){ } ArcNode(int vex,T info) :adjvex(vex),info(info), nextarc(nullptr) { } }; template class Adj_List { public: //表头结点表，此vector.size()即顶点数,所以不需要记录顶点数 std::vector> vertices; //记录边数 int arcnum; //是否为有向图 bool is_direct; }; 对于链式结构的的邻接表，可以使用变为使用数组存放边的前向星 // 边类定义，包含两个成员变量：目标节点v和权重w class edge { public: int v; // 目标节点 int w; // 边的权重 // 构造函数，初始化目标节点和边的权重 edge(int _v, int _w) :v(_v), w(_w){ } }; // 存储图的邻接表(前向星)，vextices[i]表示节点i的所有边 vector> vextices; 邻接矩阵（稠密图） 利用矩阵(即二维数组）将各个点是否存在边的信息存放起来 //使用一个二维数组 adj 来存边，其中 adj[u][v] 为 1 表示存在 u 到 v 的边，为 0 表示不存在。 //如果是带边权的图，可以在 adj[u][v] 中存储 u 到 v 的边的边权。 //默认顶点到自身没有边 //并且二维数组难以改变结构所以不考虑增加和删除节点但是可以增删边，并且二维数组空间大不适用于稀疏图 //其实无向图为对称矩阵可以压缩为一维数组存放，但是实现逻辑相似不考虑分离 //小技巧：对于有向无向图图，并且规定没有弧为0，有弧为1，则矩阵A^n[i][j]的值表示从顶点i到顶点j中路径长度为n的数目 class Adj_Matrix { public: std::vector> graph; //标志是否为有向图 bool is_direct; Adj_Matrix() = default; //顶点数量number,依旧从零开始,当weight默认时表示无权图 Adj_Matrix(int number,bool direct=false, int weight = INT_MAX):is_direct(direct) { graph.resize(number, std::vector(number,weight)); } }; 对于邻接表和邻接矩阵的比较 首先是，邻接表适用于稀疏图，邻接矩阵适用于稠密图 判断两个顶点是否存在边或者查询修改边的信息，邻接表O(n)（n表示该点的出度），邻接矩阵O(1)，所以频繁查询和修改边的信息则邻接矩阵更合适 对于需要增删顶点则邻接表更适合 应用(重要操作) 都以邻接矩阵为例 DFS:深度优先搜索，非递归时使用栈 //深度优先搜索（DFS）算法,并对节点进行处理,vis保存是否访问 void dfs(int u, std::vector& vis, const Adj_Matrix& adj, std::function address = [](int& u)->void {std::cout =vis.size()||vis[u]) { return; } //标记已访问 vis[u] = true; address(u); //递归搜索 for (int i = 0; i 非递归 //深度优先搜索（DFS）算法的非递归形式，类似于广度优先，但这里使用栈 void dfs_non_recursive(int start, std::vector& vis, const Adj_Matrix& adj, std::function address = [](int& u)->void {std::cout = vis.size())return; std::vector q;//存放当前连通分支节点 q.push_back(start);//将起始节点入栈 vis[start] = true;// 标记为已访问 //栈不为空，即当前连通分支还有未访问的节点 while (!q.empty()) { int u = q.back(); // 获取栈顶的节点 q.pop_back(); // 出栈 address(u); // 处理当前节点 // 遍历当前顶点，找到所有邻接并且未访问的节点加入队列 for (int i = 0; i BFS:广度优先搜索 非递归利用队列（类似树的层次遍历） 可用于单源无权（权值为1）最短路 //广度优先搜索（BFS）算法（非递归）,并对节点进行处理,vis保存是否访问 void bfs(int start, std::vector& vis, const Adj_Matrix& adj, std::function address = [](int& u)->void {std::cout = vis.size())return; std::queue q;//存放当前连通分支节点，并要着start节点一圈圈增加 vis[start] = true;//标记初始点访问 q.push(start);//将起始节点入队 //队列不为空，即当前连通分支还有为访问的节点 while (!q.empty()) { int u = q.front(); // 获取队列前端的节点 q.pop(); // 出队 address(u); // 处理当前节点 // 遍历当前顶点，找到所有邻接并且未访问的节点加入队列 for (int i=0;i 拓扑序列：AOV网是一个有向无环图，可以用于证明图是否有环 选择一个入度为0的顶点并输出 删除该顶点及该顶点引出的所有边 执行①②，直至所有顶点已输出，或图中剩余顶点 入度均不为0（说明存在环，无法继续拓扑排序） 对于任何无环的AOV网，其顶点均可排成拓扑序列， 其拓扑序列未必唯一 拓展：DFS可以输出拓扑序的逆序 std::vector TopologicalSort(const Adj_Matrix& adj) { // 如果是无向图，无法进行拓扑排序 if (!adj.is_direct) { std::cerr Topo; // 存储拓扑排序结果 std::queue zero_in_degree; // 存储入度为0的节点 // 存放各个节点的入度 std::vector indegree(number, 0); // 计算每个节点的入度 for (int u = 0; u v，v的入度增加 if (adj.graph[u][v] != INT_MAX) { indegree[v]++; } } } // 将入度为0的节点放入队列 for (int i = 0; i i，i的入度减一 if (adj.graph[u][i] != INT_MAX) { indegree[i]--; // 如果i的入度为0，加入队列 if (indegree[i] == 0) { zero_in_degree.push(i); } } } } // 检查是否存在环：如果拓扑排序结果的节点数不等于图的节点数，说明图中有环 if (Topo.size() != number) { std::cerr 关键路径：完成整个工程所需的最短时间取决于从源点到汇点的最长路径长度 关键活动：活动的最早开始时间等于活动 A 的最迟开始时间， 即l(i)＝e(i),也是不可以拖延的活动 关键路径：由关键活动组成的路径，亦即源点到汇点的最长路径，可能不止一条 对AOE网求各顶点vj的最早发生时间ve(j) 求各顶点vj的最迟发生时间vl(j)； 求出各活动ai的最早开始时间e(i)和 最迟开始时间l(i)，若e(i)=l(i)，则ai是关键活动 具体算法 求出拓扑排序，若网中有环则终止算法，按拓扑序求出各顶点的最早发生时间ve 按逆拓扑序求各顶点的最迟发生时间vl 根据ve和vl的值，求各活动的最早开始时间e与最迟开始时间l，若e=l，则对应活动是关键活动，其中最晚开始时间和最早开始时间的差值为活动的时间余量。 因为拓扑序列不唯一，所以关键路径也不唯一。 //关键路径不唯一 std::vector CriticalPath(const Adj_Matrix& adj) { // 检查是否为无向图 if (!adj.is_direct) { std::cerr Topo = TopologicalSort(adj); // 如果拓扑排序为空，表示图中存在环，无法进行关键路径计算 if (Topo.empty()) { std::cout VE(number, 0); // 计算每个节点的 VE for (int u = 0; u v，更新 v 的 VE if (adj.graph[u][v] != INT_MAX) { VE[v] = std::max(VE[v], VE[u] + adj.graph[u][v]); edge_num++; // 计算边的数量 } } } // 初始化每个节点的最晚发生时间（VL），结束点的 VL 为 VE[number - 1] std::vector VL(number, VE[number - 1]); // 逆拓扑排序计算每个节点的 VL for (auto it = Topo.rbegin(); it != Topo.rend(); it++) { int u = *it; for (int i = 0; i critical_adjpath; // 遍历拓扑排序中的每个节点，检查哪些弧是关键路径 for (int u = 0; u v，计算其最早开始时间 ET 和最晚开始时间 LT if (adj.graph[u][v] != INT_MAX) { int ET = VE[u]; // 最早开始时间 int LT = VL[v] - adj.graph[u][v]; // 最晚开始时间 // 如果 ET == LT，则该弧是关键路径 if (ET == LT) { // 如果 critical_adjpath 为空，加入首尾节点 if (critical_adjpath.empty()) { critical_adjpath.push_back(u); critical_adjpath.push_back(v); } // 如果首尾节点相接，直接添加尾节点 else if (critical_adjpath.back() == u) { critical_adjpath.push_back(v); } } } } } // 输出项目的最早完成时间 std::cout 最短路径 无权图的单源最短路径问题：BFS BFS过程中，当访问某个顶点时，就确定了该点与源点的最 短距离 通过BFS，从源点开始由近及远求各顶点的最短路径v // 找到无权最短路径，图中所有边权值为1，求点v到其他各个点的最短路径和最短路径长度 // path[i] 记录从 v 到 i 的最短路径上顶点 i 的前驱结点 // dist[i] 记录从 v 到 i 的最短路径长度 void ShortestPath(const Adj_Matrix& adj, int v, std::vector& dist, std::vector& path) { // dist 和 path 的初始化由调用方完成 int number = dist.size(); // 获取图中顶点的数量 // 创建一个队列用于广度优先搜索（BFS） std::queue Q; Q.push(v); // 将起点 v 入队 // 起点到自身的距离为0 dist[v] = 0; // 求 v 到其他各个顶点的最短路径，类似于图的 BFS while (!Q.empty()) { // 处理队头的顶点 u int u = Q.front(); Q.pop(); // 遍历当前点 u 的所有边（邻接节点） for (int i = 0; i i（即图中有连接） if (adj.graph[u][i] != INT_MAX) { int k = i; // 邻接点 k // dist[k] == -1 表示未访问过该节点 if (dist[k] == -1) { // 将未访问的邻接点 k 入队 Q.push(k); // 更新 dist[k] 为 u 到 k 的距离，等于 u 到起点的距离加 1 dist[k] = dist[u] + 1; // 更新 k 的前驱节点为 u path[k] = u; } } } } } 正权图的单源最短路径问题：Dijkstra算法 找到各个局部最优路（任意最短路的前缀，也是一条最短路） 初始化起点到其他点距离 找局部最优路 从局部最优路更新到其他点的距离 重复直到所有点的最优路找到 可以利用优先队列（斐波那契堆）优化找局部最优路的步骤 //利用优先队列维护最短路长度最小的结点，适用于稀疏图 void Dijkstra_ShortestPath_optimize(const Adj_Matrix& adj, int v, std::vector& vis, std::vector& dist, std::vector& path) { //创建优先队列，利用pair分别存放距离，节点,默认T有greater std::priority_queue, std::vector>, std::greater>> pq; //初始化 dist[v] = 0; //放入队列 pq.push({ 0,v }); //直到队列为空则完成 while (!pq.empty()) { //取当前最短路长度最小的结点 std::pair node = pq.top(); pq.pop(); //如果此点已经找到最小路径即局部最优路 int u = node.second; if (vis[u])continue; ////如果有已经更新的最短路径,放弃这个记录 //if (node.first > dist[u])continue; //此操作和上面判断相同 //标记 vis[u] = true; //更新从此点出发的其他点最短路径 for(int i=0;i 正权图的多源最短路径问题 多次Dijkstra算法 Floyd算法（多用于邻接矩阵） 算法通过三重循环来更新最短路径。外层循环通过引入一个中间点 k，判断是否可以通过中间点 k 来缩短从 i 到 j 的路径。 如果通过 k 的路径更短，则更新 dist[i][j]，并且更新前驱节点 path[i][j] 为通过 k 到达 j 的前驱节点。 void Floyd_ShortestPath(const Adj_Matrix& adj) { // 将从Vi到Vj的最短路径长度初始化为邻接矩阵中的值 std::vector> dist, path; // 初始化dist和path，大小与邻接矩阵相同 dist.resize(adj.graph.size(), std::vector(adj.graph.size(), 0)); path.resize(adj.graph.size(), std::vector(adj.graph.size(), -1)); // 初始化dist和path for (int i = 0; i 最小支撑树：边权之和最小的支撑树称为G的最小支撑树 Prim算法（加点法） 选择任一点u做为起点，放入集合S，即令S={u}(u属于V)； 找最小跨集合边(u, v) ，即端点分别属于集合S和V-S且权值 最小的边，将该边加入最小支撑树，并将点v放入S； 执行②，直至S=V // 普里姆算法优化，使用优先队列 Adj_Matrix MiniSpanTree_Prim(const Adj_Matrix& adj, int u = 0 /*起始点*/) { // 非连通图，返回空图 if (Connected_Component(adj) != 1) { return Adj_Matrix(0); } int n = adj.graph.size(); // 图的顶点数 Adj_Matrix MiniSpanTree(n, adj.is_direct); // 最小生成树 // 记录顶点是否已经加入生成树 std::vector vis(n, false); // 使用优先队列（最小堆）保存未加入生成树的点和其对应的最小边权值 // 队列中存储的是 (边权值, 顶点) 的 pair std::priority_queue, std::vector>, std::greater<>> pq; // 初始化：从起始点u开始，加入队列，权值为0 pq.push({0, u}); // 选择其他n-1个顶点，生成n-1条边 while (!pq.empty()) { // 取出当前权值最小的边 int current_weight = pq.top().first; int u0 = pq.top().second; pq.pop(); // 如果顶点u0已经加入生成树，则跳过 if (vis[u0]) continue; // 标记u0为已访问 vis[u0] = true; // 更新最小生成树的边 if (u0 != u) { // 排除起始点 int v0 = pq.top().second; // 顶点u0的前驱 MiniSpanTree.graph[u0][v0] = current_weight; // 无向图则增加对称边 if (!MiniSpanTree.is_direct) { MiniSpanTree.graph[v0][u0] = current_weight; } } // 更新与u0的相邻节点的最小边，并加入优先队列 for (int i = 0; i Kruskal算法（逐边加入）所以不针对邻接矩阵为例 在G中选择权值最小的边，并将此边从G中删除 若该边加入T后不产生环（即此边的两个端点在T的不同连 通分量中），则将此边加入T中，从而使T减少一个连通分 量，否则本步骤无操作，对于是否产生环可以利用并查集 重复①②直至T中仅剩一个连通分量 //克鲁斯卡尔 (Kruskal)算法，可称为“加边法”，适用于稀疏图 //每次选出权值最小并且无法使现有的树形成环的边加入最小支撑树,返回一个图 std::vector MiniSpanTree_Kruskal(std::vector graph,int number) { //非连通图 if (Connected_Component(graph,number) != 1) { return{}; } std::vector MiniSpanTree; //在Edge增加了weight成员存储权值，可以直接用sort排序 std::sort(graph.begin(), graph.end(), [](const Edge& a, const Edge& b)->bool {return a.weight Vexset; Vexset.resize(number,0); //初始化,表示各顶点自成一个连通分址 for (int i = 0; i 排序 定义 排序(Sorting)是按关键字的非递减或非递增顺序对一组记录重新进行排列的操作 排序的稳定性：关键字相同的记录排序前后的相对位置不变 内排序 内部排序的过程是一个逐步扩大记录的有序序列长度的过程。在排序的过程中，可以将排序记录区分为两个区域：有序序列区和无序序列区。 使有序区中记录的数目增加一个或几个的操作称为一趟排序。 插入排序 每一趟将一个待排序的记录，按其关键字的大小插入到已经排好序的一组记录的适当位置上，直到所有待排序记录全部插入为止 插入排序 直接插入排序：将一条记录插入到已排好序的有序表中，从而得到一个新的、 记录数量增1的有序表。 //直接插人排序，O(n^2) //稳定排序,更适合于初始记录基本有序（正序）的情况 //也适用千链式存储结构，只是在单链表上无需移动记录，只需修改相应的指针 template void Straight_Insertion_Sort(T a[], int n) { //对顺序表L做直接插入排序 //数组从0开始，第零个元素已经有序,所以从1开始排序 for (int i = 1; i = 0 && key 折半插入排序：在直接插入排序的基础上优化\"查找\"即找到插入位置，，这个 “查找＂ 操作可利用 “折半查找” 来实现 //折半插人排序，O(n^2) //在已经排序的有序数组里采用二分查找，提高找到插入位置的效率 //稳定排序,适合初始记录无序、n较大时的情况。 //只能用于顺序结构 template void Binary_Insertion_Sort(T a[], int n) { //对顺序表L做折半插入排序 for (int i = 1; i = high + 1; j--)a[j + 1] = a[j]; //插入 a[high + 1] = key; } } 希尔排序（缩小增量排序） 采用分组插入的方法。先将整个待排序记录序列分割成几组，从而减少参与直接插入排序的数据量，对每组分别进行直接插入排序，然后增加每组的数据量，重新分组。 这样 当经过几次分组排序后，整个序列中的记录“基本有序” 时，再对全体记录进行一次直接插入排序。 希尔对记录的分组，不是简单地 ”逐段分割＂，而是将相隔某个 “增量” 的记录分成一组。 具体步骤 将待排序序列分为若干子序列（每个子序列的元素在原始数组中间距相同 对这些子序列进行插入排序 减小每个子序列中元素之间的间距，重复上述过程直至间距减少为1。 //记录跳跃式地移动导致排序方法是不稳定的，只能用于顺序结构 //n越大时，效果越明显。所以适合初始记录无序、n较大时的情况 template void ShellSort(T a[], int n) { //初始化间隔 h，使用 Knuth 序列计算使其小于数组长度的最大值 int h = 1; //生成最大增量 while (h = 1) { //对每一个间隔为 h 的子数组进行插入排序 for (int i = h; i = h && a[i] 可以提前生成增量序列 template void ShellSort_C(T a[], int n,int t,int dk[]) { //dk[]存放着生成好的增量序列 //有多种增量序列 //希尔增量序列（2^k - 1） //Hibbard增量序列（1, 3, 7, 15, ...） //Sedgewick增量序列（1, 5, 19, 41, ...） for (int i = 0; i void Shellinsert_C(T a[], int n,int dk) { int d = dk;//此次增量 //插入排序 for (int i = d; i = 0 && key 交换排序 两两比较待排序记录的关键字，一旦发现两个记录不满足次序要求 时则进行交换，直到整个序列全部满足要求为止。 冒泡排序 通过两两比较相邻记录的关键字， 如果发生逆序，则进行交换，从而使关键字小的记录如气泡一般逐渐往上 ＂漂浮＂ （左移），或者使关键字大的记录如石块一样逐渐向下 ＂坠落” （右移）。 //冒泡排序，O(n^2),当数组为完全逆序时最坏需要比较n*(n-1)/2次 //两两比较相邻记录的关键字，如果发生逆序，则进行交换 //稳定排序,可用于链式存储结构 //当初始记录无序，n较大时 template void Bubble_Sort(T a[], int n) { //设置交换标识,开始时假设有交换 bool flag = true; //只要一趟起泡排序有交换就继续 while (flag) { //假设无交换 flag = false; //遍历找逆序 for (int i = 0; i a[i + 1]) { std::swap(a[i], a[i + 1]); //重置标识 flag = true; } } } } 改进 //一趟比较中，当比较结束，发现从某个位置t开始不再交换，则说明t及以后的记录有序 //从而下一趟比较进行到t即可 template void Bubble_Sort_modify(T a[], int n) { if (n 双向冒泡 //双向冒泡排序，上浮和下沉交替进行 template void Double_Bubble_Sort(T* a, int n) { // 上浮和下沉的区域 int left = 0; int right = n - 1; bool swapped = true; while (left left; i--) { if (a[i] 快速排序 由冒泡排序改进而得的，能通过两个（不相邻） 记录的一次交换消除多个逆序，大大加快排序的速度。 平均情况下，快速排序的时间复杂度为O(n*log2n)。 快速排序是递归的，执行时需要有一个栈来存放相应的数据。最大递归调用次数与递归树的 深度一致，所以最好情况下的空间复杂度为O(log2n），最坏情况下为O(n)。 具体步骤： 待排序的n个记录中任取一个记录（通常取第一个记录）作为枢轴（或支点），又称为基准，经过一趟排序后，将枢轴放置在排序好的的位置，即左边比基准小，右边比基准大，结果将待排序记录分成两个子表，分别 对左、右子表重复上述过程，直至每一子表只有一个记录时 对于快速排序有多个版本，其中取基准的办法也有多种，单趟排序也有不同。 严蔚敏《数据结构》标准分割函数，取待排序的表中第一个记录作为基准，但这样的话，如果待排序的表基本有序或者已经有序，会导致快速排序进入”陷阱“，重新使得记录无序化，时间复杂度变为最坏O(n^2) //严蔚敏《数据结构》标准分割函数 template void Quick_Sort_C(T a[], int left, int right) { int low = left; int high = right; //退出递归 if (low >= high)return; //这里选择第一个作为脊椎 T pivot = a[low]; //类似左右指针 while (low = pivot) --high; //交换 a[low] = a[high]; //左指针右移直到大于基准 while (low 为了避免快排进入\"陷阱\"，对取基准进行改进 选择基准，一般选第一个或者最后一个，但是如果数组本来有序会导致效率低 可以三数取中（即选取第一个、最后一个以及中间的元素中的中位数）或者随机取数，以及中位数中的中位数 下面为取基准的方法，可以优化快速排序 三数取中 int getmid(T array[], int left, int right) { //获取中间值下标 int mid = left + (right - left) / 2; //当leftright if (array[left] > array[right]) { return left; } else { return right; } } } else { //如果mid>right if (array[mid] > array[right]) { return mid; } else { //left>right if (array[left] > array[right]) { return left; } else { return right; } } } } 中位数中的中位数 算法的流程如下： 将整个序列划分为n/5组，每组元素数不超过 5 个； 寻找每组元素的中位数（因为元素个数较少，可以直接使用 插入排序 等算法）。 找出这n/5组元素中位数中的中位数。将该元素作为前述算法中每次划分时的分界值即可。 不考虑实现 随机取数法 //随机法 int getrandom(T array[], int left, int right) { std::random_device rd; // 获取随机设备 std::mt19937 gen(rd()); // 使用 Mersenne Twister 随机数生成器 std::uniform_int_distribution<> size_dis(left, right); return size_dis; } 处理完基准问题，这里给出快排的模板 //进行多趟排序相同一起实现,递归实现 void Sort(T array[], int left, int right) { //退出递归条件 if (left >= right)return; int idxkey = Partion(array, left, right); //继续排序左区间 Sort(array, left, idxkey - 1); //排序右区间 Sort(array, idxkey + 1, right); } //进行多趟排序相同一起实现,非递归实现 //一个栈来保存需要处理的数组区间, //如果某个子数组的元素数量少于等于1，则不需要入栈处理 void SortNoR(T a[], int left, int right) { //工作栈存放左右边界 std::vector> stack; //存放开始左右边界 stack.push_back({ left,right }); //当栈不空 while (!stack.empty()) { //取出左右边界 auto p = stack.back(); stack.pop_back(); ////使用一次单趟的快排得到第一次的基准值 int key = Partion(a, left, right); //将基准值的左右边界入栈 if (key + 1 其中Partion有多个版本，利用多态实现。 前后指针法，现在最常用的方法。 //可以先三数取中交换后，再选取数组的第一个元素作为基准数key template class FroandBack :public QuickSort { //返回左右区间的分界处，此处区间为左右闭区间即[left,right] int Partion(T array[], int left, int right) { int prev = left; int cur = left + 1; //三数取中选定基准后与第一个数交换 int key = QuickSort::getmid(array, left, right); std::swap(array[key], array[left]); int idxkey = left;//当前排序基准位置 while (cur 霍尔快排，最经典的快速排序，多用于教材。 template class Hoare :public QuickSort { int Partion(T array[], int left, int right) { //用三数取中法得到key的位置 int key = QuickSort::getmid(array, left, right); std::swap(array[key], array[left]); //当前排序基准位置 int idxkey = left; while (left = array[idxkey]) --right; //左边右移找较大值 while (left 挖坑法，最容易理解的办法 template class Hole : public QuickSort { int Partion(T* array, int left, int right)//类似于Hoare { //用三数取中法得到key的位置 int idxkey = QuickSort::getmid(array, left, right); std::swap(array[idxkey], array[left]); T key = array[left];//储存基准值 int hole = left;//第一个坑 while (left = key) { --right; } array[hole] = array[right];//填坑 hole = right;//新坑 //左边右移找较大值 while (left 快速排序的改进 三路划分法: 为了解决当数组中存在大量重复元素时，传统的快速排序算法会导致不必要的比较和交换操作数组中存在大量重复元素问题 小的甩到左边，大的甩到右边，与 key 值相等的值则推到中间 最后记录表变为[ begin , left-1 ] [ left , right ] [ right + 1 , end ] template void Quick_Sort_Threeroad(T a[], const int n) { if (n 小区间改造法： 当子区间的大小足够小时，可以考虑使用插入排序来代替递归调用提高效率，并通过设置一个阈值来决定是否使用插入排序 //Insertion_Sort为插入排序 template void Quick_Insert_Sort(T *a, int n) { if (n 10) { Quick_Insert_Sort(a + right, n - right); } else { Insertion_Sort(a + right, n - right); } if (left > 10) { Quick_Sort_Threeroad(a, left); } else { Insertion_Sort(a, left); } return; } 内省排序： 快速排序和 堆排序 的结合 内省排序将快速排序的最大递归深度限制为[log2_n]，超过限制时就转换为堆排序。 这样既保留了快速排序内存访问的局部性，又可以防止快速排序在某些情况下性能退化为 O(n^2)， 快速排序在某些情况下性能退化为 O(n^2)又称为快速排序落入陷阱 //Heap_Sort为堆排序。 template void Introspective_Sort(T* a, int n,int deep) { if (n = 2 * log2(n)) { Heap_Sort(a,n); return; } //类似三路划分 //随机法取基准 const T pivot = a[rand() % n]; // i：当前操作的元素下标 int i = 0; // arr[0, left)：存储小于 pivot 的元素 int left = 0; // arr[right, len)：存储大于 pivot 的元素 int right = n; // 完成一趟三路快排，将序列分为： // 小于 pivot 的元素 | 等于 pivot 的元素 | 大于 pivot 的元素 while (i 选择排序 每一趟从待排序的记录中选出关键字最小的记录，按顺序放在已排 序的记录序列的最后，直到全部排完为止 由于 swap（交换两个元素）操作的存在，选择排序是一种不稳定的排序算法。 简单选择排序（直接选择排序），每趟排序在未排序的记录中找到关键词最小的记录加入有序子表里。 //简单选择排序 (SimpleSelection Sort)也称作直接选择排序。O(n^2) //移动记录次数较少，当每一记录占用的空间较多时，此方法比直接插入排序快。 template void Simple_Selection_Sort(T* a, int n) { //找到n-1次最小值就已经有序了， for (int i = 0; i 堆排序： 利用 二叉堆 这种数据结构所设计的一种排序算法 堆排序的本质是建立在堆上的选择排序 或者说是将待排序的记录a[l..n]看成是一棵完全二叉树的顺序存储结构 具体步骤： 调整数组变为大根堆，自下而上建堆 依次取最大值并重新调整数组为大根堆 ```cpp //首先建立大顶堆,小数往下筛,大数往上浮 template void sift_down(T* a, int start, int end) { //父节点 int parent = start; //子节点，因为从零开始，所以子节点为parent*2+1，parent*2+2（完全二叉树性质 int child = parent * 2 + 1; //存在child,即子节点编号在区间[start,end]内（完全二叉树性质） while (child } //这里为堆排序完整实现 template void Heap_Sort(T* a, int n) { if (n //从最后一个节点的父节点完成堆化，因为数组从零开始，所以最后一个节点为n-1-1，即自下而上建堆。 for (int i = (n - 1 - 1) / 2; i >= 0; i--) { sift_down(a, i, n - 1); } //建完堆 //将第一个元素和已排序的前一位交换，接着重新调整， //将大数往上，小数往下，即重新找到下一个要排序的大数 for (int i = n - 1; i > 0; i--) { //i为要交换的位置，即第n-i大的数 std::swap(a[0], a[i]); //重新调整，但是结束区间不包括已排序值 sift_down(a, 0, i - 1); } } ### 归并排序 两个或两个以上的有序表合并成一个有序表 归并排序的时间复杂度为O(nlog2n)，稳定排序。 具体步骤： > 假设初始序列含有n个记录，则可看成是 n个有序的子序列 > > 每个子序列的长度为1,然后两两归并，得到`[n/2]`个长度为2或1的有序子序列； > > 如此重复，直至得到一个长度为n 的有序序列为止 ```cpp //归并排序最核心的部分是合并（merge）过程： //将两个有序的数组 a[i] 和 b[j] 合并为一个有序数组 c[k]。 template void merge(const T* a, size_t alen, const T* b, size_t blen, T* c) { //三个数组的工作指针 size_t i = 0, j = 0, k = 0; //遍历比较 while (i void merge(const T* a, const T* a_end, const T* b, const T* b_end, T* c) { //三个数组的工作指针 size_t i = 0, j = 0, k = 0; int alen = a_end - a; int blen = b_end - b; //遍历比较 while (i void Merge_Sort(T* a, int l, int r) { //当数组长度为 1 时，该数组就已经是有序的，不用再分解 if (r - l > 1); //分治左右区间 Merge_Sort(a, l, mid); Merge_Sort(a, mid , r); //创建临时数组 T* temp = new T[r - l]; //合并 merge(a + l, a + mid, a + mid, a + r, temp); //返回 for (int i = 0; i 非递归 //倍增法实现非递归的归并排序 template void Merge_sort(T* a, size_t n) { //临时数组 T* temp = new T[n]; //seg表示要合并的段的大小，每次翻倍 for (size_t seg = 1; seg 基于关键词比较的排序算法分析 以上的排序算法是建立在记录关键词比较的基础上，即根据关键词比较结果，变换记录位置实现排序。 平方阶排序算法及改进算法 最坏情况下时间复杂度为平方阶的排序算法称为简单排序算法，包括直接插入、冒泡、交替冒泡、直接选择、对半插入 希尔(Shell)等排序算法 简单排序算法都是通过两层循环实现的。 线性对数阶排序算法 合并排序、快速排序和堆排序算法 结论：基于关键词比较的排序算法下界：O(nlog2n)。即任何基于关键词比较的排序算法在最坏情况下的比较次数都大于等于nlog2n. 分布排序 非基于关键词比较的排序算法，而是基于分配、收集的排序算法，其中分配排序的基本思想为：排序过程无须比较关键字，而是通过\"分配\"和\"收集\"过程来实现排序 时间复杂度可达到线性阶：O(n) 基数排序 元素的关键词由多个域构成，即K=Kd,Kd-1,…,K2,K1 若每个域为英文字母，则关键词即英文单词 若每个域为1位十进制数字(0~9),则关键词即d位十进制数 自K1至Kd（自低位向高位），依次以各域为序进行稳定排序 计数排序 //计数排序,只适用于元素集中于一个范围的排序 template void Counting_Sort(T* elem,int n) { //求最大值和最小值 T max = elem[0]; T min = elem[0]; for (int i = 0; i max)max = elem[i]; if (elem[i] = 0; i--) { //如果有重复元素则位置减一 int idx = --count_a[elem[i] - min]; sorted_a[idx] = elem[i]; } //返回 for (int i = 0; i 桶排序 template void Bucket_Sort(T* elem, int n) { if (n max)max = elem[i]; if (elem[i] > buckets(cnt); //放入桶中 for (int i = 0; i 外排序 排序过程既需要内存储器又需要外存储器 查找 定义 [!note] 查找亦称检索。给定一个文件包含n个记录（或称元 素、结点），每个记录都有一个关键词域。一个查找算法， 就是对给定的值K，在文件中找关键词等于K的那个记录。 查找结果：成功或者失败 平均查找长度：查找一个元素所作的关键词平均比较次数 线性结构查找 顺序查找 从表的一端开始，依次将记录的关键字和给定值进行比较，寻找关键字 既适用于线性表的顺序存储结构，又适用于线性表的链式存储结构 实现简单，仅实现其中数组查找 template int Search_Seq(T* ST,int n, T key) { for (int i = 0; i 改进 //通过为表引入一个“虚拟＂记录key即设置监视哨，并且每次前进步长为二 //通过设置监视哨， 免去查找过程中每一步都要检测整个表是否查找完毕从而减少比较次数，能提高算法S的查找效率 template int Search_Seq_modify(std::vector& ST, T key) { // 放入虚拟记录 ST.push_back(key); int i = 0; while (ST[i] != key) { if (ST[i + 1] != key) { i += 2; // 步长为2 } else { i++; // 步长为1 } } // 返回结果 if (i == ST.size() - 1) { // 查找失败 return -1; } else { // 查找成功，返回索引 return i; } } 二分查找 二分查找要求线性表必须采用顺序存储结构， 而且表中元素按关键字有序排列 有序表Rlow ,Rlow+1 ,…, Rhigh 按照关键词递增有序。 选取一个 位置 mid (low 若: K K > Rmid，[K只可能在Rmid右侧] K = Rmid ，[查找成功结束] 使用不同的规则确定mid，可得到不同的二分查找方法：对半查找、斐波那契查找、插值查找等 对半查找 K与待查表的中间记录进行比较，即mid == (low+high)/2 每次迭代可将查找范围缩小一半。 左闭右闭 // target 是在一个在左闭右闭的区间里，也就是[left, right] //闭区间里，while (left target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target template int Binary_Search(T* a, int left,int right, T key) { int mid; //循坏搜索 while (left > 1); if (key 左闭右开 //定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。 //while (left target) right 更新为 middle，因为当前nums[middle]不等于target template int Binary_Search(T* a, int n, T key) { int left = 0; int right = n; //循坏搜索 while (left > 1); if (key 递归写法 //闭区间递归实现二分查找 template int Binary_Search_Recursive(T* a, int left, int right, T key) { if (left > right) { return -1; // 区间为空，未找到 } int mid = left + ((right - left) >> 1); // 计算中间索引，防止溢出 if (key int Binary_Search_Recursive_Open(T* a, int left, int right, T key) { if (left >= right) { return -1; // 区间为空，未找到 } int mid = left + ((right - left) >> 1); // 防止溢出 if (key 扩展：二叉判定树 便于分析算法的时间效率，采用二叉树表示查找过程 对于 有序表Rlow , Rlow+1 ,…, Rhigh ，对半查找的二叉判定树T(low,high) 的是按如下递归定义的扩充二叉树： 当high-low+1 当high-low+1 > 0时，令mid=(low+high)/2 T(low, high)的根结点是mid ； 根结点的左子树是Rlow ,…,Rmid-1 对应的二叉判定树； 根结点的右子树是Rmid+1 ,…,Rhigh 对应的二叉判定树。 在二叉树中空指针的位置，都增加特殊的结点（空叶结点）， 由此生成的二叉树称为扩充二叉树。称空叶结点为外结点，其余结点为内结点 对半查找算法的每次 成功查找对应判定树 的一个内结点，元素 比较次数为该结点的深度加1，用于计算查找成功的平均查找长度。 每次不成功的查找对应判定树的一个外结 点，关键词的比较次 数为该结点的深度。用于计算查找失败的平均查找长度。 对于对半查找的优化或者改进 一致查找 //一致对半查找， //譬如仅使用三个指针(s、门和e)中的两个。 //其具体思路是，使用当前位置i和它的变化率x,在每次不相等的比较之后，可置i cal_delta(int n) { std::vector delta; // 保存步长 int k = int(log2(n)) + 1; // 计算层数 int temp = 1; for (int i = 0; i int cbiSearch(T* a, int n, int key) { if (n Delta = cal_delta(n); // 生成步长数组 int i = n / 2; int j = 1; // 当前步长索引 while (key != a[i]) // 循环直到找到 key { if (key = Delta.size()|| Delta[j] == 0 ) return -1; // 步长为 0，无法再分割 else { i -= Delta[j]; // 左移 j++; // 步长递减 } } if (a[i] = Delta.size() || Delta[j] == 0)return -1; // 步长为 0，无法再分割 else { i += Delta[j]; // 右移 j++; // 步长递减 } } } return i; // 找到目标，返回下标 } 斐波那契查找 在二分搜索的基础上，根据斐波那契数列分割，而不是简单的二分 前提是待查找的查找表必须顺序存储并且有序 平均和最坏情况下的时间复杂性为O(log2n)。 总体运行时间略快于对半查找算法。 因为算法不涉及乘除法，而只涉及加减法。 //数列从坐标1开始计数 //构造辅助数组，即斐波那契数列，数列生成到大于等于n std::vector Fib_arr(int n) { std::vector Fib; //初始化 Fib.push_back(0); Fib.push_back(1); for (int i = 2;; i++) { int next = Fib[i - 1] + Fib[i - 2]; Fib.push_back(next); if (next - 1 >= n) break; } return Fib; } template int Fibonacci_Search(T* a,int n,T key) { //空表 if (n F = Fib_arr(n); int k = F.size()-1; //如果a数组不足F[k]-1，则重复增加a的最后一个数直到长度等于F[k]-1 std::vector temp{ a,a+n }; //一次性调整 temp 的大小来提高效率 temp.resize(F[k] - 1, temp[n - 1]); //查找，注意这里实现查找区间左边比右边大 //即如果当前区间为F[k]-1=F[k-1]-1 + F[k-2]-1 + 1;最后一个1的位置给mid //左区间为F[k-1]-1, 右区间为F[k-2]-1 while (left 插值查找 基本原理是根据要查找的值在有序数组中的大致位置进行估计，以此来缩小搜索范围 通过数据的分布情况来预测目标值的位置，特别适用于有序且均匀分布的数据集 template int InterPolation_Search(T* a, int n, T key) { if (n right) return -1; if (key 分块查找 分块查找，又称为索引顺序查找 在此查找法中，除表本身以外，尚需建立一个 “索引表”。 对每个子表（或称块）建立一个索引项，其中包括两项内容： 关键字项（其值为该子表内的最大关键字）和指针项（指示该子表的第一个记录在表中位置）。 索引表按关键字有序，则表或者有序或者分块有序，由于块内是无序的，故插入和删除比较容易，无需进行大量移动。 过程 将大数组分成若干子数组（块），每个块中的数值都 比后一块中数值小（块内不要求有序），建一个索引表记录每个子表的起始地址和各块中的最大关键字 先将key依次和索引表中各最大关键字利用对半查找进行比较，确定待查记录所在的块（子表） 确定了关键字所在的块后，从该块的指针项（指示该子表的第一个记录在表中位置）顺序查找 树形结构的查找 [!tip] 对有序数组的二分查找，适用于静态查找场景，若元素动态变化（插入、删除元素），为了维持数组有序，需要O(n)时间调整。 所以就有了树形结构的查找结构 二叉查找树 [!note] 一棵二叉树，其各结点关键词互异，且中根序列按其关键词递增排列 二叉查找树中任一结点P，其左子树中结点的关键词都小于P的关键词，右子树中结点的关键词都大于P的关键词， 且结点P的左右子树也都是二叉查找树。 查找、插入、删除平均时间复杂度O(logn)，但最坏情况时间复杂度为O(n)（根节点为最大节点或者最小结点 template class Tree { public: //数据项 T data;//重载了==运算符和 核心操作 查找：在二叉查找树中查找关键词为K的结点 //在根指针T所指二叉排序树中递归地查找某关键字等于key的数据元素 Tree* SearchBiSortTree(Tree* root, T key) { //二叉排序树为空，则查找失败，返回空指针 if (!root)return nullptr; //key等千T->data.key, 则查找成功，返回根结点地址 if (root->data == key) { return root; } else if (key data)//key小千T->data.key, 则递归查找左子树 { return SearchBiSortTree(root->lchild, key); } else//key大千T->data.key, 则递归查找右子树 { return SearchBiSortTree(root->rchild, key); } } 插入：将关键词为K的结点插入二叉查找树，插入后仍为二 叉查找树，若K已在树中，则该节点大小加一。 //当二叉排序树T中不存在关键字等千e.key的数据元素时,则插入该元素 //注意传入二级指针 void InsertBiSortTree(Tree*& root, T key) { //空树直接将其作为根节点 if (!root) { Tree* temp = new Tree(key); root = temp; } else if (key data)//将*S插入左子树 { InsertBiSortTree(root->lchild, key); } else if (root->data rchild, key); } else//相等说明root存在相同关键字的结点,个数++ { root->count++; return; } //处理size,根的节点数等于左右子树和加上本身个数 root->size = root->count + (root->left ? root->left->size : 0) + (root->right ? root->right->size : 0); // 更新节点的子树大小 return; } 删除：删除关键词为K的结点（如果该结点大小大于一则大小减一），删除后仍为二叉查找树，采用代替法删除 //二叉排序树的删除 //被删除的结点可能是二叉排序树中的任何结点 //删除结点后，要根据其位置不同修改其双亲结点及相关结点的指针，以保持二叉排序树的特性 void DeleteBST(Tree*& root, T key)//因为可能删除根节点，所以传入二级指针 { //空树 if (!root)return; //初始化,目标结点和目标节点的父节点以便查找 Tree* p = root; Tree* pre = nullptr; //查找 while (p) { //找到关键字等于key的结点* p, 结束循环 if (p->data == key)break; //前移 pre = p; //判断往左移还是右移 p = key data ? p->lchild : p->rchild; } //找不到 if (!p)return; //count大于1 if (p->count > 1) { p->count--; } else { //考虑三种情况 //q记录s的前驱 Tree* q = p; Tree* s = p->rchild; //被删结点*p左右子树均不空 if (p->lchild && p->rchild) { //在*p的左子树中继续查找其前驱结点，即最右下结点也是左子树最大节点用以代替被删除节点 //或者找右子树最小节点代替 while (s->rchild) { q = s; s = s->rchild; } //s指向被删结点的 “前驱\",以最大节点替换被删结点 p->data = s->data; //重接*q的右子树 if (q != p)//避免q未移动 { //s左子树的值依旧大于其前驱，并且s作为最大节点一定没有右子树了 q->rchild = s->lchild; } else//重接*q的左子树,未移动则q即是被s替换的p { q->lchild = s->lchild; } delete s; return; } else if (!p->rchild)//被删结点*p无右子树， 只需重接其左子树 { q = p; p = p->lchild; } else if (p->lchild)//被删结点*p无左子树， 只需重接其右子树 { q = p; p = p->rchild; } //将p所指的子树挂接到其双亲结点*f相应的位置 //被删结点为根节点 if (!pre)root = p; else if (q == pre->lchild)//被删结点为前驱的左子树 { //挂接到*f的左子树位置 pre->lchild = p; } else //被删结点为前驱的左子树 { pre->rchild = p; } delete q; } //维护size root->size = root->count + (root->left ? root->left->size : 0) + (root->right ? root->right->size : 0); // 更新节点的子树大小 return; } //递归版本，注意传入二级指针 void remove(Tree*& root,T key) { //空树，或者找不到 if (root == nullptr) { return; } if (root->data rchild, key); } else if (key data) { remove(root->lchild, key); } else//找到 { if (root->count > 1) { root->count--; } else { //左子树为空 if (root->lchild == nullptr) { Tree* temp = root; root = root->rchild; delete temp; return; } //右子树为空 else if (root->rchild == nullptr) { Tree* temp = root; root = root->lchild; delete temp; return; } else { //找到继承者，即左子树最大节点或者右子树最小节点 Tree* successor = findMax(root->lchild); root->data = successor->data; root->count = successor->count; // 当 successor->count > 1时，也应该删除该节点，否则 // 后续的删除只会减少重复数量 successor->count = 1; remove(root->rchild, successor->data); } } } // 继续维护size，不写成 --root->size; // 是因为value可能不在树中，从而可能未发生删除 root->size = root->count + (root->left ? root->left->size : 0) +(root->right ? root->right->size : 0); return; } AVLTree(高度平衡树) 定义 [!note] 一棵满足如下条件的二叉查找树：任意结点的左子树和右子树的高度最多相差1。 即对于任意结点P，| P的左子树高度−P的右子树高度 | AVL树中任意结点P的平衡系数(平衡因子）定义为：P的左子树高度减去右子树高度。从定义可知平衡系数只可能为：-1,0,1 核心操作 [!important] 查找：与普通二叉查找树一致。 插入和删除：先使用二叉查找树的插入/删除方法，但插入/ 删除一个结点后，有可能破坏AVL树的平衡性。因此需对平衡树进行调整，恢复其平衡性，实现这种调整的操作称为“旋转（Rotation）”。 插入新结点X后，若AVL树失去平衡，应调整失去平衡的最小子树，即找从X到根结点的路径上的第一个失衡结点A， 平衡以 A为根的子树。 调整策略： ①LL型：右转 ②RR型：左转 ③LR型：左转+右转 ④RL型：右转+左转 对于插入： 如何找从插入点到根结点的路径中第一个失衡结点A？ ➢ 从根到插入点（自顶向下）：通过递归过程实现； ➢ 从插入点到根（自底向上）：通过递归函数的返回过程（ 回溯）实现。在上一层递归函数返回后，检查当前结点的平衡性。 void Insert(AVLnode* &root, int K) { if(root==NULL) root=new AVLnode(K); else if(K key) //在左子树插入 Insert(root->left, K); else if(K > root->key) //在右子树插入 Insert(root->right, K); ReBalance(root); } //调整平衡 void ReBalance(AVLnode* &t) { if(t==NULL) return; if(Height(t->left)- Height(t->right)==2){ if(Height(t->left->left) >= Height(t->left->right)) LL(t); else LR(t); }else if(Height(t->right)- Height(t->left)==2){ if(Height(t->right->right) >= Height(t->right->left)) RR(t); else RL(t); } UpdateHeight(t); } 对于删除 二叉查找树的删除算法进行删除 沿实际删除点到根结点的路径，向上找第 一个不平衡点为A，平衡以 A为根的子树。 平衡后，可能使子树A高度变小。这样可能导致A的父结点 不满足平衡性。 要继续向上考察结点的平衡性，最远可能至根结点， 即最多需要做O(logn)次旋转 void remove(AVLnode* &root, int K) { if(root==NULL) return; if(Kkey) remove(root->left, K); //在左子树删K else if(K>root->key) remove(root->right, K); //在右子树删K else if(root->left!=NULL && root->right!=NULL){ AVLnode *s=root->right; while(s->left!=NULL) s=s->left; root->key=s->key; //s为t右子树中根序列第一个结点 remove(root->right, s->key); }else{ AVLnode* oldroot=root; root=(root->left!=NULL)? root->left:root->right; delete oldroot; } ReBalance(root); } 总结 AVL树的高度为O(logn)，因此使插入、删除、查找的最坏时间复杂度均为O(logn)。 删除操作最坏情况下需要做O(logn)次旋转，即从删除节点一直维护平衡到根节点 红黑树（Red Black Tree） 红黑树是一种自平衡的二叉搜索树。每个节点额外存储了一个 color 字段 (\"RED\" or \"BLACK\")，用于确保树在插入和删除时保持平衡。 [!tip] 一棵合法的红黑树必须遵循以下五条性质： 节点为红色或黑色(非红即黑) NIL 节点（空叶子节点或者说外结点）为黑色（黑外） 红色节点的子节点为黑色（红父黑子） 从根节点到 NIL 节点的每条路径上的黑色节点数量相同 根结点为黑色； （黑根） 这条性质要求完成插入操作后若根节点为红色则将其染黑，但由于将根节点染黑的操作也可以延迟至删除操作时进行，因此，该条性质并非必须满足。 红黑树类的定义 template > class RBTreeMap { // 排序函数 Compare compare = Compare(); // 节点结构体 struct Node { std::shared_ptr parent,left,right; enum class color{BLACL,RED}; Key key; Value value; }; // 根节点指针 Node* root = nullptr; // 记录红黑树中当前的节点个数 size_t count = 0; } Splay 树 [!note] Splay 树, 或 伸展树，是一种平衡二叉查找树 它通过 Splay/伸展操作 不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，能够在均摊 时间内完成插入，查找和删除操作，并且保持平衡而不至于退化为链。 结构 Splay 树是一棵二叉搜索树，查找某个值时满足性质： 左子树任意节点的值 节点维护信息 rt tot fa[i] ch[i][0/1] val[i] cnt[i] sz[i] 根节点编号 节点个数 父亲 左右儿子编号 节点权值 权值出现次数 子树大小 旋转操作 为了使 Splay 保持平衡而进行旋转操作，旋转的本质是将某个节点上移一个位置。 旋转需要保证： 整棵 Splay 的中序遍历不变（不能破坏二叉查找树的性质）。 受影响的节点维护的信息依然正确有效。 root 必须指向旋转后的根节点。 B树（B-Tree） [!note] B树：平衡m叉查找树。 一个结点存多个关键词，形成多叉查找树来代替 二叉查找树，降低查找树高度。 B树结点结构 包含j个关键词：满足 K1。 包含j+1个指针：第i个指针pi（0 m阶B树的定义 ① 每个结点至多有m个孩子； ② 除根和叶结点外，每个结点至少有[m/2]取下界个孩子； ③ 若根结点不是叶结点，则至少有2个孩子； ④ 有k个孩子的结点恰好包含k-1个递增有序的关键词； ⑤ 所有的叶结点在同一层，不包含任何信息。 [!important] 根和叶以外的结点有[m/2]取下界～m个孩子 根结点有2 ～m个孩子 在 B 树中，有两种节点： 内部节点（internal node）：存储了数据以及指向其子节点的指针。 叶子节点（leaf node）：与内部节点不同的是，叶子节点只存储数据，并没有子节点。是虚拟的结点 指向叶结点的指针是空指针 B树的查找 ①在根结点内查找K，即在其所包含的关键词K1 ,…, Kj 中查找 K（可采用顺序查找或对半查找），找到则查找成功； ②否则，确定K在某个Ki 和Ki+1 之间，于是在指针pi 所指向的 子树里继续查找K，即将pi 所指向的结点读入内存，继续查 找；如果pi 为空，则查找失败。 B树的插入 先查找，在查找失败的位置插入。 若在结点中插入关键词后，结点包含的关键词超过m-1个， 则该结点关键词上溢，需进行分裂操作。 B树的删除 类似于二叉查找树的删除 但是当删除关键词后，若该结点目前包含的关键词个数小于[m/2]-1 称为下溢，则从左（右）兄弟结点中借最大（最小）关键词。 B+ 树 ① 每个结点至多有m个子结点； ② 除根结点外，其它每个非叶结点至少有m/2个子结点； ③ 根结点至少有两个子结点； ④ 包含n个孩子的结点有n个关键词（即每个关键词对应一棵子 树）； ⑤ 每个非叶结点仅包含各孩子的最大关键词及指向各孩子的指 针（每个非叶结点不存放实际的数据记录，可看成索引）； ⑥ 所有叶结点包含全部关键词及指向相应数据记录的指针，且 叶结点按关键词递增的顺序连成一个链表（每个叶结点的指 针指向磁盘上实际数据文件中的记录，也可看成索引）。 [!warning] B树：每个结点存储关键词及其 对应的实际数据 记录（或指针） B+树：只存关键词 散列查找 散列（Hash, 亦称哈希、杂凑） [!note] 哈希表又称散列表，一种以「key-value」形式存储数据的数据结构。 所谓以「key-value」形式存储数据，是指任意的键值 key 都唯一对应到内存中的某个位置。只需要输入查找的键值，就可以快速地找到其对应的 value。 可以把哈希表理解为一种高级的数组，这种数组的下标可以是很大的整数，浮点数，字符串甚至结构体。 哈希函数 ✓自变量K：关键词 ✓函数值h(K)：元素在散列表中的存 储地址（亦称散列地址） ✓作用：把关键词值映射到散列地址 哈希函数应当易于计算，并且尽量使计算出来的索引均匀分布。 冲突 [!warning] 多个不同的关键词具有相同的散列函数值， 即K1!=K2, h(K1)=h(K2) 一些方法来处理冲突 拉链法 拉链法也称开散列法（open hashing）。 拉链法是在每个存放数据的地方开一个链表，如果有多个键值索引到同一个地方，只用把他们都放到那个位置的链表里就行了。查询的时候需要把对应位置的链表整个扫一遍，对其中的每个数据比较其键值与查询的键值是否一致。 若链表很长，可将其替代为跳表或查找树 闭散列法 闭散列方法把所有记录直接存储在散列表中，如果发生冲突则根据某种方式继续进行探查。 线性探查（亦称线性探测）:当发生冲突时，以固定的次序查找表中的记录，直到找到一个关键词为K的结点或者找到一个空位置。 二次探查: 一旦冲突，能更快的跳离“是非之地”，避免聚集 双重探查：从h(K)开始，寻找空地址时，所前进的步长不是固定的，而与K有关， 散列表的删除 懒惰删除 并不真正的删除元素，而是将删除的位置做一个标记，其状态置为“已删除” 实时删除 将位置j清空，然后考察位置j+1到下一个空位前的每一个位置i，看将位置j清空后，是否阻碍查找T[i]的探查路 径，若是则将T[i]前移至空位。 延迟删除 每隔一段时间定期执行一次真正删除， 把标记为“已删除”的结点真正清空 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - data_structure "},"docs/Cpp/":{"url":"docs/Cpp/","title":"Cpp","keywords":"","body":" Cpp Cpp 本目录收集了与 C++ 学习相关的笔记和章节，内容覆盖基础、进阶及实用技巧，便于逐章阅读或查阅特定主题。 C++ 已成为世界上最常用的编程语言之一,但是C++的语法或者新特性一直都在更新，理论是学不完的，所以建议在学习的同时尝试多去实践，多去写代码，可以编写一个管理系统或者一个小游戏，不要只是纸上谈兵，Show me the code [!tip] 建议学习路线：Pre-knowledge -> C++-Primer -> Effective-Modern-C++ -> Modern-Cpp-templates-tutorial 子目录： C++-Primer/：面向系统学习 C++ 基础与进阶的章节笔记。 Effective-Modern-C++/：现代 C++ 的实用建议与注意事项。 Modern-Cpp-templates-tutorial/：关于模板的简明教程。 Pre-knowledge/：学习 C++ 前应掌握或回顾的基础知识。 我的github仓库Cpp 欢迎在仓库内提交 Issue 或 PR 来提供建议和见解 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - Cpp "},"docs/Cpp/C++-Primer/":{"url":"docs/Cpp/C++-Primer/","title":"C++-Primer","keywords":"","body":" C++-Primer C++-Primer 本目录收集了基于《C++ Primer》/C++ 基础与进阶主题的笔记与章节译注，面向想系统学习 C++ 语言及 STL 的读者。 在yuzujr的笔记上完成,所以有问题也可以寻找yuzujr进行咨询。 目录结构： 01_泛型算法 02_关联容器 03_动态内存 04_拷贝控制 05_重载运算与类型转换 06_面向对象程序设计 07_模板与泛型编程 08_标准库特殊设施 09_用于大型程序的工具 10_特殊工具与技术 11_lambda表达式的类型 12_nullptr 章节简介： 01_泛型算法：讲常用的算法和迭代器，告诉你如何在容器里查找、排序和复制数据。 02_关联容器：介绍按键查找的容器（像字典），适合快速查找和去重。 03_动态内存：说明程序如何申请和释放内存，如何避免内存泄漏。 04_拷贝控制：讲对象复制和移动时发生的事，教你如何正确控制对象的行为。 05_重载运算与类型转换：说明如何让自定义类型支持加减等运算，以及如何安全地转换类型。 06_面向对象程序设计：介绍类和对象的基本用法，如何组织代码更清晰。 07_模板与泛型编程：教你写通用的代码，一份代码适配多种数据类型。 08_标准库特殊设施：汇总一些标准库中实用的小工具，能让代码更简洁。 09_用于大型程序的工具：提供面向大项目的实用建议，如模块划分和性能关注点。 10_特殊工具与技术：收集一些进阶技巧和常见问题的解决办法。 11_lambda表达式的类型：讲短小的匿名函数（lambda）如何写，适合做临时小任务。 12_nullptr：解释空指针的用法和注意事项，避免空指针错误。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - C++-Primer "},"docs/Cpp/C++-Primer/01_泛型算法.html":{"url":"docs/Cpp/C++-Primer/01_泛型算法.html","title":"01_泛型算法","keywords":"","body":" C++ 泛型算法详解 迭代器进阶 1. 插入迭代器 (Inserters) 泛型算法结构 1.1 back_inserter 1.2 front_inserter 1.3 inserter 2. 流迭代器 (Stream Iterator) 2.1 istream_iterator 2.2 ostream_iterator 3. 反向迭代器 (Reverse Iterator) 泛型算法结构 1. 迭代器种类 2. 算法形参模式 3. 算法命名规范 (1) 重载形式传递谓词 (2) _if 版本算法 (3) 拷贝与非拷贝版本 4. 特定容器算法 (1) splice 成员函数 (2) 链表特有操作的影响 [TOC] C++ 泛型算法详解 迭代器进阶 迭代器是C++中连接容器和算法的桥梁，了解不同类型的迭代器及其特性对于高效使用泛型算法至关重要。 #include 1. 插入迭代器 (Inserters) 迭代器特性: 左闭合区间 [begin, end)，迭代器末端永远指向最后一个元素之后的位置（尾后位置）。这种设计保证了算法的简洁性和一致性。 泛型算法结构 插入迭代器是一种适配器，它将赋值操作转换为对应容器的插入操作。 1.1 back_inserter 使用容器的 push_back() 方法在容器末尾添加元素。 vector vec; auto it = back_inserter(vec); // 创建一个使用push_back的插入迭代器 *it = 42; // 等价于 vec.push_back(42) 1.2 front_inserter 使用容器的 push_front() 方法在容器开头添加元素（仅适用于支持此操作的容器，如 list 和 deque）。 注意: 使用 front_inserter 会颠倒元素的插入顺序，因为每个新元素都被插入到容器的开头。 list lst; auto it = front_inserter(lst); *it = 1; // lst: [1] *it = 2; // lst: [2, 1] *it = 3; // lst: [3, 2, 1] 1.3 inserter 使用容器的 insert() 方法在指定位置前插入元素。与 front_inserter 不同，inserter 每次插入后会自增迭代器，因此插入顺序与赋值顺序一致。 vector vec = {1, 4, 7}; // 在vec[1]位置(即值为4的元素)之前插入新元素 auto it = inserter(vec, vec.begin() + 1); *it = 2; // vec: [1, 2, 4, 7] *it = 3; // vec: [1, 2, 3, 4, 7] 2. 流迭代器 (Stream Iterator) 流迭代器将流操作与迭代器接口连接起来，允许算法直接从输入流读取数据或向输出流写入数据。 2.1 istream_iterator 从输入流中读取指定类型的数据。 构造方式: 默认构造：创建一个表示结束的迭代器（尾后迭代器） 使用输入流构造：关联到特定输入流 从标准输入读入整数并构造vector: // 方式一：使用循环 istream_iterator in_iter(cin); istream_iterator eof; // 默认构造的迭代器代表输入结束 vector vec; while(in_iter != eof) { vec.push_back(*in_iter++); } // 方式二：直接使用迭代器范围构造 istream_iterator in_iter(cin), eof; vector vec(in_iter, eof); // 从迭代器范围构造vec 使用算法操作流迭代器: // 计算输入的整数序列的总和 istream_iterator in(cin), eof; cout 2.2 ostream_iterator 向输出流写入指定类型的数据。 vector vec = {1, 2, 3, 4, 5, 6, 7, 8, 9}; // 创建输出迭代器，第二个参数是分隔符 ostream_iterator out_iter(cout, \" \"); // 方式一：手动赋值 for (auto i : vec) { *out_iter++ = i; // 输出i并跟一个空格 } cout 3. 反向迭代器 (Reverse Iterator) 反向迭代器颠倒了元素的访问顺序，从容器的最后一个元素开始，向第一个元素方向移动。 主要特点: ++it 移动到前一个元素（向容器开头方向移动） --it 移动到下一个元素（向容器末尾方向移动） 包括 rbegin()、rend()、crbegin()、crend() 成员函数（r 表示反向，c 表示常量） 不能用于单向链表 forward_list 和流迭代器 base() 成员函数可以将反向迭代器转换为对应的正向迭代器 vector vec = {1, 2, 3, 4, 5}; // 使用反向迭代器从尾到头遍历 for (auto it = vec.rbegin(); it != vec.rend(); ++it) { cout ==迭代器特性：左闭合区间，即[---->)，迭代末端永远是尾“后”，保证了算法的简洁和统一。== 泛型算法结构 1. 迭代器种类 每个泛型算法都对其使用的迭代器类型有特定要求。任何算法的最基本特性是它要求其迭代器提供哪些操作。 算法所要求的迭代器操作可以分为5个迭代器类别(iterator category)，每个算法都会对它的每个迭代器参数指明须提供哪些迭代器类型。 输入迭代器 只读，不写，单遍扫描，只能递增 判等(==、!=),递增(++),解引用(*),箭头运算符(->) 输出迭代器 只写，不读，单遍扫描，只能递增 递增(++),解引用(*) 前向迭代器 可读写；多遍扫描，只能递增 输入输出、多次读写、可保存 双向迭代器 可读写；多遍扫描，可递增递减 双向、支持--运算， 随机访问迭代器 可读写；多遍扫描，支持全部迭代器运算 常量时间访问速度 2. 算法形参模式 大多数标准库算法遵循以下四种基本形式之一： alg(beg, end, other_args) 对范围内元素进行操作 alg(beg, end, dest, other_args) dest 是目标位置，算法假定从 dest 开始有足够空间来容纳写入的数据 alg(beg, end, beg2, other_args) 算法假定从 beg2 开始的序列与 beg 和 end 表示的范围至少一样大 alg(beg, end, beg2, end2, other_args) 同时使用两个迭代器范围 3. 算法命名规范 标准库算法的命名遵循一定的模式，理解这些模式有助于记忆和使用算法。 (1) 重载形式传递谓词 许多算法提供接受谓词（predicate）的重载版本： // 不使用谓词，使用默认的相等比较 unique(beg, end); // 使用自定义的比较谓词 unique(beg, end, comp); (2) _if 版本算法 当算法需要接受一个元素值和一个谓词函数作为可选参数时，通常会提供带有 _if 后缀的版本： // 查找特定值 find(beg, end, val); // 查找第一个满足谓词条件的元素 find_if(beg, end, pred); 这种命名方式避免了参数数量相同可能导致的函数重载歧义。 (3) 拷贝与非拷贝版本 有些算法提供两个版本：一个在原序列上直接操作，另一个将结果写入新的目标位置。 // 直接反转原序列 reverse(beg, end); // 将反转后的序列写入目标位置，原序列保持不变 reverse_copy(beg, end, dest); 某些算法甚至同时提供 _copy 和 _if 版本： // 将满足条件的元素从v1拷贝到v2，v1保持不变 // 该示例将非偶数元素（即奇数）从v1拷贝到v2 remove_copy_if(v1.begin(), v1.end(), back_inserter(v2), [](int i) { return i % 2; }); 4. 特定容器算法 某些容器类型（如链表）提供了针对其数据结构特点优化的特殊成员算法，使用这些算法通常比通用泛型算法更高效。 以下是链表（std::list）的一些特殊成员函数： png) (1) splice 成员函数 splice 是链表的一个重要操作，用于将一个链表的元素移动到另一个链表： (2) 链表特有操作的影响 由于链表特有算法的实现机制，这些操作会改变底层容器的结构，可能导致迭代器甚至链表对象本身失效。在使用这些操作时需要特别注意管理迭代器的有效性。 list lst1 = {1, 2, 3}; list lst2 = {10, 20, 30}; auto it = lst1.begin(); ++it; // 指向值2的元素 lst1.splice(lst1.end(), lst2, lst2.begin(), lst2.end()); // 此时lst2为空，lst1包含 {1, 2, 3, 10, 20, 30} // it仍然有效，指向值2的元素 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 01_泛型算法 "},"docs/Cpp/C++-Primer/02_关联容器.html":{"url":"docs/Cpp/C++-Primer/02_关联容器.html","title":"02_关联容器","keywords":"","body":" C++ 关联容器详解 关联容器概述 头文件和容器类型 1. 使用关联容器 1.1 map 容器 1.2 set 容器 1.3 multi 容器 2. 关键字类型的要求 默认排序准则 自定义排序准则 3. pair 类型 pair 的操作 创建和使用pair 4. 关联容器操作 5. 关联容器迭代器 5.1 解引用关联容器迭代器 5.2 set 的迭代器是常量迭代器 5.3 遍历关联容器 5.4 关联容器和泛型算法 6. 添加元素 6.1 pair的四种创建方式 6.2 insert和emplace操作 6.3 检测插入操作的返回值 7. 删除元素 7.1 erase操作 8. map的下标操作 8.1 下标操作和at函数 8.2 下标运算符的特性 9. 访问元素 9.1 查找元素 9.2 处理multimap或multiset中的元素 方法一：使用find和count 方法二：使用lower_bound和upper_bound 方法三：使用equal_range 10. 无序容器 10.1 无序容器的基本原理 10.2 桶管理 10.3 自定义类型的要求 [TOC] C++ 关联容器详解 关联容器概述 关联容器是C++标准库中的一类重要容器，它们将值与键关联起来，并通过键快速访问值。两个主要的关联容器类型是 map 和 set。 C++标准库提供了8种关联容器，它们之间的区别主要体现在三个方面： 容器类型：map（键值对）或 set（仅键） 键的唯一性：键可以重复（multi）或必须唯一 元素顺序：有序存储或无序（哈希表实现）存储 下表展示了8种关联容器的特点： 头文件和容器类型 有序容器： map 和 multimap 定义在 头文件中 set 和 multiset 定义在 头文件中 无序容器： unordered_map 和 unordered_multimap 定义在 头文件中 unordered_set 和 unordered_multiset 定义在 头文件中 1. 使用关联容器 所有关联容器都提供高效的关键字查询和访问操作。关联容器的迭代器都是双向迭代器，支持前向和后向遍历。 1.1 map 容器 map 是键值对（key-value pair）的集合，每个键对应一个值。 map word_count; // 字符串到整数的映射 word_count[\"hello\"] = 1; // 插入键值对 {\"hello\", 1} map 类型通常被称为关联数组（associative array），与普通数组相比，其最大的不同在于下标（键）不必是整数，可以是任何能比较大小的类型。 1.2 set 容器 set 是关键字的简单集合，值就是键，每个键只能出现一次。 set exclude = {\"the\", \"but\", \"and\", \"or\", \"an\", \"a\"}; if (exclude.find(\"the\") != exclude.end()) cout 当我们只需要知道一个值是否存在时，set 是最有用的容器类型。 1.3 multi 容器 带有 multi 前缀的关联容器（multimap, multiset）允许多个元素具有相同的键。 // 允许一个作者有多本书 multimap authors; // 作者到书名的映射 authors.insert({\"Tolkien\", \"The Hobbit\"}); authors.insert({\"Tolkien\", \"The Lord of the Rings\"}); // 同一作者的另一本书 // 允许集合中有重复元素 multiset nums = {1, 3, 5, 7, 1, 3, 1}; // 包含多个1和3 cout 对于普通的 set 和 map，插入重复键的元素不会产生任何效果，而 multiset 和 multimap 则会存储所有具有相同键的多个元素。 2. 关键字类型的要求 关联容器中的关键字必须能够比较大小，以便容器能对元素进行排序和查找。 默认排序准则 默认情况下，标准库使用关键字类型的 运算符进行比较。这意味着： 关键字类型必须定义 运算符 或者，必须提供自定义的比较函数 自定义排序准则 如果要使用自定义的比较方式，可以在模板参数中提供一个函数类型： // 使用自定义的比较函数 bool compareLength(const string &a, const string &b) { return a.size() word_count(compareLength); 自定义的比较函数必须满足严格弱序（strict weak ordering）的要求，确保能够正确排序元素。 3. pair 类型 pair 是一个简单的模板类，用于将两个值组合在一起： 定义在头文件 中 是一个模板：pair 数据成员是 public 的，分别为 first 和 second pair 的操作 创建和使用pair // 几种创建pair的方式 pair word_count1; // 默认构造 pair word_count2(\"hello\", 1); // 提供两个值构造 pair word_count3 = {\"world\", 2}; // 列表初始化 auto p = make_pair(\"C++\", 3); // 自动推断类型 // 访问pair成员 cout 4. 关联容器操作 关联容器除了支持普通容器操作外，还提供了特定于关联容器的操作，如按键查找等。 使用作用域运算符(::)可以访问容器的类型成员，例如 map::key_type 表示 map 的键类型。 5. 关联容器迭代器 关联容器的迭代器有一些特殊性质，了解这些特性对于正确使用它们非常重要。 5.1 解引用关联容器迭代器 当我们解引用一个关联容器的迭代器时，得到的是一个 value_type 类型的值的引用： map::iterator it = word_count.begin(); // *it 是一个 pair& 类型 cout first second 对于 map，value_type 是 pair，第一个成员（键）是常量，不能被修改。 注意：map 的 value_type 是一个 pair，我们可以改变 pair 的值部分，但不能改变关键字部分。 5.2 set 的迭代器是常量迭代器 由于 set 中元素的值就是键，且键是常量，因此 set 的迭代器是常量迭代器，不能用来修改元素值： set iset = {1, 2, 3}; set::iterator it = iset.begin(); // *it = 42; // 错误：set的元素是const的，不能修改 5.3 遍历关联容器 可以使用 begin() 和 end() 操作，以及范围for循环来遍历关联容器： map word_count = {{\"hello\", 1}, {\"world\", 2}}; // 使用迭代器 for (auto it = word_count.begin(); it != word_count.end(); ++it) { cout first second 5.4 关联容器和泛型算法 通常不对关联容器使用泛型算法，原因有两个： 关键字是常量：关联容器的关键字是 const 的，这意味着算法无法修改 set 的元素和 map 元素（pair）的第一个成员，因此不能用于修改或重排容器元素的算法。 查找效率：关联容器提供的查找算法通常比泛型算法快得多，因为它们利用了关联容器的内部结构。 在实际使用中，如果要对关联容器使用算法，通常有两种情况： 将关联容器作为输入源序列 将关联容器作为目标位置（通常需要使用插入迭代器） 6. 添加元素 向关联容器中添加元素通常使用 insert() 方法，可以插入一个元素或一个范围的元素。 6.1 pair的四种创建方式 向 map 添加元素时，我们需要创建键值对（pair）。C++提供了多种创建 pair 的方式： 6.2 insert和emplace操作 关联容器提供了多种插入元素的方法： // 向map中插入元素的不同方式 map word_count; // 方式1：使用insert和value_type word_count.insert(map::value_type(\"hello\", 1)); // 方式2：使用insert和pair word_count.insert(pair(\"world\", 2)); // 方式3：使用insert和花括号列表初始化 word_count.insert({\"C++\", 3}); // 方式4：使用emplace直接构造 word_count.emplace(\"programming\", 4); // 插入范围 map other_words = {{\"book\", 5}, {\"pen\", 6}}; word_count.insert(other_words.begin(), other_words.end()); 6.3 检测插入操作的返回值 对于不允许重复键的容器（map、set），添加单一元素的 insert 和 emplace 返回一个pair： pair 其中： 第一个成员是一个迭代器，指向具有给定键的元素 第二个成员是一个布尔值，如果插入成功则为true，如果键已存在则为false // 检测插入是否成功 auto ret = word_count.insert({\"hello\", 1}); if (ret.second) { cout second 注意：对于允许重复键的容器（multimap、multiset），insert 仅返回指向新插入元素的迭代器，不返回布尔值，因为插入总是成功的。 7. 删除元素 从关联容器中删除元素通常使用 erase() 方法。 7.1 erase操作 关联容器支持三种形式的 erase 操作： 删除指定迭代器指向的元素 删除一个迭代器范围内的所有元素 删除所有匹配特定键的元素（关联容器特有） map word_count = {{\"hello\", 1}, {\"world\", 2}, {\"C++\", 3}}; // 通过迭代器删除 auto it = word_count.find(\"hello\"); if (it != word_count.end()) word_count.erase(it); // 删除\"hello\" // 通过键删除 size_t removed = word_count.erase(\"world\"); // 返回值是1，表示删除了一个元素 // 删除一个范围 word_count.erase(word_count.begin(), word_count.end()); // 清空map 当使用键作为参数调用 erase 时，函数返回实际删除的元素数量。这对于 multimap 和 multiset 特别有用，可以知道有多少具有相同键的元素被删除了。 8. map的下标操作 map 类型提供了下标运算符([])和 at() 函数来直接访问与特定键关联的值。 8.1 下标操作和at函数 map word_count; // 使用下标操作 - 如果键不存在，会创建元素并进行值初始化 word_count[\"hello\"] = 1; // 添加新元素 word_count[\"hello\"]++; // 更新现有元素 // 使用at函数 - 如果键不存在，会抛出异常 try { word_count.at(\"world\")++; // 如果\"world\"不存在，抛出out_of_range异常 } catch (const out_of_range& e) { cout 8.2 下标运算符的特性 重要特性： Set不支持下标操作，因为set的元素本身就是键，没有对应的值可以获取或修改。 下标运算符的自动插入行为： 使用下标运算符时，如果关键字不在map中，会自动创建一个新元素并插入到map中，关联值将进行值初始化（对于内置类型是0，对于类类型调用默认构造函数）。 下标运算符仅适用于非const map： 由于下标操作可能插入新元素，因此只能对非const的map使用下标运算符。 下标操作vs解引用： 下标操作返回 mapped_type 对象（值类型） 解引用迭代器返回 value_type 对象（键值对） // 区别示例 map word_count = {{\"hello\", 1}}; int& count1 = word_count[\"hello\"]; // 下标返回值类型的引用 pair& pair1 = *word_count.find(\"hello\"); // 解引用返回pair的引用 9. 访问元素 关联容器提供了多种访问元素的方法，包括查找特定元素和范围内的元素。 9.1 查找元素 在关联容器中，查找特定键的元素通常使用 find 函数： map word_count = {{\"hello\", 1}, {\"world\", 2}}; auto it = word_count.find(\"hello\"); if (it != word_count.end()) cout first second 对map使用find而非下标操作：如果只是想检查一个键是否存在而不想修改容器，应该使用 find 而非下标操作。下标操作会在键不存在时插入新元素。 9.2 处理multimap或multiset中的元素 对于允许重复键的容器，需要特殊的技术来处理具有相同键的多个元素。 方法一：使用find和count // 在multimap中查找特定作者的所有书籍 string search_item(\"Alain de Botton\"); auto entries = authors.count(search_item); // 获取元素的数量 auto iter = authors.find(search_item); // 获取第一个匹配元素的迭代器 // 遍历所有匹配的元素 while (entries) { cout second 方法二：使用lower_bound和upper_bound lower_bound 返回指向第一个具有给定键的元素的迭代器，upper_bound 返回指向最后一个具有给定键之后位置的迭代器： // 使用迭代器范围查找特定作者的所有书籍 for (auto beg = authors.lower_bound(search_item), end = authors.upper_bound(search_item); beg != end; ++beg) { cout second 方法三：使用equal_range equal_range 函数一次性返回一对迭代器，表示具有给定键的元素范围： // equal_range返回表示范围的迭代器对 auto range = authors.equal_range(search_item); for (auto it = range.first; it != range.second; ++it) { cout second equal_range 返回一个 pair，其中 first 成员等价于 lower_bound 的返回值，second 成员等价于 upper_bound 的返回值。 10. 无序容器 C++11新增了四种无序关联容器（unordered_map、unordered_set、unordered_multimap和unordered_multiset），它们不是使用比较运算符来组织元素，而是使用哈希函数（hash function）和键类型的相等运算符（==）。 10.1 无序容器的基本原理 哈希组织：无序容器使用哈希技术来组织元素，相比于有序容器的树形结构，哈希表通常提供更好的平均查找性能。 基本操作：除了组织方式不同外，无序容器的大部分操作与有序容器相同。所有适用于有序容器的操作（如插入、删除、查找等）都可以用于对应的无序容器。 // 无序容器示例 unordered_map word_count; word_count[\"hello\"] = 1; word_count[\"world\"] = 2; // 查找操作与有序map相同 auto it = word_count.find(\"hello\"); if (it != word_count.end()) cout first second 10.2 桶管理 无序容器在内部组织为一组桶（bucket），每个桶保存零个或多个元素： 哈希过程： 容器使用哈希函数将键转换为哈希值 哈希值决定元素应存储在哪个桶中 所有具有相同哈希值的元素都存储在同一个桶中 性能影响因素： 哈希函数的质量（避免冲突） 桶的数量（足够多以减少冲突） 桶的大小（每个桶中元素过多会降低查找性能） 无序容器提供了一组桶管理函数： // 检查和管理桶 unordered_map word_count; // 填充容器... // 显示容器状态 cout 10.3 自定义类型的要求 要将自定义类型用作无序容器的键，必须满足两个要求： 相等比较：必须定义 == 运算符 哈希函数：必须提供计算哈希值的函数 // 为自定义类型提供哈希支持 struct Person { string name; int age; bool operator==(const Person& p) const { return name == p.name && age == p.age; } }; // 为Person类型定义哈希函数 namespace std { template<> struct hash { size_t operator()(const Person& p) const { return hash()(p.name) ^ hash()(p.age); } }; } // 现在可以使用Person作为键了 unordered_map person_map; 标准库为所有内置类型（包括指针）和一些标准库类型（如string和智能指针）提供了哈希函数。 例如: size_t hasher (const Sales_data &sd) { return hash() ( sd.isbn() );//hash() 产生一个string的hash对象,调用()运算符来运算 sd.isbn() 的hash值. // 推荐：避免不必要的构造或插入时，可以使用 C++17 的 try_emplace。 // try_emplace 只有在键不存在时才构造对应的 mapped_type，且不会发生额外的拷贝或移动。 // 例如： // auto [it, inserted] = word_count.try_emplace(\"new_key\", 42); // if (inserted) cout bookStore (42, hasher, eqOp);//传递hash和==的函数指针 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 02_关联容器 "},"docs/Cpp/C++-Primer/03_动态内存.html":{"url":"docs/Cpp/C++-Primer/03_动态内存.html","title":"03_动态内存","keywords":"","body":" C++ 动态内存管理 本节要点 一、智能指针 1. shared_ptr 基本用法 shared_ptr操作 引用计数 1.1 直接管理内存 1.1.1 new 和 delete 运算符 1.1.2 定位new表达式（placement new） 1.2 智能指针和原始指针的结合使用 从原始指针创建智能指针 自定义删除器 1.3 reset和智能指针的安全修改 使用场景示例 2. 异常安全和内存管理 3. unique_ptr 3.1 基本用法 3.2 使用自定义删除器 3.3 所有权转移 3.4 传递和返回unique_ptr 4. weak_ptr 4.1 基本用法 4.2 使用lock方法安全访问对象 4.3 lock方法的工作原理 4.4 解决循环引用问题 二、动态数组 1. new 和数组 1.1 声明方式： 1.2 初始化： 1.3 释放动态数组 1.4 智能指针和动态数组 2.3 拷贝和填充 [TOC] C++ 动态内存管理 C++的动态内存管理是一个强大但复杂的特性。良好的内存管理对于编写高效、稳定的C++程序至关重要。本章探讨C++中动态内存的分配、使用和释放方法，特别关注现代C++中智能指针的应用。 本节要点 首选使用标准库智能指针（make_shared / make_unique）管理动态资源，避免直接使用裸 new/delete。 shared_ptr 实现共享所有权；unique_ptr 实现独占所有权；weak_ptr 用于观察 shared_ptr 管理的对象且不增加引用计数，常用于打破循环引用。 管理动态数组时，优先使用 unique_ptr 或标准容器（如 std::vector）；若使用 shared_ptr 管理数组，必须提供自定义删除器。 std::allocator 可将内存分配与对象构造分离，适用于需要精细控制内存和对象构造的场景。 一、智能指针 智能指针是C++标准库提供的模板类，用于自动管理动态分配的内存，有效防止内存泄漏和指针悬挂等常见问题。 定义在头文件中 基于RAII（资源获取即初始化）原理设计 C++11引入了三种智能指针：shared_ptr、unique_ptr和weak_ptr 1. shared_ptr shared_ptr是一种共享所有权的智能指针，多个shared_ptr可以指向同一个对象，当最后一个指向该对象的shared_ptr被销毁时，对象才会被释放。 基本用法 // 创建shared_ptr shared_ptr p1; // 默认初始化为空指针 shared_ptr> p2; // 指向list的空指针 shared_ptr p3 = make_shared(42); // 指向值为42的int shared_ptr p4 = make_shared(\"Hello\"); // 指向字符串 // 使用shared_ptr if (p4) { // 检查p4是否为空 cout size() 默认初始化的智能指针保存着一个空指针 解引用一个智能指针返回它指向的对象 make_shared函数是创建shared_ptr的首选方式，它在单次内存分配中同时创建对象和控制块 shared_ptr操作 shared_ptr提供了多种操作方法来管理共享对象： .png) 引用计数 shared_ptr通过引用计数机制跟踪有多少个智能指针共享同一个对象： auto p1 = make_shared(42); // 引用计数为1 auto p2 = p1; // 引用计数增加到2 { auto p3 = p1; // 引用计数增加到3 } // p3离开作用域，引用计数减为2 p1.reset(); // p1不再指向该对象，引用计数减为1 // 当p2离开作用域，引用计数变为0，对象被自动删除 1.1 直接管理内存 除了使用智能指针外，C++也允许程序员直接管理动态内存，但这要求程序员自行确保内存的正确释放，防止内存泄漏和悬挂指针问题。 1.1.1 new 和 delete 运算符 new运算符用于动态分配内存，delete运算符用于释放动态分配的内存： 初始化方式： // 内置类型的初始化 new int; // 默认初始化，值未定义 new int(); // 值初始化为0 new int(42); // 初始化为42 // 类类型的初始化 new string; // 默认初始化为空字符串 new string(); // 同上，值初始化 new string(\"Hello\"); // 初始化为\"Hello\" // C++11的列表初始化 new int{42}; // 初始化为42 new vector{1, 2, 3, 4}; // 初始化为包含1,2,3,4的vector 内存释放： int* p1 = new int(42); // 分配一个int delete p1; // 释放int int* p2 = new int[10]; // 分配10个int的数组 delete[] p2; // 释放数组 1.1.2 定位new表达式（placement new） 定位new表达式允许在预先分配的内存上构造对象，或者传递额外参数给分配函数： 示例： // 使用nothrow选项 int* p = new(nothrow) int(42); // 如果分配失败，返回nullptr而非抛出异常 // 在预先分配的缓冲区上构造对象 char buffer[sizeof(int)]; int* p = new(buffer) int(42); // 在buffer上构造int对象 1.2 智能指针和原始指针的结合使用 智能指针需要与传统的原始指针交互，尤其是与那些使用C风格内存管理的代码协作时。 从原始指针创建智能指针 // 使用原始指针初始化智能指针 int* raw_ptr = new int(42); shared_ptr sp(raw_ptr); // shared_ptr接管内存管理 // 推荐使用make_shared而不是上述方式 auto sp2 = make_shared(42); // 更安全、更高效 自定义删除器 // 为需要特殊清理的资源定义删除器 auto deleter = [](FILE* fp) { fclose(fp); }; shared_ptr fp(fopen(\"data.txt\", \"r\"), deleter); // 当fp离开作用域，会调用deleter来关闭文件 [!WARNING] 所有权转移注意事项 一个动态分配的对象应该只由一种智能指针类型管理。混合使用不同类型的智能指针，或者混用智能指针和原始指针管理同一对象，会导致多重释放或悬挂指针问题。 [!WARNING] 谨慎使用get方法 若使用get()方法获取的原始指针初始化另一个智能指针，会出现两个独立的智能指针（计数器不共享）指向相同的内存，导致未定义行为，通常是对象被释放两次。 shared_ptr p1(new int(42)); // 错误用法：会导致double free shared_ptr p2(p1.get()); // p1和p2各自维护引用计数 1.3 reset和智能指针的安全修改 reset方法允许智能指针指向新对象，同时正确处理原对象的引用计数： // 安全地修改shared_ptr指向的对象 if (!p.unique()) { p.reset(new string(*p)); // 如果有其他shared_ptr指向同一对象，先创建副本 } *p += newVal; // 现在确保p是唯一指向该对象的指针，可以安全修改 // 重置为空或其他对象 shared_ptr p1(new int(42)); p1.reset(); // p1现在为空 p1.reset(new int(1024)); // p1指向新值1024 使用场景示例 // 实现写时复制的字符串类 class CopyOnWriteString { private: shared_ptr text; public: CopyOnWriteString(const string& s) : text(make_shared(s)) {} void modify(const string& newText) { if (!text.unique()) // 如果有其他对象共享此文本 text.reset(new string(*text)); // 创建副本 *text = newText; // 修改文本 } string get() const { return *text; } }; 2. 异常安全和内存管理 智能指针在异常处理中特别有用，因为它们能够自动释放不再需要的内存，防止内存泄漏。 对比原始指针和智能指针在异常情况下的行为： // 使用原始指针 - 可能导致内存泄漏 void f() { int *ip = new int(53); // 如果这里发生异常且未在f中被捕获 // ip指向的内存永远不会被释放 delete ip; // 如果前面有异常，这行代码不会执行 } // 使用智能指针 - 异常安全 void g() { shared_ptr sp(new int(53)); // 即使发生异常，sp也会被正确销毁 // sp指向的内存会被自动释放 } 智能指针也是处理那些具有复杂清理要求（如文件句柄、网络连接等）的资源的理想选择。 [!IMPORTANT] 使用RAII（资源获取即初始化）模式和智能指针是现代C++中管理资源的最佳实践。 3. unique_ptr unique_ptr是一种独占所有权的智能指针，不允许多个指针指向同一对象。它提供了对动态分配资源的专属访问。 3.1 基本用法 // 创建unique_ptr unique_ptr p1(new int(42)); unique_ptr p2 = make_unique(\"Hello\"); // C++14引入的函数 // 使用unique_ptr if (p1) { cout 3.2 使用自定义删除器 unique_ptr支持自定义删除器，但删除器类型是智能指针类型的一部分。 1. 使用函数对象作为删除器 #include #include // 自定义删除器 struct CustomDeleter { void operator()(int* ptr) const { std::cout u1(new int(42)); // 使用自定义删除器 // 当u1离开作用域时，会调用CustomDeleter return 0; } 2. 使用lambda表达式作为删除器 #include #include int main() { auto deleter = [](int* ptr) { std::cout u2(new int(42), deleter); // 使用lambda删除器 // 当u2离开作用域时，会调用lambda删除器 return 0; } 3.3 所有权转移 由于unique_ptr不共享所有权，复制是不允许的，但可以通过移动语义转移所有权： unique_ptr p1(new int(42)); // unique_ptr p2 = p1; // 错误：不允许复制 // 转移所有权 unique_ptr p3 = std::move(p1); // p1现在为空，p3接管了资源 p1 = std::move(p3); // 所有权再次转移回p1，p3现在为空 3.4 传递和返回unique_ptr // 返回unique_ptr unique_ptr createInt(int value) { return unique_ptr(new int(value)); // 可以返回临时unique_ptr // 或者更简洁地 return make_unique(value); // C++14 } // 使用返回的unique_ptr auto p = createInt(42); [!NOTE] 从C++14开始，推荐使用std::make_unique创建unique_ptr，这样更安全且更简洁。 4. weak_ptr weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由shared_ptr管理的对象，但不会影响对象的引用计数。 4.1 基本用法 weak_ptr主要用于解决循环引用问题，以及在不确定对象是否还存在时安全地访问该对象。 // 创建weak_ptr shared_ptr sp = make_shared(42); weak_ptr wp = sp; // wp观察sp指向的对象但不增加引用计数 // 检查对象是否存在并使用 if (shared_ptr locked = wp.lock()) { // 对象仍然存在 cout 4.2 使用lock方法安全访问对象 lock方法是weak_ptr的核心功能，它尝试提升weak_ptr为shared_ptr： #include #include int main() { std::shared_ptr sp = std::make_shared(42); std::weak_ptr wp = sp; // 对象仍存在时的lock if (auto locked_sp = wp.lock()) { std::cout 4.3 lock方法的工作原理 std::weak_ptr::lock方法返回一个std::shared_ptr，具有以下特性： 如果原对象存在：返回一个新的shared_ptr，该指针与其他指向同一对象的shared_ptr共享所有权。引用计数会增加，反映新的shared_ptr的存在。 如果原对象已销毁：返回一个空的shared_ptr（等价于默认构造的shared_ptr）。 临时对象处理：如果调用wp.lock()但不保存返回值，创建的shared_ptr会在语句结束时立即销毁，引用计数会相应减少。 4.4 解决循环引用问题 class Node { public: shared_ptr next; // 强引用可能导致循环引用 weak_ptr parent; // 使用weak_ptr避免循环引用 ~Node() { cout (); auto child = make_shared(); // 建立双向引用 parent->next = child; child->parent = parent; // 使用weak_ptr避免循环引用 // 当我们释放这些指针时，对象能正确释放 // 如果都使用shared_ptr，将导致内存泄漏 return 0; } 二、动态数组 动态数组是在运行时动态分配的一组连续的对象，其大小在编译时不需要知道。C++提供多种管理动态数组的方式。 1. new 和数组 1.1 声明方式： int * pia = new int [ size_t ] ; typedef int arrT [42]; int *p = new arrT; //实际和方式一等效 [!NOTE] 实际上所谓的“动态数组”并不是数组，使用new T []获得的T类型指针ptr，虽然我们可以通过ptr访问申请到的空间，但是不能对它调用 begin或end，也不能用范围 for 语句来处理动态数组中的元素。 1.2 初始化： [!IMPORTANT] [!IMPORTANT] 不能用 auto 分配数组 auto p = new auto[10](1) //错误 [!NOTE] new T[0]是合法的 1.3 释放动态数组 // 错误用法示例（不要这样做，会导致 double free） // shared_ptr p1(new int(42)); // 错误示例（不要这样做）： // shared_ptr p2(p1.get()); // p1 和 p2 各自认为自己拥有该裸指针 -> double free // 正确示例： // auto p2 = p1; // 共享所有权 // weak_ptr wp = p1; // 仅观察，不增加引用计数 // 正确做法：直接复制 shared_ptr 或使用 weak_ptr 来观察 { auto p1 = std::make_shared(42); auto p2 = p1; // 正确，共享同一个控制块，引用计数安全增加 } // 如果只想观察而不影响生命周期，可使用 weak_ptr { auto p1 = std::make_shared(100); std::weak_ptr wp = p1; // 不增加引用计数 if (auto sp = wp.lock()) { // 可以安全地使用 sp } } > 1.4 智能指针和动态数组 使用 unique_ptr 管理 new 分配的数组。 shared_ptr p1 = make_shared(42); // 推荐：使用 make_shared // 错误示例（不要这样做）： // shared_ptr p2(p1.get()); // 错误用法：p1和p2各自维护引用计数 -> double free // 正确做法：共享所有权 auto p2 = p1; // p1 和 p2 共享引用计数 // 或者，仅想观察但不拥有：使用 weak_ptr weak_ptr wp = p1; // 不增加引用计数，仅观察 up.reset(); // 释放并删除数组（调用 delete[]） ![image-20240709134037770](./assets/image-20240709134037770.png) > shared_ptr 本质上仍是一个**单一对象的指针**，因此要使用它管理动态数组，需要**自行定义删除器**。 ![image-20240709134437442](./assets/image-20240709134437442.png) ### 2. allocator 类 > std::allocator 类定义在头文件 memory 中，它帮助我们将**内存分配和对象构造分离**开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。 #### 2.1 new 的局限性： **内存分配和对象构造绑定** 1. 提前分配**并初始化**了可能不需要使用的对象。 2. 对于确实要使用的对象，在初始化时进行了默认初始化，但默认初始化往往不是我们所需要的，重复赋值造成了资源浪费。 3. > [!IMPORTANT] > > 使得没有默认构造函数的类无法动态分配数组 #### 2.2 allocator类的使用 > std::allocator 是一个模板 ````cpp allocator alloc; // 可以分配string的allocator对象 auto const p = alloc.allocate(n); // 分配 n 个未构造的 string 存储空间（未初始化） // 需要手动构造 / 销毁 / 释放： for (size_t i = 0; i 2.3 拷贝和填充 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 03_动态内存 "},"docs/Cpp/C++-Primer/04_拷贝控制.html":{"url":"docs/Cpp/C++-Primer/04_拷贝控制.html","title":"04_拷贝控制","keywords":"","body":" 拷贝控制 1. 拷贝构造函数 本节要点 1. 拷贝构造函数 1.1 拷贝初始化 2. 对象移动 2.1 右值引用 2.2 移动构造函数和移动赋值运算符 2.3 合成的移动操作 2.4 拷贝并交换赋值运算符和移动操作 2.5 移动迭代器 2.6 右值引用和成员函数 2.6.1 引用限定符 2.7 重载和引用函数 2.8 图解 2.9 总结 [TOC] 拷贝控制 拷贝控制操作（copy control）： 拷贝构造函数 拷贝赋值运算符 移动构造函数 移动赋值运算符 析构函数 [!WARNING] 1. 拷贝构造函数 本节要点 拷贝/移动控制成员（拷贝构造、拷贝赋值、移动构造、移动赋值、析构）决定类的资源管理语义。 若类管理资源（裸指针、文件句柄等），应显式管理这五类函数，遵循三/五/零法则。 推荐使用移动语义和 noexcept 标注以提升容器重排性能和异常安全性。 拷贝并交换（copy-and-swap）提供异常安全的赋值实现，适合多数自定义资源类型。 1. 拷贝构造函数 1.1 拷贝初始化 拷贝初始化发生的情况： 用 = 定义变量； std::string a = \"abc\"; 将一个对象作为实参传递给一个非引用类型的形参 从一个返回类型为非引用类型的函数返回一个对象 用花括号列表初始化一个数组中的元素或一个聚合类中的成员 [!IMPORTANT] [!IMPORTANT] 三/五法则 如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符，反之亦然。然而无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。 [!IMPORTANT] [!IMPORTANT] [!IMPORTANT] // 完整的 HasPtr 示例：展示拷贝、移动、拷贝并交换、swap class HasPtr { public: HasPtr(const std::string &s = std::string()) : ps(new std::string(s)), i(0) {} // 拷贝构造 HasPtr(const HasPtr &rhs) : ps(new std::string(*rhs.ps)), i(rhs.i) {} // 移动构造 HasPtr(HasPtr &&rhs) noexcept : ps(rhs.ps), i(rhs.i) { rhs.ps = nullptr; rhs.i = 0; } // 析构 ~HasPtr() { delete ps; } // 拷贝并交换赋值（同时支持拷贝和移动） HasPtr& operator=(HasPtr rhs) noexcept { swap(*this, rhs); return *this; } friend void swap(HasPtr &a, HasPtr &b) noexcept { using std::swap; swap(a.ps, b.ps); swap(a.i, b.i); } private: std::string *ps; int i; }; // 使用示例 void example() { HasPtr h1(\"hello\"); HasPtr h2(\"world\"); h1 = h2; // copy-and-swap h1 = std::move(h2); // move via parameter move-constructed } 2. 对象移动 2.1 右值引用 右值引用代表着： 所引用的对象将要被销毁 该对象没有其他用户 这使得我们可以自由地接管右值引用对象的资源。 [!NOTE] std::move 显式地将一个左值转换为对应的右值引用类型 [!WARNING] 使用 std::move 后的对象称为“移后源对象”，我们承诺了像右值一样使用它，所以除了对它进行赋值或销毁外，我们将不再使用它。 [!WARNING] 2.2 移动构造函数和移动赋值运算符 如果我们希望在自己设计的类使用移动操作，那么就需要为其定义移动构造函数和移动赋值运算符。 移动构造函数应确保： 移后源对象必须可析构、有效（可赋值、可以安全地使用而不依赖其当前值） 同样地，我们的程序也不应该依赖移后源的值，因为它是不确定的。 一旦资源完成移动，源对象必须不再指向被移动的资源。即完成了所有权的转移。 //移动构造函数 StrVec::StrVec(StrVec &&s) noexcept //不抛出任何异常 //接管 s 中的资源 : elements(s.elements), first_free(s.first_free), cap(s.cap) { //确保第一条：销毁无害 s.elements = s.first_free = s.cap = nullptr; } //移动赋值运算符 StrVec &StrVec::operator=(StrVec &&rhs) noexcept { if (this != &rhs) { free(); elements = rhs.elements; first_free = rhs.first_free; cap = rhs.cap; rhs.elements = rhs.first_free = rhs.cap = nullptr; } return *this; } [!NOTE] 为什么移动构造函数的参数没有const？ 拷贝构造使用const的原因是它保证源对象的状态不变，而移动构造代表着所有权的转移，类似于\"窃取\"，移后源将失去原有资源，并且不再使用它的值。 [!NOTE] 前提是它真的不会抛出异常 2.3 合成的移动操作 [!NOTE] [!note] 示例：为自定义类型提供哈希与相等比较器，然后传入容器构造函数。 // 假设有一个 Sales_data 类型，提供 isbn() 成员 struct Sales_data { std::string isbn() const; /* ... */ }; auto hasher = [](const Sales_data &sd) { return std::hash()(sd.isbn()); }; auto eqOp = [](const Sales_data &lhs, const Sales_data &rhs) { return lhs.isbn() == rhs.isbn(); }; // 使用 lambda 类型作为 Hash 和 KeyEqual std::unordered_multiset bookStore(42, hasher, eqOp); 2.4 拷贝并交换赋值运算符和移动操作 class HasPtr { public: // 添加的移动构造函数 HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i) { p.ps = nullptr; } // 赋值运算符既是移动赋值运算符，也是拷贝赋值运算符 HasPtr& operator=(HasPtr rhs) { swap(*this, rhs); return *this; } }; 当函数的形参为非引用类型时，需要创建一个新的对象来保存传递的参数。这个新的对象可以通过拷贝构造函数或移动构造函数来创建。如果提供了移动构造函数且传递的参数是右值或临时对象，编译器将使用移动构造函数；否则，将使用拷贝构造函数。 因此，该参数的拷贝初始化表现为——左值被拷贝，右值被移动 hp = hp2; //拷贝构造，hp2不变 hp = std::move(hp2); //移动构造，hp2成为移后源 巧妙之处在于拷贝并交换（copy and swap）保证了两种情况都是安全且行为正确的。 [!IMPORTANT] 2.5 移动迭代器 std::make_move_iterator 将一个普通迭代器转换为一个移动迭代器。 [!CAUTION] [!CAUTION] 2.6 右值引用和成员函数 [!NOTE] 2.6.1 引用限定符 引用限定符用来限定调用这个函数的对象是左值还是右值。 引用限定符可以是&或&&，分别指出this可以指向一个左值或右值，只能用于（非static）成员函数，且必须同时出现在函数的声明和定义中。 class Foo { public: Foo &operator=(const Foo&) &; // 只能向可修改的左值赋值 // Foo 的其他参数 }; Foo &Foo::operator=(const Foo &rhs) & { // 执行将 rhs 赋予本对象所需的工作 return *this; } [!NOTE] 一个函数可以同时使用 const 和引用限定。但是引用限定符必须跟随在 const 之后： class Foo { public: Foo someMem() const &; //先const再引用限定 } 2.7 重载和引用函数 引用限定符可以区分重载版本。 [!NOTE] 如果我们定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者所有都不加。 class Foo { public: Foo sorted() &&; Foo sorted() const; // 错误：必须加上引用限定符 // Comp 是函数类型的类型别名（参见6.7节，第222页） // 此函数类型可以用来比较 int 值 using Comp = bool(const int&, const int&); Foo sorted(Comp*); Foo sorted(Comp*) const; // 正确：两个版本都没有引用限定符 }; 2.8 图解 拷贝构造 移动构造 2.9 总结 移动构造实际上是一个高效的抽象，在具体实现中涉及到指针的拷贝和一些静态内存的拷贝。移动构造的关键在于尽可能避免昂贵的深拷贝操作，通过转移资源所有权（如指针）来实现更高效的对象管理。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 04_拷贝控制 "},"docs/Cpp/C++-Primer/05_重载运算与类型转换.html":{"url":"docs/Cpp/C++-Primer/05_重载运算与类型转换.html","title":"05_重载运算与类型转换","keywords":"","body":" 1. 重载运算 本节要点 1.1 可重载的运算符 1.2 成员函数或非成员函数 1.3 运算符介绍 1.3.1 算术和关系运算符( + - * / > 1.3.2 相等运算符( == ) 1.3.3 赋值运算符( = ) 1.3.4 下标运算符( [ ] ) 1.3.5 递增和递减运算符(++ --) 1.3.6 成员访问运算符(* ->) 1.3.7 函数调用运算符() 1.4 函数对象 1.4.1 lambda是函数对象 1.4.2 标准库函数对象 1.5 std::function 2. 类型转换 2.1 类型转换运算符 2.2 显式类型转换（explicit） 2.3 避免类型转换二义性 2.4 函数匹配与重载运算符 [TOC] 1. 重载运算 本节要点 什么时候定义成员运算符，什么时候定义非成员运算符（对称性与访问权限）; 常见运算符的推荐签名（例如前置/后置++、operator[]、operator->等）; 对于等价性，优先实现 operator== 并用它实现 operator!=；对于二元算术运算，优先提供非成员 operator+ 以支持隐式类型转换。 谨慎定义类型转换运算符以避免二义性，必要时使用 explicit。 1.1 可重载的运算符 [!NOTE] [!NOTE] 逻辑与、逻辑或：短路求值属性 逗号：求值顺序 取地址：用于类类型对象时的特殊含义 1.2 成员函数或非成员函数 注：一般规则是——如果运算符需要访问类的私有成员，或者其左操作数必须是该类的可修改对象，优先实现为成员函数；否则优先实现为非成员（通常是非成员非友元或友元）以保持对称性和支持隐式类型转换。例如二元算术运算通常实现为非成员。 1.3 运算符介绍 1.3.1 算术和关系运算符( + - * / > [!NOTE] 1.3.2 相等运算符( == ) [!NOTE] 1.3.3 赋值运算符( = ) [!IMPORTANT] 1.3.4 下标运算符( [ ] ) [!IMPORTANT] 1.3.5 递增和递减运算符(++ --) [!IMPORTANT] 区分前置和后置运算符： StrBlobPtr operator++; //前置 StrBlobPtr operator--; StrBlobPtr operator++(int); //后置 StrBlobPtr operator--(int); 显式调用后置运算符 p.operator++(0); //后置 p.operator++(); //前置 1.3.6 成员访问运算符(* ->) class StrBlobPtr { public: //解引用运算符 std::string& operator*() const { auto p = check(curr, \"dereference past end\"); return (*p)[curr]; // (*p)是对象所指的vector } //箭头运算符 std::string* operator->() const { // 将实际工作委托给解引用运算符 return &this->operator*(); } }; 注：重载的箭头运算符应返回指针或提供箭头运算符的类型；返回临时对象会导致未定义行为或临时对象被解引用时悬挂。 特殊的箭头运算符 [!NOTE] 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象 1.3.7 函数调用运算符() 如果类定义了调用运算符，则该类的对象称作函数对象（function object）。因为可以调用这种对象，所以我们说这些对象的“行为像函数一样”。 函数对象常常作为泛型算法的实参。 1.4 函数对象 定义了重载调用运算符的对象 1.4.1 lambda是函数对象 lambda表达式被翻译为一个匿名类的匿名对象、该类含有一个重载的函数调用运算符。 默认情况下lambda不能改变它捕获的变量，因此默认情况下函数调用运算符是一个const成员函数，除非它被声明为可变的。 引用捕获的变量被lambda直接使用 值捕获的变量被lambda拷贝到类内对应的数据成员中 1.4.2 标准库函数对象 定义在 functional 头文件中 一般在算法中使用标准库函数对象，以改变算法的默认行为，或者避免UB： sort( svec.begin(), svec.end(), greater() ); //使降序排列 sort( PStr.begin(), PStr.end(), less() ); 标准库规定，指针的less是定义良好的，而直接使用UB 1.5 std::function 定义在functional头文件中，解决了相同调用形式的可调用对象的类型冲突问题。 // 定义一个 map，其中 key 是操作符，value 是对应的函数对象 std::map> binops = { {\"+\", add}, // 函数指针 {\"-\", std::minus()}, // 标准库函数对象 {\"/\", divide}, // 用户定义的函数对象 {\"*\", [](int i, int j) { return i * j; }}, // 未命名的 lambda {\"%\", mod} // 命名了的 lambda 对象 }; //使用map中的操作符 int a = 10, b = 2; std::cout [!NOTE] 重载函数二义性 虽然重载函数的调用形式不同，但是function无法确定使用者想使用形式匹配的函数还是错误地想使用形式不匹配的重载函数，所以function不能直接存入重载函数的名字，解决方法： 传入函数指针int (*fp)(int, int) = add; 使用lambda表达式[] (int a, int b) {return add(a, b) }; 2. 类型转换 2.1 类型转换运算符 operator type() const; type表示某种可以作为函数返回类型的类型（除了void） 必须是类的成员函数 不能声明返回类型，但是有返回值 形参列表为空 通常应该是const函数 [!NOTE] 实践建议：若一个类型转换可能会在隐式场景下造成二义性或意外转换，请将转换运算符声明为 explicit（C++11 起支持）。对于表示“语义上明确的转换”的函数对象和容器操作，应优先使用显式转换以增加代码可读性和安全性。 2.2 显式类型转换（explicit） [!CAUTION] 显式的类型转换运算符也有可能被隐式执行 被隐式转换为bool类型，用于条件判断 在列表初始化时发生隐式转换 [!NOTE] 这是一个设计决定，而不是错误，在上下文明确时，设计者允许为了代码的简洁性而隐式调用显式的类型转换运算符。 比如，标准库的io类型可以使用while (std::cin >> value)来读入数据直到发生异常或EOF，原因是std定义了istream向bool的显式类型转换，只有在这种特定情况下会隐式调用。 2.3 避免类型转换二义性 不要在两个类之间建立相同的类型转换 比如A类中A->B的类型转换运算符，B类中A->B的构造函数。 //in class A operator B() const {} //in class B B(const A&); 不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换 A(int = 0);//转换源都是算术类型 A(double); operator int() const;//转换目标都是算术类型 operator double() const; void f2(long double); A a; f2(a); //因为无精准匹配，而且int和double转换到long double的转换级别一致，所以产生了\"类型转换二义性\" long lg; A a2(lg); //相同的原因产生了\"构造二义性\" [!IMPORTANT] [!WARNING] 2.4 函数匹配与重载运算符 [!NOTE] [!WARNING] ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 05_重载运算与类型转换 "},"docs/Cpp/C++-Primer/06_面向对象程序设计.html":{"url":"docs/Cpp/C++-Primer/06_面向对象程序设计.html","title":"06_面向对象程序设计","keywords":"","body":" 面向对象程序设计 1. 动态绑定 2.派生类中的虚函数 3. 派生类的初始化 4. 派生类的声明 5. 类型转换与继承 6. 虚函数 7. 访问控制与继承 8. 继承中的类作用域 9. 构造函数与拷贝控制 10. 容器与继承 [TOC] 面向对象程序设计 1. 动态绑定 [!NOTE] [!NOTE] 任何构造函数之外的非静态函数都可以是虚函数 virtual只能出现在类内部的声明语句之前 虚函数的派生隐式地也是虚函数 如果成员函数没被声明为虚函数，则其解析过程发生在编译时而非运行时 2.派生类中的虚函数 class foo { virtual void bar() const &; }; class Foo : public foo { public: void bar() const & override; //使用override关键字显式声明进行了虚函数的覆盖 }; 3. 派生类的初始化 [!NOTE] 4. 派生类的声明 [!NOTE] 基类必须被定义，该规定还有一层隐含的意思，即一个类不能派生它本身 [!NOTE] C++11新标准提供了一种防止继承发生的方法： 在类名后跟一个关键字 final 5. 类型转换与继承 [!NOTE] [!WARNING] 不存在从基类向派生类的隐式类型转换 可以使用dynamic_cast请求一个类型转换，它进行运行时安全检查 Foo F; foo f; foo* pf = &f; Foo* pF = dynamic_cast(pf); if (pF != nullptr) { pF->bar(); } else{//运行时类型检查冲突后返回nullptr print(\"pF is nullptr\"); } 如上，pf实际上指向一个foo对象，dynamic_cast在运行时检查会拒绝转换，返回一个nullptr，如果pf指向一个Foo对象，那么转换成功。 另一种方法是使用static_cast，static_cast不进行运行时检查来确认pf实际上指向一个Foo类型的对象。如果pf不指向Foo类型的对象，使用static_cast进行向下转换可能会导致未定义行为，例如访问无效的内存。 [!warning] 对象之间的类型转换 6. 虚函数 [!NOTE] 可以在函数指定为final，禁止任何尝试覆盖该函数的操作。 class foo { public: virtual void func(int) final {} }; class Foo : public foo { public: void func() { print(\"Foo: func\"); } // 参数列表不同，不是覆盖 // void func(int){} 报错 }; 默认实参 class foo { public: virtual void func(string param=\"foo\") { print(fmt::format(\"foo: param:{}\", param)); } }; class Foo : public foo { public: virtual void func(string param=\"Foo\") { print(fmt::format(\"Foo: param: {}\", param)); } }; void fn() { foo* pf=new Foo; pf->func(); } 如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定 回避虚函数的机制 [!NOTE] 使用作用域运算符 pf->foo::func(); [!WARNING] class foo { public: virtual void recurse() { print(fmt::format(\"foo:recurse\")); return; } }; class Foo : public foo { public: // 错误示例：直接调用同名成员会导致无限递归 virtual void recurse() { recurse(); } // 无限递归（错误示例） // 正确示例：显式调用基类版本以避免递归 // virtual void recurse() { foo::recurse(); } // 正确写法 }; void fn() { foo* pf = new Foo; pf->recurse(); } 纯虚函数 virtual return_type func(args..) = 0; 含有纯虚函数的类是抽象基类 不能创建抽象基类的对象 7. 访问控制与继承 [!IMPORTANT] protected 派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员；对于普通的基类对象中的成员不具有特殊的访问权限。 [!NOTE] 派生类到基类转换的可访问性 友元 class默认私有继承，struct默认公有继承 struct 和 class 唯一的差别就是默认成员访问说明符及默认派生访问说明符；除此之外，再无其他不同之处。 8. 继承中的类作用域 [!NOTE] 可以通过作用域运算符来使用隐藏的成员 [!important] 名字查找先于类型检查 struct Base { int memfcn(); }; struct Derived : Base { int memfcn(int); // 隐藏基类的memfcn }; Derived d; Base b; b.memfcn(); // 调用 Base::memfcn d.memfcn(10); // 调用 Derived::memfcn d.memfcn(); // 错误：参数列表为空的 memfcn 被隐藏了 d.Base::memfcn(); // 正确：调用 Base::memfcn [!NOTE] d.memfcn(); 编译器首先在Derived中查找名字memfcn；最先找到memfcn(int),一旦名字找到，编译器就不再继续查找了，参数列表不匹配，编译器报错。 [!NOTE] 虚函数形参列表必须相同的原因： 9. 构造函数与拷贝控制 [!WARNING] 基类通常应该定义一个虚析构函数 [!NOTE] 虚析构函数将阻止合成移动操作 [!WARNING] [!WARNING] [!NOTE] 继承的构造函数 using Base::Base; 派生类自己的数据成员将被默认初始化。 10. 容器与继承 [!WARNING] 在容器中放置（智能）指针而非对象 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 06_面向对象程序设计 "},"docs/Cpp/C++-Primer/07_模板与泛型编程.html":{"url":"docs/Cpp/C++-Primer/07_模板与泛型编程.html","title":"07_模板与泛型编程","keywords":"","body":" 模板与泛型编程 1. 定义模板 1.1 语法要求 1.2 模板与友元 1.3 模板参数 1.4 成员模板 2. 模板实参推断 2.1 类型转换与模板类型参数 2.2 函数模板显式实参 2.3 尾置返回类型与类型转换 2.4 函数指针和实参推断 2.5 模板实参推断和引用 2.6 理解 std::move 2.7 转发 include include include 二元折叠 总结 [TOC] 模板与泛型编程 1. 定义模板 1.1 语法要求 [!NOTE] /* @brief 翻转函数参数 * * 用于翻转一个两参数的函数的参数顺序并调用之 */ template void flip(F f, T1&& t1, T2&& t2) { f(std::forward(t2), std::forward(t1)); } // 示例 // auto lambda = [](int a, const std::string& b){ /*...*/ }; // flip(lambda, std::string(\"s\"), 42); 1.2 模板与友元 1.3 模板参数 [!NOTE] 使用类的类型成员 使用前加typename 默认模板实参 1.4 成员模板 成员模板不能是虚函数 控制实例化 通过显式实例化来避免在多个文件中实例化相同模板的额外开销。 template void foo(T) {} template void foo(int a);//使用显式指定的模板参数实例化 f template void foo(char a);//用推导出的模板参数‘char’实例化 f [!WARNING] [!NOTE] 实例化定义会实例化所有成员 2. 模板实参推断 2.1 类型转换与模板类型参数 函数模板中可用的类型转换 顶层const无论是在形参中还是在实参中，都会被忽略。 除此之外，编译器会生成一个新的模板实例。 [!NOTE] 2.2 函数模板显式实参 将需要显式指定的模板形参放在前面 template T1 sum(T2,T3); //编译器无法推导T1的类型，需要每次实例化时显式指定。 [!NOTE] 显式指定的实参可以进行正常的类型转换。 template int compare(const T& a,const T& b); long lng; compare(lng, 1024) //1024: int->long compare(lng, 1024) //lng: long->int 2.3 尾置返回类型与类型转换 [!NOTE] 当我们不确定返回结果的准确类型时，可以使用尾置返回类型。 //尾置返回允许我们在参数列表之后声明返回类型 template auto fcn(It beg,It end) ->decltype(*beg) { //处理序列 return *beg;//返回序列中一个元素的引用 } //或者可以直接使用auto作为返回值，让编译器自动推导。 更进一步，也许我们希望返回元素的值而非引用，但是迭代器只能生成元素的引用，为了获得元素本身的类型，我们可以使用标准库的类型转换（type transformation）模板，它们定义在头文件type_traits中。 template auto fcn(It beg, It end) -> typename std::remove_reference::type //std::remove_reference::type是脱去引用后的类型 { return *beg; } 如果不可能（或不必要）转换模板参数，type成员就是模板参数类型本身。 2.4 函数指针和实参推断 当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。 template int compare(const T&, const T&); int (*pf1) (const int&, const int&) = compare; [!NOTE] 2.5 模板实参推断和引用 从左值引用函数参数推断类型 T& 只能接受一个左值 const T& 可以接受任何类型的实参——对象、临时对象、字面常量值。 从右值引用函数参数推断类型 template void f3(T&&); f3(42); //T是int 引用折叠和右值引用参数 template void f3 (T&&); 假定 i 是一个int对象，我们可能认为像 f3 ( i ) 这样的调用是不合法的。毕竟，i 是一个左值，而通常我们不能将一个右值引用绑定到一个左值上。但是，C++语言在正常绑定规则之外定义了两个例外规则，允许这种绑定。这两个例外规则是 move 这种标准库设施正确工作的基础。 第一个例外规则 第一个例外规则影响右值引用参数的推断如何进行。当我们将一个左值传递给函数模板的右值引用参数（如T&&)时，编译器推断模板 类型参数为实参的左值引用类型。因此，当我们调用 f3 (1) 时，编译器推断 T 的类型为 int& ,而非 int 。 第二个例外规则 如果我们间接创建一个引用的引用，则这些引用形成了“折叠”。 对于一个给定类型： X& &、X& && 和 X&& & 都折叠成类型X& 类型X&& &&折叠成X&& [!NOTE] 通常，我们不能直接定义一个引用的引用，但是通过类型别名或通过模板类型参数间接定义是可以的。 typedef int& intLref; int b; intLref& a = b;//a是一个左值引用 typedef int&& intRref; intRref&& c = 42;//c是一个右值引用 template void f3 (T&&); f3(i); //T是int& f3(42);//T是int&& [!NOTE] [!NOTE] 使用右值引用的函数模板通常使用下面的方式进行重载： template void f(T&&); //绑定到非const右值 template void f(const T&);//左值和const右值 2.6 理解 std::move 标准库是这样定义move的： template //模板形参列表 typename std::remove_reference::type&& //返回类型 move (T&& t) { return static_cast::type&&>(t); } 假设我们传递给move一个int左值，T被推断为int&，替换T后函数变为： typename remove_reference::type&& //返回类型 move (int& && t) { return static_cast::type&&>(t); } 显然，remove_reference::type&&>即为int&&，move返回了static_cast(t)，实现了将左值转换为右值。 [!NOTE] 从一个左值static_cast到一个右值引用是允许的 2.7 转发 使用指向模板类型参数的右值引用 使用std::forward保持类型信息 [!NOTE] std::forward的实现 template _GLIBCXX_NODISCARD constexpr _Tp&& //返回类型 forward(typename std::remove_reference::type& __t) noexcept { return static_cast(__t); } typename std::remove_reference::type&& //返回类型 move (int& && t) { return static_cast::type&&>(t); } * @brief 翻转函数参数 * * 用于翻转一个两参数的函数的参数顺序并调用之 */ void flip(F f,T1 &&t1,T2 &&t2) { f(std::forward(t2), std::forward(t1)); } 3. 重载与模板 对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例 候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板。 与往常一样，可行函数（模板与非模板）按类型转换（如果对此调用需要的话）来排序。当然，可以用于函数模板调用的类型转换是非常有限的。 与往常一样，如果恰有一个函数提供比任何其他函数都更好的匹配，则选择此函数。但是，如果有多个函数提供同样好的匹配，则： 如果同样好的函数中只有一个是非模板函数，则选择此函数。 如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一 个模板比其他模板更特例化，则选择此模板。 否则，此调用有歧义。 [!WARNING] const T& 比 T 更通用，但是由于“特例化“规则，当传递一个 const 指针时，会调用 T. [!NOTE] template std::string debug_rep(const T& t) { std::ostringstream ret; ret std::string debug_rep(T* p) { std::ostringstream ret; // std::cout 4. 可变参数模板 可变参数模板定义 可变参数模板时需要在typename或class后面带上省略号「...」 template template void f(T... args); 省略号作用 声明一个参数包T... args，这个参数包中可以包含0到任意个模板参数； 在模板定义的右边，可以将参数包展开成一个一个独立的参数。 带省略号的参数称为“参数包”，它里面包含了0到N（N>=0）个模板参数。 模式：后随省略号且其中至少有一个形参包的名字的模式会被展开 成零个或更多个逗号分隔的模式实例，&args... 中 &args 就是模式 递归函数展开参数包 通过递归函数展开参数包，需要提供一个「参数包展开的函数」和一个「递归终止函数」，递归终止函数正是用来终止递归的 //递归终止函数 template void foo(const T& arg) { print(\"end of call\"); } // 递归终点：当只剩一个参数时更特例化 //参数包展开的函数 template void foo(const T& arg, const Args&... args) { println(\"size of Args: {}\", sizeof...(Args)); println(\"size of args: {}\", sizeof...(args)); foo(args...); // 递归调用,args每次少一个参数 } sizeof...(args)返回参数包参数个数 typename... class...参数包展开 另一例子 #include using namespace std; template T sum(const T& t) { return t; } template T sum(const T& first, const Types&... rest) { return first + sum(rest...); } int main() { cout [!WARNING] 逗号表达式展开参数包 借助「逗号表达式」(逗号表达式是从左往右执行的，返回最右边的值作为整个逗号表达式的值)和「初始化列表」 也就是说：每一个 (std::cout 都会返回 0 #include using namespace std; template void printArg(T t) { cout void expand(Args... args) { int _[] = {(printArg(args), 0)...}; } int main() { expand(1, 2, 3, 4); return 0; } //「C++14的新特性」泛型lambda表达式 expand([](auto i)->void{cout 模板偏特化和递归方式来展开参数包 可变参数模板类的展开一般需要定义两到三个类，包括「类声明」和「偏特化」的模板类 #include using namespace std; // 前向声明,声明这个Sum类是一个可变参数模板 template struct Sum; // 基本定义 template struct Sum { enum { value = Sum::value + Sum::value }; }; // 递归终止 template struct Sum { enum { value = sizeof(Last) }; }; int main() { cout ::value s; // cout 4.1 转发参数包 4.2 模板特例化 [!NOTE] 将特殊的函数定义为一个特例化版本还是一个独立的非模板函数，会影响到函数匹配。 template int compare(const T& v1, const T& v2) { if (v1 int compare(const char* const& p1, const char* const& p2) { return strcmp(p1, p2); } 类模板特例化 // 打开std命名空间，以便特例化std::hash namespace std { template <> //vector的hash函数的特例化 class hash> { public: typedef size_t result_type; typedef vector argument_type; size_t operator()(const vector& s) const; }; //类外定义hash函数 size_t hash>::operator()(const vector& strs) const { size_t res = 114514; for (const auto& str : strs) { res ^= hash()(str); } return res; } } // namespace std 类模板部分特例化 [!NOTE] 引：std::remove_reference类型是通过一系列的特例化版本来完成其功能的。 特例化特定成员函数 5. 折叠表达式 C++17 折叠表达式 语法 ( 形参包 运算符 ... ) (1)//(E1 运算符 (... 运算符 (EN-1 运算符 EN))) ( ... 运算符 形参包 ) (2)//(((E1 运算符 E2) 运算符 ...) 运算符 EN) ( 形参包 运算符 ... 运算符 初值 ) (3)//(E1 运算符 (... 运算符 (EN−1 运算符 (EN 运算符 I)))) ( 初值 运算符 ... 运算符 形参包 ) (4)//((((I 运算符 E1) 运算符 E2) 运算符 ...) 运算符 EN) （其中 N 是包展开中的元素数量） 折叠表达式是左折叠还是右折叠，取决于 ... 是在“形参包”的左边还是右边。 实现Print函数 再需要创建愚蠢的数组对象 _。 template void print(const Args&...args) { ((std::cout 一元折叠 “对于逗号运算符，一元左折叠和一元右折叠没有区别”。 一个非类型模板参数的变量模板来展示在一些情况下左折叠和右折叠是会造成不同结果:右折叠就是先算右边，左折叠就是先算左边。 template constexpr int v_right = (I - ...); // 一元右折叠 template constexpr int v_left = (... - I); // 一元左折叠 int main(){ std::cout 二元折叠 template void print(Args&&... args){ (std::cout 运算符 ... 运算符 这种形式就是二元。 折叠表达式是左折叠还是右折叠，取决于 ... 是在“形参包”的左边还是右边。 // 二元右折叠 template constexpr int v = (I + ... + 10); // 1 + (2 + (3 + (4 + 10))) // 二元左折叠 template constexpr int v2 = (10 + ... + I); // (((10 + 1) + 2) + 3) + 4 std::cout 总结 template auto Reverse(Args&&... args) { std::vector> res{}; bool tmp{ false }; (tmp = ... = (res.push_back(args), false)); return res; } std::vector> res{} \" std::common_type_t 的作用很简单，就是确定我们传入的共用类型，说白了就是这些东西都能隐式转换到哪个，那就会返回那个类型 (tmp = ... = (res.push_back(args), false)); 二元左折叠表达式，根据下面的展开方式： ((((I 运算符 E1) 运算符 E2) 运算符 ...) 运算符 EN) 该函数是将传入的参数进行逆序。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 07_模板与泛型编程 "},"docs/Cpp/C++-Primer/08_标准库特殊设施.html":{"url":"docs/Cpp/C++-Primer/08_标准库特殊设施.html","title":"08_标准库特殊设施","keywords":"","body":" 标准库特殊设施 1. tuple类型 1.1 定义和初始化tuple 访问tuple的成员 关系和相等运算符 1.2 使用tuple返回多个值 2. bitset 类型 2.1 定义和初始化bitset 2.2 bitset操作 3. 正则表达式 3.1 基本使用 指定 regex 对象的选项 指定或使用正则表达式时的错误 正则表达式类和输入序列类型必须匹配 3.2 匹配与 Regex 迭代器类型 使用匹配数据 3.3 使用子表达式 子表达式用于数据验证 3.4 使用regex_replace 只替换输入序列的一部分 控制匹配和格式的标志 4. 随机数 4.1 随机数引擎和分布 分布类型与引擎 使用时间种子 4.2 其他随机数分布 生成随机实数 生成非均匀分布的随机数 5. IO库再探 5.1 格式化输入与输出 使用操纵符（manipulator） 控制输入格式 5.2 未格式化的输入/输出操作 单字节操作 多字节操作 5.3 流随机访问 seek和tell函数 6. 附录 6.1 随机数分布 6.2 随机数引擎 [TOC] 标准库特殊设施 本章将介绍4个标准库设施：tuple、bitset、随机数生成及正则表达式。此外，我们还将介绍IO库中一些具有特殊目的的部分。 1. tuple类型 一个tuple可以有任意数量的成员。当我们希望将一些数据组合成单一对象，但又不想麻烦地定义一个新数据结构来表示这些数据时，tuple是非常有用的。 1.1 定义和初始化tuple 使用tuple的默认构造函数，它会对每个成员进行值初始化； tuple threeD; //值初始化为0 为每个成员提供一个初始值。tuple的这个构造函数是explicit的， 因此我们必须使用直接初始化语法： // 完整示例（可复制到 main 中运行） // #include // #include // #include // using namespace std; // int main(){ // string pattern = \"[[:alpha:]]cei[[:alpha:]]\"; // regex r(pattern, regex::ECMAScript); // string test = \"receipt freind theif receive\"; // smatch m; // if(regex_search(test, m, r)) cout //错误，无法从initializer_list隐式转换到tuple tuple threeD = {1, 2, 3}; //正确 tuple threeD{1, 2, 3}; 使用make_tuple函数 //使用初始值的类型推断tuple的类型 auto item = make_tuple(\"0-999-78345-X\", 3, 20.00); 访问tuple的成员 使用std::get，显式模板实参表示访问第几个成员 auto book = get(item);//0代表第一个成员 [!NOTE] 尖括号内的值必须是整形常量表达式 两个类模板：tuple_size, tuple_element. auto item = make_tuple(1, 2.0, 'c'); typedef decltype(item) trans;//使用decltype获得tuple类型 size_t sz = tuple_size::value; //sz == 3 tuple_element::type ele = 1.0;//ele: double 关系和相等运算符 [!NOTE] tuple逐对比较左侧和右侧的成员 成员数量必须相同 对每对成员使用==运算符必须都是合法的 对每对成员使用 1.2 使用tuple返回多个值 综合利用上述操作即可 2. bitset 类型 std::bitset使得位运算的使用更为容易，并且能够处理超过最长整型类型大小的位集合。bitset类定义在头文件bitset中。 2.1 定义和初始化bitset bitset是一个类模板，具有固定的大小，定义时需指定它包含多少个二进制位： bitset bitvec(1U); //32位，低位为1，其他位为0 2.2 bitset操作 [!NOTE] to_ulong 和 to_ullong 3. 正则表达式 正则表达式(regular expression) 是一种描述字符序列的方法，C++正则表达式库（RE库）是新标准库的一部分，它定义在头文件regex中 3.1 基本使用 // 在英语中，ei这个组合前面只能是c，否则拼写错误 // 下面查找不在字符c之后的字符串ei string pattern(\"[^c]ei\"); //^在这里代表非 pattern = \"[[:alpha:]]*\" + pattern + \"[[:alpha:]]*\"; //[[:alpha:]]代表字母，*匹配0个或多个 regex r(pattern);//正则表达式 string test = \"receipt freind theif receive\";//搜索对象 smatch matchs;//搜索结果 // 参数：从哪来(搜索对象)，到哪去(搜索结果)，做什么(regex) if (regex_search(test, matchs, r)) { std::cout [!NOTE] ^ 在正则表达式中的作用取决于它所处的位置： 行首：当 ^ 在正则表达式的开头时，它表示匹配字符串的开始。例如，^abc 表示匹配以 \"abc\" 开头的字符串。 否定字符集：当 ^ 在方括号 [] 内的字符集的开头时，它表示对字符集的取反（否定）。例如，[^c] 表示匹配任何不是 c 的字符。在这种情况下，^ 的作用是将字符集中的字符进行否定。 指定 regex 对象的选项 默认情况下，ECMAScript 标志被设置 例，使用icase标志查找指定具有拓展名的文件。大多数操作系统都是按大小写无关的方式识别扩展名的，这也是我们使用icase的原因。 // 一个或多个字母或数字后接一个'.'再接\"cpp\"或\"cc\"或\"cxx\" regex r(\"[[:alnum:]]+\\\\.(cpp|cc|cxx)$\", regex::icase); string test1 = \"a.cpp\"; string test2 = \"b.cc\"; smatch match; if (regex_search(test1, match, r)) { cout [!NOTE] alnum代表字母或数字 \\\\.的原因: c++和regex都使用\\作为转义字符，而.在regex中代表匹配任意字符，使用\\.可以保留原意，但因为c++的原因需要使用\\\\来表示\\ $在这里代表字符串末尾 指定或使用正则表达式时的错误 [!NOTE] 所以如果正则表达式存在错误，则会在运行时抛出错误std::regex_error， 它有一个what操作来描述错误，一个名为code的成员用来返回错误代码，code返回的值是由具体实现定义的。 正则表达式类和输入序列类型必须匹配 3.2 匹配与 Regex 迭代器类型 我们可以使用sregex_iterator来获得所有匹配 重写扩展名匹配程序: // 一个或多个字母或数字后接一个'.'再接\"cpp\"或\"cc\"或\"cxx\" regex r(\"[[:alnum:]]+\\\\.(cpp|cc|cxx)\", regex::icase); string test = \"it is a1.cpp, b2.cc and c3.cxx\"; sregex_iterator it(test.begin(), test.end(), r), end_it; while (it != end_it) { println(\"{}\", it->str()); ++it; } 现在程序输出所有匹配项：a1.cpp b2.cc c3.cxx [!NOTE] 空sregex_iterator可以当作尾后迭代器使用 使用匹配数据 匹配类型有两个名为prefix和suffix的成员，分别返回表示输入序列中当前匹配之前和之后部分的ssub_match对象。的成员，一个ssub_match对象有两个名为str和length的成员，分别返回匹配的string和该string的大小。我们可以用这些操作重写语法程序的循环。 while (it != end_it) { println(\"{}\", it->prefix().str()); println(\">>>{}str()); println(\"{}\", it->suffix().str()); ++it; } 这样程序就打印了匹配结果的上下文，还可以用substr()对上下文进行裁剪. 以下是更多有关smatch的操作： 3.3 使用子表达式 正则表达式中的模式通常包含一个或多个子表达式 (subexpression)。一个子表达式是模式的一部分，本身也具有意义。正则表达式语法通常用括号表示子表达式。 匹配对象除了提供匹配整体的相关信息外，还提供访问模式中每个子表达式的能力。子匹配是按位置来访问的。第一个子匹配位置为0，表示整个模式对应的匹配，随后是每个子表达式对应的匹配。 println(\">>>{}str(1));//将上例的输出语句稍加修改 //输出：a1 b2 c3 子表达式用于数据验证 例：筛选美国电话号码 语法知识 要求: 美国的电话号码有十位数字，包含一个区号和一个七位的本地号码。区号通常放在括号里，但这并不是必需的。剩余七位数字可以用一个短横线、一个点或是一个空格分隔，但也可以完全不用分隔符。 //让我们来分步编写这个表达式 // 1. (\\\\()? //左括号 // 2. (\\\\d{3}) //区号 // 3. (\\\\))? //右括号 // 4. ([-. ])? //分隔符 // 5. (\\\\d{3}) //号码前三位 // 6. ([-. ])? //分隔符 // 7. (\\\\d{4}) //号码后四位 下面编写代码： string number = \"(\\\\()?(\\\\d{3})(\\\\))?([-. ])?(\\\\d{3})([-. ])?(\\\\d{4})\"; regex r(number); string test; while (getline(cin, test)) { for (sregex_iterator it(test.begin(), test.end(), r), end_it;it != end_it; ++it) { if (valid(*it)) { println(\"valid: {}\", it->str()); } else { println(\"not valid: {}\", it->str()); }//if (valid(*it)) }//for }//while (getline(cin, test)) 筛选出符合regex的结果后，还要通过valid函数判断 可选的括号是否匹配 分隔符要么使用要么完全不使用 分隔符是否统一 在编写valid函数之前，先了解一些子匹配操作： 该操作的重点是细心讨论所有情况： bool valid(const smatch& m) { if (m[1].matched) { // 如果有左括号 return m[3].matched && (!m[4].matched || m[4].str() == \" \"); // 那么有右括号，并且紧跟下一个号码或者一个空格 } else { //否则无右括号，并且分隔符匹配 return !m[3].matched && m[4].str() == m[6].str(); } } 3.4 使用regex_replace 正则表达式也可以用来将我们找到的序列替换为另一个序列，继续以电话号码为例，我们可能希望电话号码的格式为ddd.ddd.dddd。 下面介绍有关regex_replace的相关操作： 为了匹配上述格式，我们只需要电话号码的第2，5，7个子表达式，即： // 2. (\\\\d{3}) //区号 // 5. (\\\\d{3}) //号码前三位 // 7. (\\\\d{4}) //号码后四位 替换： string fmt = \"$2.$5.$7\";//使用$提取匹配对象中的子表达式 regex r(phone); string number = \"(908) 555-1800\"; println(\"{}\",regex_replace(number, r, fmt)); 只替换输入序列的一部分 使用上面的方法可以替换一个大文件中的电话号码 //before: morgan (201) 555-2368 862-555-0123 drew (973)555.0130 Lee (609) 555-0132 2015550175 800.555-0000 //after: morgan 201.555.2368 862.555.0123 drew 973.555.0130 Lee 609.555.0132 201.555.0175 800.555.0000 这就是正则表达式的强大之处。 控制匹配和格式的标志 例，使用format_no_copy修改上例中的代码： //before: //morgan (201) 555-2368 862-555-0123 //drew (973)555.0130 //Lee (609) 555-0132 2015550175 800.555-0000 string fmt = \"$2.$5.$7\\n\";// \\n增加可读性 println(\"{}\", regex_replace(test, r, fmt, regex_constants::format_no_copy)); //最终的结果更为直观了: //201.555.2368 //862.555.0123 //973.555.0130 //609.555.0132 //201.555.0175 //800.555.0000 其余标志在这里不做展开。 练习 17.26 int main() { //r为regex //input为读入的一行数据 std::sregex_iterator it(input.begin(), input.end(), r), end_it; // 使用std::distance计算匹配的电话号码数量 int count = std::distance(it, end_it); // 重新初始化迭代器 it = std::sregex_iterator(input.begin(), input.end(), r); // 遍历匹配结果并输出 for (int i = 0; it != end_it; ++it, ++i) { if (count == 1 || i > 0) { std::cout str() [!NOTE] std::distance基于operator++获得两迭代器之间的距离 由于 std::distance 已经耗尽了迭代器，需要重新初始化它。 4. 随机数 rand函数有一些问题: 不同范围的随机数 非均匀分布的数 而程序员为了解决这些问题而试图转换rand生成的随机数的范围、类型或分布时，常常会引入非随机性。 定义在头文件random中的随机数库通过一组协作的类来解决这些问题：随机数引擎类(random-number engines)和随机数分布类(random-number distribution)。 [!NOTE] 4.1 随机数引擎和分布 随机数引擎是函数对象类，”调用“它返回一个随机unsigned整数 default_random_engine实际上是一个类型别名，它一般是最通用的随机数引擎，在gcc-std中它实际是:linear_congruential_engine default_random_engine e; print(\"{}\",e()); 分布类型与引擎 default_random_engine e; uniform_int_distribution u(0, 9); for (size_t i = 0; i [!NOTE] [!WARNING] 使用时间种子 [!WARNING] 4.2 其他随机数分布 生成随机实数 uniform_real_distribution u(0, 1); 生成非均匀分布的随机数 正态分布 normal_distribution default_random_engine e; normal_distribution<> u(4, 1.5); vector vals(9); for (size_t i = 0; i 伯努利分布 bernoulli_distribution 普通类，返回bool值，默认true和false的概率各为0.5。接受一个参数_p指定返回true的概率。 [!WARNING] [!NOTE] 更多的分布模板在附录中 5. IO库再探 5.1 格式化输入与输出 使用操纵符（manipulator） [!NOTE] 很多操纵符改变格式状态 通常最好在不再需要特殊格式时尽快将流恢复到默认状态。 控制布尔值的格式 cout 指定整型值的进制 /* hex: 16进制 oct: 8进制 dec: 10进制 */ [!NOTE] [!NOTE] 使用showbase在输出中显示进制，noshowbase还原 前导0x表示十六进制。 前导0表示八进制。 无前导字符串表示十进制。 [!NOTE] 使用uppercase输出大写十六进制数，nouppercase还原 控制浮点数格式 指定打印精度 使用precision成员或setprecision操纵符 [!NOTE] 指定浮点数计数法 scientific：科学计数法 fixed：定点十进制 hexfloat：十六进制 defaultfloat：恢复默认状态 打印小数点 showpoint强制打印小数点，noshowpoint恢复 输出补白 setw指定下一个数字或字符串值的最小空间。 left表示左对齐输出。 right表示右对齐输出，右对齐是默认格式。 internal控制负数的符号的位置，它左对齐符号，右对齐值，用空格填满所有中间空间。 setfill允许指定一个字符代替默认的空格来补白输出。 [!NOTE] 控制输入格式 noskipws令cin读取空白符，skipws恢复 5.2 未格式化的输入/输出操作 未格式化的输入/输出操作允许我们将一个流当作一个无解释的字节序列来处理。 单字节操作 [!NOTE] 一般情况下，在读取下一个值之前，标准库保证我们可以退回最多一个值。即，标准库不保证在中间不进行读取操作的情况下能连续调用putback或unget。 [!NOTE] 返回int值的原因 这些函数返回一个int的原因是：可以返回文件尾标记。我们使用char范围中的每个值来表示一个真实字符，因此，取值范围中没有额外的值可以用来表示文件尾。 多字节操作 [!WARNING] 比如使用get获取一行，但是换行符还在流中。 [!NOTE] 应该在任何后续未格式化输入操作之前调用gcount。 5.3 流随机访问 [!NOTE] [!WARNING] seek和tell函数 [!NOTE] 只有一个标记 6. 附录 6.1 随机数分布 6.2 随机数引擎 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 08_标准库特殊设施 "},"docs/Cpp/C++-Primer/09_用于大型程序的工具.html":{"url":"docs/Cpp/C++-Primer/09_用于大型程序的工具.html","title":"09_用于大型程序的工具","keywords":"","body":" 用于大型程序的工具 1. 异常处理 1.1 抛出异常 栈展开 栈展开过程中对象被自动销毁 异常对象 1.2 捕获异常 查找匹配的处理代码 重新抛出 捕获所有异常的处理代码 1.3 函数try语句块与构造函数 1.4 noexcept异常说明 异常说明的实参 noexcept运算符 异常说明与指针、虚函数和拷贝控制 1.5 异常类层次 2. 命名空间 2.1 命名空间定义 每个命名空间都是一个作用域 命名空间可以是不连续的 模板特例化 全局命名空间 嵌套的命名空间 未命名的命名空间 2.2 使用命名空间成员 命名空间的别名 using声明（declaration） using指示（directive） 2.3 类、命名空间与作用域 实参相关的查找与类类型形参 友元声明与实参相关的查找 2.4 重载与命名空间 与实参相关的查找与重载 重载与 using 声明/指示 3. 多重继承与虚继承 3.1 多重继承 多重继承的派生类从每个基类中继承状态 派生类构造函数初始化所有基类 继承的构造函数与多重继承 析构函数与多重继承 多重继承的派生类的拷贝与移动操作 3.2 类型转换与多个基类 基于指针类型或引用类型的查找 3.3 多重继承下的类作用域 3.4 虚继承 使用虚基类 3.5 构造函数与虚继承 虚继承的对象的构造方式 构造函数与析构函数的次序 [TOC] 用于大型程序的工具 1. 异常处理 异常处理(exception handling)机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。异常使得我们能够将问题的检测与解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。检测环节无须知道问题处理模块的所有细节，反之亦然。 1.1 抛出异常 当执行一个throw时： 沿着调用链的函数可能会提早退出。 一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁。 栈展开 简而言之就是在包含throw语句的try语句块中找与之关联的catch子句，如果没找到就继续沿栈返回（调用逆序）寻找，这个过程被称为栈展开（stack unwinding）。 假设找到了一个匹配的catch子句，则程序进入该子句并执行其中的代码。当执行完这个catch子句后，找到与try块关联的最后一个catch子句之后的点，并从这里继续执行。 try块可以关联多个catch子句 如果一直没找到匹配的catch，退出main函数后查找过程终止，程序将调用标准库函数terminate，终止程序。 [!NOTE] 栈展开过程中对象被自动销毁 这意味着类类型的析构函数会自动调用，这里有一个隐含前提。 析构函数不应该抛出不能被它自身处理的异常 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。 示例实践：保证析构函数不抛出异常 struct FileGuard { FILE* f; FileGuard(const char* path): f(std::fopen(path, \"r\")) {} ~FileGuard() noexcept { // 保证不会向上抛出异常 if (f) { // 使用 noexcept-safe 的清理代码 std::fclose(f); f = nullptr; } } }; [!WARNING] 异常对象 编译器对异常对象进行拷贝初始化，所以throw语句中的表达式必须拥有完全类型。 如果是类类型，则相应的类必须含有一个可访问的析构函数和一个可访问的拷贝或移动构造函数。 数组类型或函数类型将被转换为对应的指针类型。 不应抛出指向局部对象的指针。 异常对象的类型取决于表达式的静态编译时类型 [!WARNING] 1.2 捕获异常 异常声明可以是左值引用，但不能是右值引用 通常情况下，如果catch接受的异常与某个继承体系有关，则最好将catch的参数定义成引用类型 静态类型决定catch语句所能执行的操作 查找匹配的处理代码 在搜寻catch语句的过程中，挑选出来的应该是第一个与异常匹配的catch语句。因此，越是专门的catch越应该置于整个catch列表的前端。 绝大多数类型转换都不被允许： 允许从非常量向常量的类型转换，也就是说，一条非常量对象的throw语句可以匹配一个接受常量引用的catch语句。 允许从派生类向基类的类型转换。 数组被转换成指向数组（元素）类型的指针，函数被转换成指向该函数类型的指针。 [!NOTE] 重新抛出 在catch语句中使用throw; catch (my error &eobj) { //引用类型 eobj.status = errCodes::severeErr; //修改了异常对象 throw; //异常对象的status成员是severeErr } catch (other error eobj) { //非引用类型 eobj.status = errCodes::badErr; //只修改了异常对象的局部副本 throw; //异常对象的status成员没有改变 } 捕获所有异常的处理代码 catch(...)称为捕获所有异常（catch all） try { throw 1; } catch (std::exception) { print(\"caught an exception\"); } catch (...) { print(\"caught 1\"); } //output: caught 1 [!NOTE] 1.3 函数try语句块与构造函数 [!NOTE] 为处理构造函数初始值列表中抛出的异常，我们必须将构造函数写成函数try语句块（也称为函数测试块，function try block）。 foo::foo(int i) try:data(i) { } catch(const std::exception &e){ handle(e); } 还有一种情况值得读者注意，在初始化构造函数的参数时也可能发生异常，这样的异常不属于函数try语句块的一部分。函数try语句块只能处理构造函数开始执行后发生的异常。和其他函数调用一样，如果在参数初始化的过程中发生了异常，则该异常属于调用表达式的一部分，并将在调用者所在的上下文中处理。 1.4 noexcept异常说明 对于一个函数来说，noexcept说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。 该说明应该在函数的尾置返回类型之前。 我们也可以在函数指针的声明和定义中指定noexcept.。在typedef或类型别名中则不能出现noexcept。 在成员函数中，noexcept说明符需要跟在const及引用限定符之后，而在final、override或虚函数的=0之前。 复习：引用限定符（&）用来限定调用这个函数的对象是左值还是右值。 virtual void foo() const && noexcept final{} //修饰符参考顺序 noexcept可以用在两种情况下： 确认函数不会抛出异常 不知道该如何处理异常 [!WARNING] 通常情况下，编译器不能也不必在编译时验证异常说明。如果声明为noexcept的函数抛出了异常，程序会调用terminate终止，以确保不在运行时抛出异常的承诺。对是否执行栈展开未做约定。 异常说明的实参 noexcept说明符接受一个可选的实参，该实参必须能转换为bool类型：如果实参是true,则函数不会抛出异常：如果实参是false,则函数可能抛出异常： void recoup(int) noexcept(true);//recoup不会抛出异常 void alloc(int) noexcept(false);//a11oc可能抛出异常 noexcept运算符 noexcept运算符是一个一元运算符，它的返回值是一个bool类型的右值常量表达式，用于表示给定的表达式是否会抛出异常。和sizeof类似，noexcept也不会求其运算对象的值。 [!NOTE] 异常说明与指针、虚函数和拷贝控制 指针： 函数指针及该指针所指的函数必须具有一致的异常说明。也就是说，如果我们为某个指针做了不抛出异常的声明，则该指针将只能指向不抛出异常的函数。相反，如果我们显式或隐式地说明了指针可能抛出异常，则该指针可以指向任何函数，即使是承诺了不抛出异常的函数也可以： //recoup和pf1都承诺不会抛出异常 void (*pfl)(int) noexcept = recoup; //正确：recoup不会抛出异常，pf2可能抛出异常，二者之间互不干扰 void (*pf2)(int) = recoup; pf1 = alloc; //错误：alloc可能抛出异常，但是pf1已经说明了它不会抛出异常 pf2 = alloc; //正确：pf2和alloc都可能抛出异常 虚函数： 如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺：与之相反，如果基类的虚函数允许抛出异常，则派生类的对应函数既可以允许抛出异常，也可以不允许抛出异常。 拷贝控制： 当编译器合成拷贝控制成员时，同时也生成一个异常说明。如果对所有成员和基类的所有操作都承诺了不会抛出异常，则合成的成员是noexcept的。如果合成成员调用的任意一个函数可能抛出异常，则合成的成员是noexcept(false)。而且，如果我们定义了一个析构函数但是没有为它提供异常说明，则编译器将合成一个。合成的异常说明将与假设由编译器为类合成析构函数时所得的异常说明一致。 1.5 异常类层次 2. 命名空间 2.1 命名空间定义 [!NOTE] namespace { ... } // C++17 支持嵌套命名空间的简写 namespace A::B::C { void f(); } 每个命名空间都是一个作用域 和其他作用域类似，命名空间中的每个名字都必须表示该空间内的唯一实体。因为不同命名空间的作用域不同，所以在不同命名空间内可以有相同名字的成员。 命名空间可以是不连续的 参考std命名空间 [!NOTE] 模板特例化 全局命名空间 ::member_name; 嵌套的命名空间 namespace cpp { namespace cpp98 {//普通嵌套 //使用cpp98的内容需要使用cpp::cpp98::name; } inline namespace cpp23{//内联嵌套 //cpp命名空间内可以直接访问cpp23内容 cpp::name; } } 未命名的命名空间 变量具有静态生命周期 不能跨文件 名字可以直接使用 作用域与该命名空间所在的作用域相同 [!NOTE] [!WARNING] 2.2 使用命名空间成员 命名空间的别名 namespace primer = cplusplus_priemr; [!NOTE] using声明（declaration） using std::string; using指示（directive） using namespace std; [!WARNING] 2.3 类、命名空间与作用域 [!NOTE] 实参相关的查找与类类型形参 std::string s; std::cin >> s; 思考上面的代码，我们可能已经对>>（输入运算符）习以为常，string 在std中重载了该运算符用于输入一个字符串，这个调用等价于operator>>(std::cin,s);，那么问题是，为什么我们不显式使用std::限定符就可以调用operator>>？ 对于命名空间中名字的隐藏规则来说有一个重要的例外，它使得我们可以直接访问输出运算符。这个例外是，当我们给函数传递一个类类型的对象时，除了在常规的作用域查找外还会查找实参类所属的命名空间。这一例外对于传递类的引用或指针的调用同样有效。 友元声明与实参相关的查找 2.4 重载与命名空间 与实参相关的查找与重载 编译器在每个实参类(以及实参类的基类)所属的命名空间中搜寻候选函数。在这些命名空间中所有与被调用函数同名的函数都将被添加到候选集当中，即使其中某些函数在调用语句处不可见也是如此： 例如： 假设你定义了一个与标准库名字冲突的函数print，你为了不报错而没有使用using namespace std;，奇怪的是，给它传递一个非std内定义的参数时没有问题，但是一旦传递类似std::string这样的参数就会发生调用冲突，原因就是实参所在的命名空间查找，把std::print也纳入了候选函数，如果没有更好的匹配就会产生二义性。 重载与 using 声明/指示 一个using声明引入的函数将重载该声明语句所属作用域中已有的其他同名函数。如果using声明出现在局部作用域中，则引入的名字将隐藏外层作用域的相关声明。如果using声明所在的作用域中已经有一个函数与新引入的函数同名且形参列表相同，则该using声明将引发错误。除此之外，using声明将为引入的名字添加额外的重载实例，并最终扩充候选函数集的规模。 与using声明不同的是，对于using指示来说，引入一个与已有函数形参列表完全相同的函数并不会产生错误。此时，只要我们指明调用的是命名空间中的函数版本还是当前作用域的版本即可。 3. 多重继承与虚继承 3.1 多重继承 多重继承的派生类从每个基类中继承状态 派生类构造函数初始化所有基类 基类的构造顺序与派生列表中基类的出现顺序保持一致，而与派生类构造函数初始值列表中基类的顺序无关。 以上图为例，初始化顺序为ZooAnimal -> Bear -> Endangered -> Panda。 继承的构造函数与多重继承 在C+11新标准中，允许派生类从它的一个或几个基类中继承构造函数。但是如果从多个基类中继承了相同的构造函数（即形参列表完全相同），则程序将产生错误，则这个类必须为该构造函数定义它自己的版本。 析构函数与多重继承 派生类的析构函数只负责清除派生类本身分配的资源。 析构函数调用顺序与构造函数相反。 多重继承的派生类的拷贝与移动操作 与只有一个基类的继承一样，多重继承的派生类如果定义了自己的拷贝/赋值构造函数和赋值运算符，则必须在完整的对象上执行拷贝、移动或赋值操作。 3.2 类型转换与多个基类 [!NOTE] 编译器不会在派生类向基类的几种转换中进行比较和选择，因为在它看来转换到任意种基类都一样好。 基于指针类型或引用类型的查找 与只有一个基类的继承一样，对象、指针和引用的静态类型决定了我们能够使用哪些成员。 3.3 多重继承下的类作用域 派生类的作用域嵌套在直接基类和间接基类的作用域中。 在多重继承的情况下，相同的查找过程在所有直接基类中同时进行。如果名字在多个基类中都被找到，则对该名字的使用将具有二义性。 [!WARNING] 名字查找先于类型检查 即使形参列表不同、访问控制不同也有可能发生错误，因为名字查找先于类型检查，当编译器在两个作用域同时发现这个名字时，将直接报告一个调用二义性的错误。 要想避免潜在的二义性，最好的办法是在派生类中为该函数定义一个新版本。 3.4 虚继承 在C++语言中我们通过虚继承(virtual inheritance)的机制解决多次继承的问题。虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为虚基类 virtual base class)。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。 如图，Panda同时继承自Bear和Raccoon，而Bear和Raccoon都是ZooAnimal的子类，我们通过虚继承解决了对ZooAnimal的多次继承。 [!NOTE] 使用虚基类 使用方法： class Raccoon : public virtual ZooAnimal { /* ... */ }; class Bear : virtual public ZooAnimal { /* ... */ }; //virtual 和 访问控制符 顺序任意 支持向基类的常规类型转换 虚基类成员的可见性 如果在D1和D2中都没有x的定义，则x将被解析为B的成员，此时不存在二义性，一个D的对象只含有x的一个实例。 如果×是B的成员，同时是D1和D2中某一个的成员，则同样没有二义性，派生类的x比共享虚基类B的x优先级更高。 如果在D1和D2中都有×的定义，则直接访问×将产生二义性问题。 与非虚的多重继承体系一样，最好的解决办法是在派生类中为成员自定义新的实例。 3.5 构造函数与虚继承 在虚派生中，虚基类是由最底层的派生类初始化的。 虚继承的对象的构造方式 含有虚基类的对象的构造顺序与一般的顺序稍有区别：首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对其进行初始化。 [!NOTE] 构造函数与析构函数的次序 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 09_用于大型程序的工具 "},"docs/Cpp/C++-Primer/10_特殊工具与技术.html":{"url":"docs/Cpp/C++-Primer/10_特殊工具与技术.html","title":"10_特殊工具与技术","keywords":"","body":" 特殊工具与技术 1. 控制内存分配 1.1 重载new和delete new和delete的工作机理 operator new接口和operator delete接口 1.2 定位new表达式 显式的析构函数调用 2. 运行时类型识别 2.1 dynamic_cast 运算符 指针类型的dynamic_cast 引用类型的dynamic_cast 2.2 typeid运算符 2.3 使用RTTI实现继承类的相等运算符 2.4 type_info类 3. 枚举类型 4. 类成员指针 4.1 数据成员指针 返回数据成员指针的函数 4.2 成员函数指针 成员指针的类型别名 成员指针函数表 4.3 将成员函数用作可调用对象 使用function生成一个可调用对象 使用mem_fn生成一个可调用对象 使用bind生成一个可调用对象 5. 嵌套类 6. union：一种节省空间的类 匿名union 含有类类型成员的union 7. 局部类 8. 固有的不可移植的特性 8.1 位域 8.2 volatile 限定符 8.3 链接指示：extern \"C\" [TOC] 特殊工具与技术 示例：下面的章节展示一些特殊工具和技术的简短示例与说明。 1. 控制内存分配 1.1 重载new和delete new和delete的工作机理 operator new 分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或者对象的数组）。 编译器运行相应的构造函数以构造这些对象，并为其传入初始值。 对象被分配了空间并构造完成，返回一个指向该对象的指针。 operator delete 对指针所指的对象或者数组中的元素执行对应的析构函数。 编译器调用名为operator delete(或者operator delete[])的标准库函数释放内存空间。 [!WARNING] new和delete函数的查找过程和其他重载函数类似，可以在全局作用域中定义。 operator new接口和operator delete接口 //这些版本可能抛出异常 void *operator new(size_t); // 分配一个对象 void *operator new[](size_t); // 分配一个数组 void *operator delete(void*) noexcept; // 释放一个对象 void *operator delete[](void*) noexcept; // 释放一个数组 //这些版本承诺不会抛出异常 void *operator new(size_t, nothrow_t&) noexcept; void *operator new[](size_t, nothrow_t&) noexcept; void *operator delete(void*, nothrow_t&) noexcept; void *operator delete[](void*, nothrow_t&) noexcept; const char* a = \"hello\"; int* b = new int; if (typeid(a) == typeid(b)) { println(\"equal, typeid:{}\", typeid(a).name()); } else { println(\"not equal, ltypeid:{}, rtypeid:{}\", typeid(a).name(), typeid(b).name()); } operator delete返回类型必须是void, 第一个形参类型必须是void*. 作为类的成员时, 可以包含另外一个类型为size_t的形参, 表示对象的字节数. 1.2 定位new表达式 与allocator不同的是，对于operator new分配的内存空间来说我们无法使用construct函数构造对象。相反，我们应该使用new的定位new (placement new)形式构造对象。如我们所知，new的这种形式为分配函数提供了额外的信息。我们可以使用定位new传递一个地址，此时定位new的形式如下所示： new (address) type new (address) type (initializers)） new (address) type [size] new (address) type [size] {braced initializer list} [!NOTE] operator new(size_t, void*)实际上不分配任何内存，因为我们已经给他提供了一个指针，它返回这个指针，new表达式在指定的地址初始化对象。 实际上，传给定位new表达式的指针甚至不需要指向动态内存： int a=1; new(&a) int(2); print(\"{}\",a); //a的值变为2 //这是一个危险的操作，我们直接在栈内存上使用new构造了一个int对象并且覆盖了原有的a 显式的析构函数调用 string *sp = new string(\"hello\"); sp->~string(); [!NOTE] 2. 运行时类型识别 运行时类型识别(run-time type identification,RTTI) 的功能由两个运算符实现： typeid运算符，用于返回表达式的类型。 dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。 这两个运算符特别适用于以下情况：我们想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数。一般来说，只要有可能我们应该尽量使用虚函数。当操作被定义成虚函数时，编译器将根据对象的动态类型自动地选择正确的函数版本。然而，并非任何时候都能定义一个虚函数。假设我们无法使用虚函数，则可以使用一个RTTI运算符。另一方面，与虚成员函数相比，使用RTTI运算符蕴含着更多潜在的风险：程序员必须清楚地知道转换的目标类型并且必须检查类型转换是否被成功执行。 [!WARNING] 2.1 dynamic_cast 运算符 dynamic_cast(e); dynamic_cast(e); dynamic_cast(e); 在转换时进行运行时类型检查，比如，如果一个基类指针指向派生类对象，那么可以使用dynamic_cast转换为派生类指针，如果实际指向基类对象，那么通过运行时类型检查，转换将会失败。 必须满足三个条件之一： e 的类型是type的共有派生类 e 的类型是type的共有基类 e 的类型就是type的类型 如果失败： 指针类型调用返回0 引用类型调用抛出一个bat_cast异常 指针类型的dynamic_cast [!NOTE] if (Derived *dp = dynamic_cast(bp)) { //使用dp指向的Derived对象 } else { //使用bp指向的Base对象 } 引用类型的dynamic_cast void f(const Base &b) { try { const Derived& d = dynamic_cast(b); } catch(std::bad_cast) { //处理类型转换失败的情况 } } 2.2 typeid运算符 typeid运算符可以作用于任意类型的表达式。 和往常一样，顶层const被忽略。 如果表达式是一个引用，则typeid返回该引用所引对象的类型。 当typeid作用于数组或函数时，并不会执行向指针的标准类型转换。 当运算对象不属于类类型或者是一个不包含任何虚函数的类时，typeid运算符指示的是运算对象的静态类型。 当运算对象是定义了至少一个虚函数的类的左值时，typeid的结果直到运行时才会求得。 [!WARNING] 只有当类型含有虚函数时，需要运行时检查，编译器才会对表达式求值。 如果触发了运行时求值，而表达式是空指针，将抛出一个bad_typeid异常。 2.3 使用RTTI实现继承类的相等运算符 friend bool operator==(const Base &lhs,const Base &rhs) { // 如果 typeid 不相同，返回 false；否则虚调用 equal return typeid(lhs) == typeid(rhs) && lhs.equal(rhs); } //定义为友元的原因： //1.对称性，保证a==b和b==a的语义相同 //2.扩展性，友元函数可以在不修改类定义的情况下进行扩展 //派生类的equal函数首先使用dynamic_cast转换为派生类型，然后进行相应的比较，基类直接进行比较即可。 2.4 type_info类 定义在typeinfo头文件中，并且至少提供以下操作： 创建type_info对象的唯一途径是使用typeid运算符 const char* const a = new char; int* b = new int; if (typeid(a) == typeid(b)) { println(\"equal, typeid:{}\", typeid(a).name()); } else { println(\"not equal, ltypeid:{}, rtypeid:{}\",typeid(a).name(),typeid(b).name()); } //输出： //not equal, ltypeid:PKc, rtypeid:Pi 在gcc14.1.0编译器中，P代表指针，K代表const，类的name()比较复杂，请读者自行尝试。 [!NOTE] 3. 枚举类型 限定作用域的枚举类型 enum class open_mods {input, output, append}; 不限定作用域的枚举类型 enum color {red, yellow, green}; enum {floatPrec = 6, doublePrec = 10, double_doublePrec = 10};//名字是可选的 枚举成员 enum color (red,yellow,green};//不限定作用域的枚举类型 enum stoplight (red,yellow,green}//错误：重复定义了枚举成员 enum class peppers{red,yellow,green};//正确：枚举成员被隐藏了 color eyes = green;//正确：不限定作用域的枚举类型的枚举成员位于有效的作用域中 peppers p = green;//错误：peppers的枚举成员不在有效的作用域中 //color::green在有效的作用域中，但是类型错误 color hair = color::red;//正确：允许显式地访问枚举成员 peppers p2 = peppers::red;//正确：使用pappers的red 默认情况下，枚举值从0开始，依次加1,也可以指定初始值。 枚举值不一定唯一。 枚举成员是const，初始值必须是常量表达式 可以作为switch语句的表达式，枚举值作为cast标签。 作为非类型模板形参 [!NOTE] 不限定作用域的枚举类型成员可以隐式地转换成int，但是限定作用域的就不会。 指定enum的大小 enum的名字后加上冒号以及想要使用的类型： enum intValues : unsigned long long { ... }; 限定作用域的enum成员类型默认为 int，然而不限定的不存在默认类型，但是成员的潜在类型足够大。 枚举类型的前置声明 C++11新标准中，可以提前声明enum，enum的前置声明（无论隐式地还是显式地）必须指定其成员的大小： enum intValues : unsigned; //不限定作用域的，必须显式指定 enum class open_modes; //限定作用域的可以使用默认类型int 4. 类成员指针 成员指针(pointer to member)是指可以指向类的非静态成员的指针。 [!NOTE] 类的静态成员不属于任何对象，因此无须特殊的指向静态成员的指针，指向静态成员的指针与普通指针没有什么区别。 4.1 数据成员指针 int foo::*p = &foo::data;//传统香烟 auto pp = &foo::data;//锐克五代 现在只是有名无实，只有当解引用成员指针时我们才提供对象的信息： foo f, *pf = &f; auto s = foo.*p;//对象 s = pf->*p;//指针 成员指针访问运算符：.*和->*，它们首先解引用成员指针以得到所需的成员；然后像成员访问运算符一样，通过对象或指针获取成员。 返回数据成员指针的函数 static int foo::*getData(){ return &foo::data; }//foo的静态成员，返回foo类的int成员指针 int foo::*pdata = foo::getData();//获得成员指针 int mdata = mfoo.*pdata;//获得成员 4.2 成员函数指针 int (foo::*pbar)() const = &foo::bar; //(foo::*pbar)括号必不可少，否则将被视为函数声明 //note：而且非成员函数不能使用const限定符，函数声明无效。 auto pbar = &foo::bar; 和普通函数指针不同的是，在成员函数和指向该成员的指针之间不存在自动转换规则： pbar = &foo::bar; //必须显式地使用取地址运算符 pbar = foo::bar; //错误：在成员函数和指针之间不存在自动转换规则 使用： foo f, *pf = &f; (f.*pbar)();//对象调用 (pf->*pbar)();//指针调用 (f.*pbar)括号必不可少，因为调用运算符()的优先级高于成员指针访问运算符.* ->*。 假设去掉括号：f.*pbar() 则会调用名为pbar的函数，但pbar并不是一个函数，因此代码会产生错误。 [!NOTE] 成员指针的类型别名 using barFunc = int (foo::*)() const; barFunc bptr = &foo::bar; //用来声明函数 void action(barFunc = &foo::bar); [!NOTE] 成员指针函数表 //枚举类型增强可读性 enum func {func1, func2, func3, func4}; //函数表 barFunc Menu[] = {&foo::func1, &foo::func2, &foo::func3, &foo::func4, }; //调用指定函数 foo& foo::action(func f) { return (this->*Menu[f])(); } /**使用**/ foo f; foo.action(foo::func1); foo.action(foo::func2); 4.3 将成员函数用作可调用对象 成员指针不是一个可调用对象，这样的指针不支持函数调用运算符，也不能将它传递给一个标准库算法。 使用function生成一个可调用对象 std::function通过重载 operator() 并结合类型擦除和包装技术，实现了对成员函数指针的支持，使其可以像普通函数一样使用。 function 要想使用function，必须提供成员的调用形式。 使用mem_fn生成一个可调用对象 和function一样，mem_fn也定义在functional头文件中，并且可以从成员指针生成一个可调用对象；和function不同的是，mem_fn可以根据成员指针的类型推断可调用对象的类型，而无须用户显式地指定： find_if(svec.begin(), svec.end(), mem_fn(&string::empty)); mem_fn生成的可调用对象可以通过对象调用，也可以通过指针调用： auto f = mem_fn(&string::empty); f(svec[0]); //对象，通过.*调用 f(&svec[0]);//指针，通过->*调用 使用bind生成一个可调用对象 auto it = find_if(svec_begin(),svec.end(), bind(&string::empty, _1)); //必须将函数中用于表示执行对象的隐式形参转换成显式的_1 5. 嵌套类 嵌套类的名字在外层类作用域中是可见的，在外层类作用域之外不可见。和其他嵌套的名字一样，嵌套类的名字不会和别的作用域中的同一个名字冲突。 嵌套类也使用访问限定符来控制外界对其成员的访问权限。外层类对嵌套类的成员没有特殊的访问权限，同样，嵌套类对外层类的成员也没有特殊的访问权限。 嵌套类在其外层类中定义了一个类型成员。和其他成员类似，该类型的访问权限由外层类决定。 [!WARNING] 如我们所知，嵌套类是其外层类的一个类型成员，因此外层类的成员可以像使用任何其他类型成员一样使用嵌套类的名字。 和过去一样，函数返回类型不在类的作用域中（参见7.4节，第253页），因此，如果返回值类型是在类内定义的，我们必须使用作用域运算符指明作用域。比如foo::type。 6. union：一种节省空间的类 联合(union)是一种特殊的类。一个union可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当我们给union的某个成员赋值之后，该union的其他成员就变成未定义的状态了。分配给一个union对象的存储空间至少要能容纳它的最大的数据成员。和其他类一样，一个union定义了一种新类型。 不能含有引用类型的成员 成员可以是类类型 默认情况下成员是public的 可以定义构造函数和析构函数 不能继承自其他类，也不能作为基类使用，所以不能含有虚函数 为union的一个数据成员赋值会令其他数据成员变成未定义的状态。因此，当我们使用union时，必须清楚地知道当前存储在union中的值到底是什么类型。如果我们使用错误的数据成员或者为错误的数据成员赋值，则程序可能崩溃或出现异常行为，具体的情况根据成员的类型而有所不同。 匿名union union { char cval; int ival; double dval; }; 一旦我们定义了一个匿名union，编译器就自动地为该union创建一个未命名的对象，在匿名union的定义所在的作用域内该union的成员都是可以直接访问的。 [!NOTE] 含有类类型成员的union 对于union来说，要想构造或销毁类类型的成员必须执行非常复杂的操作，因此我们通常把含有类类型成员的union内嵌在另一个类当中。 这个类可以管理并控制与union的类类型成员有关的状态转换。为了追踪union中到底存储了什么类型的值，我们通常会定义一个独立的对象，该对象称为union的判别式(discriminant)。我们可以使用判别式辨认union存储的值。 一定要注意，在处理union中的类类型成员时，要手动调用构造函数和析构函数。 7. 局部类 局部类（local class）是定义在某个函数内的类。 [!NOTE] 在局部类中不允许声明静态数据成员，因为我们没法定义这样的成员。 局部类只能访问外层作用域定义的类型名、静态变量以及枚举成员。 如果局部类定义在某个函数内部，则它不能使用该函数的普通局部变量。 局部类内的嵌套类也是一个局部类，必须遵循局部类的各种规定。 8. 固有的不可移植的特性 为了支持低层编程，C++定义了一些固有的不可移植(nonportable)的特性。所谓不可移植的特性是指因机器而异的特性，当我们将含有不可移植特性的程序从一台机器转移到另一台机器上时，通常需要重新编写该程序。 8.1 位域 类可以将其（非静态）数据成员定义成位域(bit-field),在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。 [!NOTE] 位域的类型必须是整形或枚举类型。 因为带符号位域的行为是由具体实现确定的，所以在通常情况下我们使用无符号类型保存一个位域。 位域的声明形式是在成员名字之后紧跟一个冒号以及一个常量表达式，该表达式用于指定成员所占的二进制位数。 如果可能的话，在类内部连续定义的位域压缩在同一整数的相邻位，从而提供存储压缩，这与机器相关。 取地址运算符（&）不能用于位域，因此任何指针都无法指向类的位域 [!WARNING] typedef unsigned int Bit; class File{ Bit mode: 2;//占2位 Bit modified: 1;//占1位 public: enum modes {READ = 01, WRITE = 02, EXECUTE = 03}; //此处是八进制数 File &open(modes); void close(); void write(); bool isRead() const; void setWrite(); } 通常使用内置的位运算符操作超过1位的位域。 8.2 volatile 限定符 [!WARNING] 直接处理硬件的程序常常包含这样的数据元素，它们的值由程序直接控制之外的过程控制。例如，程序可能包含一个由系统时钟定时更新的变量。当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为volatile。关键字volatile告诉编译器不应对这样的对象进行优化。 volatile和const有许多相似之处，并且可以同时存在。 但它们的一个重要区别是我们不能使用合成的拷贝/移动构造函数以及赋值运算符初始化volatile对象或从volatile对象赋值，这是由合成函数的参数类型导致的。 以下是自定义的volatile拷贝控制操作： class Foo { public: //从一个volatile对象进行拷贝 Foo(const volatile Foo&); //将一个volatile对象赋值给一个非volati1e对象 Foo& operator=(volatile const Foo&); //将一个volatile对象赋值给一个volatile对象 Foo& operator=(volatile const Foo&) volatile; }; 8.3 链接指示：extern \"C\" C++程序有时需要调用其他语言编写的函数，最常见的是调用C语言编写的函数。 像所有其他名字一样，其他语言中的函数名字也必须在C++中进行声明，并且该声明必须指定返回类型和形参列表。 对于其他语言编写的函数来说，编译器检查其调用的方式与处理普通C+函数的方式相同，但是生成的代码有所区别。C++使用链接指示(linkage directive)指出任意非C++函数所用的语言。 [!NOTE] [!note] 声明一个非C++的函数 extern \"C\" size_t strlen(const char*); extern \"C\" { int strcmp(const char*, const char*); char *strcat(char*, const char*); } 链接指示与头文件 extern \"C\" { #include }//对头文件中所有普通函数的声明都有效 指向extern \"C\"函数的指针 void (*pf1)(int); extern \"C\" void (*pf2)(int); pf1 = pf2; //错误，类型不同 [!WARNING] 链接指示对整个声明都有效 extern \"C\" void f1( void(*)(int) ); //extern对于f1的形参函数指针也有效 //调用时必须传入一个C函数或指向C函数的指针 给C++函数传入一个指向C函数的指针： extern \"C\" typedef void FC(int); void f2(FC*); ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 10_特殊工具与技术 "},"docs/Cpp/C++-Primer/11_lambda表达式的类型.html":{"url":"docs/Cpp/C++-Primer/11_lambda表达式的类型.html","title":"11_lambda表达式的类型","keywords":"","body":" lambda 表达式的类型 理解 lambda 表达式的类型 使用 decltype 获取 lambda 的类型 lambda 表达式的类型 在 C++ 中，lambda 表达式实际上是一个匿名的闭包类型（closure type），每个 lambda 表达式都有自己独特的类型。这种类型是编译器为该 lambda 生成的匿名类，通常无法直接写出它的类型名。可以通过 decltype 获得该类型。 理解 lambda 表达式的类型 当我们定义一个 lambda 表达式时，编译器会为其生成一个匿名类并在其中定义 operator()。例如： auto deleter = [](int* ptr) { std::cout 上述 lambda 在编译器内部等价于： struct __lambda_deleter { void operator()(int* ptr) const { std::cout 因此，deleter 的类型是一个匿名类，具有 operator()。 使用 decltype 获取 lambda 的类型 如果需要把 lambda 的类型用作模板参数或类型别名，可以使用 decltype： using DeleterType = decltype(deleter); DeleterType d = deleter; // 复制 lambda 对象 一个常见场景是为 std::unique_ptr 提供自定义删除器： #include #include int main() { auto del = [](int* p){ std::cout p(new int(42), del); // 或者直接写成： std::unique_ptr p(new int(42), del); } 注意：lambda 的类型通常很长且是匿名的，直接把 decltype(lambda) 写入模板参数是常见做法。若需要类型擦除或更灵活的传递方式，可使用 std::function（有性能开销）： #include std::function f = del; 小结：lambda 是匿名类，decltype(lambda) 可用于获取其确切类型，常用于需要类型作为模板参数的场景（例如 unique_ptr 的自定义删除器）。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 11_lambda表达式的类型 "},"docs/Cpp/C++-Primer/12_nullptr.html":{"url":"docs/Cpp/C++-Primer/12_nullptr.html","title":"12_nullptr","keywords":"","body":" nullptr 和 NULL nullptr 和 NULL nullptr 在 C++11 中被引入，相比传统的 NULL，它在语义和类型安全上更清晰。下面概述了两者的主要差别及为什么推荐使用 nullptr： 类型安全：nullptr 的类型是 std::nullptr_t，可以隐式转换为任意指针类型，但不能转换为整数类型（除 bool）。而 NULL 常被定义为整数字面量 0，在重载或模板上下文中可能被误解为整数，从而造成歧义或错误。 模板与重载友好：在模板或重载决议中，nullptr 能明确表示空指针意图，而 NULL（0）可能更倾向于匹配整数重载或导致歧义。 可读性：nullptr 明确表意，表明这是一个空指针，而不是整数常量。 下面给出一个清晰且可编译的例子，展示 NULL（或 0）与 nullptr 在重载解析上的不同表现： #include void func(char* /*ptr*/) { std::cout 说明：示例中通过为 func 提供一个接受 int 的重载来模拟 NULL 作为整数时可能触发的情况；使用 nullptr 能保证调用指针重载，从而避免歧义或错误。 小结：在现代 C++ 中，优先使用 nullptr 替代 NULL，以提高类型安全与可读性。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 12_nullptr "},"docs/Cpp/Effective-Modern-C++/":{"url":"docs/Cpp/Effective-Modern-C++/","title":"Effective-Modern-C++","keywords":"","body":" Effective-Modern-C++ Effective-Modern-C++ 本文件夹收集了《Effective Modern C++》相关的简明笔记，每个文件讲一个实用技巧或常见用法，语言尽量通俗，方便快速查阅。 当然，这只是本人的理解，希望你能学习当前笔记的同时去阅读原书和相关知识 目录（主要文件）： CHAPTER_1_Deducing_Types CHAPTER_2_auto CHAPTER_3_Moving_to_Modern_C++ CHAPTER_4_Smart_Pointers CHAPTER_5_RValue_References,Move_Semantics_and_Perfect_Forwarding CHAPTER_6_Lambda_Expressions 章节简介： CHAPTER_1_Deducing_Types：讲编译器如何推断变量类型，能帮你写更简洁的代码。 CHAPTER_2_auto：介绍 auto 的使用场景，什么时候可以让编译器替你选类型。 CHAPTER_3_Moving_to_Modern_C++：把旧写法改成更现代、更安全的写法，包含常见改造建议。 CHAPTER_4_Smart_Pointers：讲如何用智能指针自动管理内存，减少手动释放的麻烦。 CHAPTER_5_RValue_References,Move_Semantics_and_Perfect_Forwarding：解释如何避免不必要的复制，让程序更快（用简单例子说明）。 CHAPTER_6_Lambda_Expressions：介绍小型匿名函数（lambda），适合写短小的逻辑或回调。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - Effective-Modern-C++ "},"docs/Cpp/Effective-Modern-C++/CHAPTER_1_Deducing_Types.html":{"url":"docs/Cpp/Effective-Modern-C++/CHAPTER_1_Deducing_Types.html","title":"CHAPTER_1_Deducing_Types","keywords":"","body":" 第一章 类型推导 Item 1: Understand template type deduction 情景一：ParamType是一个指针或引用，但不是通用引用 情景二：ParamType是一个通用引用 情景三：ParamType既不是指针也不是引用 数组形参 函数实参 总结 Item 2: Understand auto type deduction 和模板类型推导相同点 和模板类型推导的区别 总结 Item 3: Understand decltype 主要作用 总结 Item 4: Know how to view deduced types 1. IDE编辑器 2. 编译器诊断 3. 运行时输出 [TOC] 第一章 类型推导 Item 1: Understand template type deduction 对于 template void f(ParamType param); f(expr); //从expr中推导T和ParamType 在编译期间，编译器使用expr进行两个类型推导： 一个是针对T的，另一个是针对ParamType的。 这两个类型通常是不同的，因为ParamType包含一些修饰，比如const和引用修饰符。 情景一：ParamType是一个指针或引用，但不是通用引用 最简单的情况是ParamType是一个指针或者引用，但非通用引用。在这种情况下，类型推导会这样进行： 如果expr的类型是一个引用，忽略引用部分 然后expr的类型与ParamType进行模式匹配来决定T template void f(const T& param); //param现在是reference-to-const int x = 27; //如之前一样 const int cx = x; //如之前一样 const int& rx = x; //如之前一样 f(x); //T是int，param的类型是const int& f(cx); //T是int，param的类型是const int& f(rx); //T是int，param的类型是const int& rx的reference-ness在类型推导中被忽略了。 指针类似： template void f(T* param); //param现在是指针 int x = 27; //同之前一样 const int *px = &x; //px是指向作为const int的x的指针 f(&x); //T是int，param的类型是int* f(px); //T是const int，param的类型是const int* px的point-ness在类型推导中被忽略了 情景二：ParamType是一个通用引用 这样的形参被声明为像右值引用一样（也就是，在函数模板中假设有一个类型形参T，那么通用引用声明形式就是T&&或者是auto&&) 如果expr是左值，T和ParamType都会被推导为左值引用。这非常不寻常，第一，这是模板类型推导中唯一一种T被推导为引用的情况。第二，虽然ParamType被声明为右值引用类型，但是最后推导的结果是左值引用。 如果expr是右值，就使用正常的（也就是情景一）推导规则 template void f(T&& param); //param现在是一个通用引用类型 int x=27; //如之前一样 const int cx=x; //如之前一样 const int & rx=cx; //如之前一样 f(x); //x是左值，所以T是int&， //param类型也是int& f(cx); //cx是左值，所以T是const int&， //param类型也是const int& f(rx); //rx是左值，所以T是const int&， //param类型也是const int& f(27); //27是右值，所以T是int， //param类型就是int&& 情景三：ParamType既不是指针也不是引用 当ParamType既不是指针也不是引用时，我们通过传值（pass-by-value）的方式处理： 和之前一样，如果expr的类型是一个引用，忽略这个引用部分 如果忽略expr的引用性（reference-ness）之后，expr是一个const，那就再忽略const。如果它是volatile，也忽略volatile（volatile对象不常见，它通常用于驱动程序的开发中。关于volatile的细节请参见Item40） template void f(T param); //以传值的方式处理param int x=27; //如之前一样 const int cx=x; //如之前一样 const int & rx=cx; //如之前一样 f(x); //T和param的类型都是int f(cx); //T和param的类型都是int f(rx); //T和param的类型都是int param是一个完全独立于cx和rx的对象——是cx或rx的一个拷贝。 具有常量性的cx和rx不可修改并不代表param也是一样。 只有在传值给形参时才会忽略const（和volatile）这一点很重要: template void f(T param); //仍然以传值的方式处理param const char* const ptr = //ptr是一个常量指针，指向常量对象 \"Fun with pointers\"; f(ptr); //传递const char * const类型的实参 像这种情况，ptr自身的值会被传给形参，根据类型推导的第三条规则，ptr自身的常量性constness将会被省略，所以param是const char* 在类型推导中，这个指针指向的数据的常量性constness将会被保留，但是当拷贝ptr来创造一个新指针param时，ptr自身的常量性constness将会被忽略。 数组形参 const char name[] = \"J. P. Briggs\"; //name的类型是const char[13] const char * ptrToName = name; //数组退化为指针 在这里const char*指针ptrToName会由name初始化，而name的类型为const char[13]，这两种类型（const char*和const char[13]）是不一样的，但是由于数组退化为指针的规则，编译器允许这样的代码。 传值给模板的一个数组类型会被推导为一个指针类型 void myFunc(int param[]); void myFunc(int* param); //与上面相同的函数 template void f(T param); //传值形参的模板 f(name); //name是一个数组，但是T被推导为const char* 函数不能声明形参为真正的数组，但是可以接受指向数组的引用，使得T被推导为了真正的数组。 template void f(T& param); //传引用形参的模板 f(name); //T被推导为const char[13] 借助可声明指向数组的引用的能力，使得我们可以创建一个模板函数来推导出数组的大小 //在编译期间返回一个数组大小的常量值（//数组形参没有名字， //因为我们只关心数组的大小） template //关于 constexpr std::size_t arraySize(T (&)[N]) noexcept //constexpr { //和noexcept return N; //的信息 } //请看下面 （constexpr是一种比const更加严格的常量定义，noexcept是说明函数永远都不会抛出异常——译者注） 函数实参 在C++中不只是数组会退化为指针，函数类型也会退化为一个函数指针 void someFunc(int, double); //someFunc是一个函数， //类型是void(int, double) template void f1(T param); //传值给f1 template void f2(T & param); //传引用给f2 f1(someFunc); //param被推导为指向函数的指针， //类型是void(*)(int, double) f2(someFunc); //param被推导为指向函数的引用， //类型是void(&)(int, double) 总结 [!note] 在模板类型推导时，有引用的实参会被视为无引用，他们的引用会被忽略 对于通用引用的推导，左值实参会被特殊对待 对于传值类型推导，const和/或volatile实参会被认为是non-const的和non-volatile的 在模板类型推导时，数组名或者函数名实参会退化为指针，除非它们被用于初始化引用 Item 2: Understand auto type deduction 和模板类型推导相同点 当一个变量使用auto进行声明时，auto扮演了模板中T的角色，变量的类型说明符扮演了ParamType的角色。 在使用auto作为类型说明符的变量声明中，类型说明符代替了ParamType，因此Item1描述的三个情景稍作修改就能适用于auto： 情景一：类型说明符是一个指针或引用但不是通用引用 情景二：类型说明符一个通用引用 情景三：类型说明符既不是指针也不是引用 auto x = 27; //情景三（x既不是指针也不是引用） const auto cx = x; //情景三（cx也一样） const auto & rx=cx; //情景一（rx是非通用引用） //情景二： auto&& uref1 = x; //x是int左值， //所以uref1类型为int& auto&& uref2 = cx; //cx是const int左值， //所以uref2类型为const int& auto&& uref3 = 27; //27是int右值， //所以uref3类型为int&& //数组和函数名如何退化为指针。那些内容也同样适用于auto类型推导： const char name[] = //name的类型是const char[13] \"R. N. Briggs\"; auto arr1 = name; //arr1的类型是const char* auto& arr2 = name; //arr2的类型是const char (&)[13] void someFunc(int, double); //someFunc是一个函数， //类型为void(int, double) auto func1 = someFunc; //func1的类型是void (*)(int, double) auto& func2 = someFunc; //func2的类型是void (&)(int, double) 和模板类型推导的区别 当用auto声明的变量使用花括号进行初始化，auto类型推导推出的类型则为std::initializer_list。 auto x1 = 27; //类型是int，值是27 auto x2(27); //同上 auto x3 = { 27 }; //类型是std::initializer_list， //值是{ 27 } auto x4{ 27 }; //同上 [!warning] auto x4{27} 在书中称 auto 推导出 std::initializer_list。然而，在 N3922 之后，将会推导出 int。 auto x1 = {3}; // x1 is std::initializer_list auto x2{1, 2}; // error: not a single element auto x3{3}; // x3 is int // (before N3922 x2 and x3 were both std::initializer_list) auto x5 = { 1, 2, 3.0 }; //错误！无法推导std::initializer_list中的T 这里确实发生了两种类型推导是很重要的。 一种是由于auto的使用：x5使用花括号的方式进行初始化，x5必须被推导为std::initializer_list。 std::initializer_list会被某种类型T实例化，T也会被推导，推导之所以失败，是因为在花括号中的值并不是同一种类型。 对于模板类型推导这样就行不通： auto x = { 11, 23, 9 }; //x的类型是std::initializer_list template //带有与x的声明等价的 void f(T param); //形参声明的模板 f({ 11, 23, 9 }); //错误！不能推导出T template void f(std::initializer_list initList); f({ 11, 23, 9 }); //T被推导为int，initList的类型为 //std::initializer_list [!note] auto类型推导和模板类型推导的真正区别在于，auto类型推导假定花括号表示std::initializer_list而模板类型推导不会这样 但是C++14允许auto用于函数返回值并会被推导（参见Item3），而且C++14的lambda函数也允许在形参声明中使用auto。但是在这些情况下auto实际上使用模板类型推导的那一套规则在工作，而不是auto类型推导。 auto createInitList() { return { 1, 2, 3 }; //错误！不能推导{ 1, 2, 3 }的类型 } std::vector v; … auto resetV = [&v](const auto& newValue){ v = newValue; }; //C++14 … resetV({ 1, 2, 3 }); //错误！不能推导{ 1, 2, 3 }的类型 总结 [!note] auto类型推导通常和模板类型推导相同，但是auto类型推导假定花括号初始化代表std::initializer_list，而模板类型推导不这样做 在C++14中auto允许出现在函数返回值或者lambda函数形参中，但是它的工作机制是模板类型推导那一套方案，而不是auto类型推导 Item 3: Understand decltype 主要作用 decltype只是简单的返回名字或者表达式的类型： const int i = 0; //decltype(i)是const int bool f(const Widget& w); //decltype(w)是const Widget& //decltype(f)是bool(const Widget&) struct Point{ int x,y; //decltype(Point::x)是int }; //decltype(Point::y)是int Widget w; //decltype(w)是Widget if (f(w))… //decltype(f(w))是bool template //std::vector的简化版本 class vector{ public: … T& operator[](std::size_t index); … }; vector v; //decltype(v)是vector … if (v[0] == 0)… //decltype(v[0])是int& C++11，decltype最主要的用途就是用于声明函数模板，而这个函数返回类型依赖于形参类型。 template //最终的C++14版本 decltype(auto) authAndAccess(Container&& c, Index i) { authenticateUser(); return std::forward(c)[i]; } decltype(auto)的使用不仅仅局限于函数返回类型，当你想对初始化表达式使用decltype推导的规则，你也可以使用： Widget w; const Widget& cw = w; auto myWidget1 = cw; //auto类型推导 //myWidget1的类型为Widget decltype(auto) myWidget2 = cw; //decltype类型推导 //myWidget2的类型是const Widget& [!warning] decltype(auto) f1() { int x = 0; … return x; //decltype(x）是int，所以f1返回int } decltype(auto) f2() { int x = 0; return (x); //decltype((x))是int&，所以f2返回int& } 注意不仅f2的返回类型不同于f1，而且它还引用了一个局部变量！ 总结 [!note] decltype总是不加修改的产生变量或者表达式的类型。 对于T类型的不是单纯的变量名的左值表达式，decltype总是产出T的引用即T&。 C++14支持decltype(auto)，就像auto一样，推导出类型，但是它使用decltype的规则进行推导。 Item 4: Know how to view deduced types 我们探究三种方案：在你编辑代码的时候获得类型推导的结果，在编译期间获得结果，在运行时获得结果。 1. IDE编辑器 在IDE中的代码编辑器通常可以显示程序代码中变量，函数，参数的类型，你只需要简单的把鼠标移到它们的上面 为此，你的代码必须或多或少的处于可编译状态，因为IDE之所以能提供这些信息是因为一个C++编译器（或者至少是前端中的一个部分）运行于IDE中。 2. 编译器诊断 使用编译器出错时提供的错误消息。 template //只对TD进行声明 class TD; //TD == \"Type Displayer\" TD xType; //引出包含x和y TD yType; //的类型的错误消息 variableName**Type**的结构来命名变量，因为这样它们产生的错误消息可以有助于我们查找 3. 运行时输出 使用printf的方法（并不是说我推荐你使用printf）类型信息要在运行时才会显示出来，但是它提供了一种格式化输出的方法。 std::cout 对一个对象如x或y调用typeid产生一个std::type_info的对象，然后std::type_info里面的成员函数name()来产生一个C风格的字符串（即一个const char*）表示变量的名字。 td::type_info::name的结果并不总是可信的 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - CHAPTER_1_Deducing_Types "},"docs/Cpp/Effective-Modern-C++/CHAPTER_2_auto.html":{"url":"docs/Cpp/Effective-Modern-C++/CHAPTER_2_auto.html","title":"CHAPTER_2_auto","keywords":"","body":" 第2章 auto Item 5: Prefer auto to explicit type declarations std::function 总结 Item 6: Use the explicitly typed initializer idiom when auto deduces undesired types 总结 [TOC] 第2章 auto Item 5: Prefer auto to explicit type declarations auto变量从初始化表达式中推导出类型，所以我们必须初始化。 int x1; //潜在的未初始化的变量 auto x2; //错误！必须要初始化 auto x3 = 0; //没问题，x已经定义了 //使用解引用迭代器初始化局部变量 template //如之前一样 void dwim(It b,It e) { while (b != e) { auto currValue = *b; … } } 使用C++14，lambda*表达式中的形参也可以使用auto： auto derefLess = //C++14版本 [](const auto& p1, //被任何像指针一样的东西 const auto& p2) //指向的值的比较函数 { return *p1 std::function std::function是一个C++11标准模板库中的一个模板，泛化了函数指针的概念。 std::function可以指向任何可调用对象，创建std::function对象时你也需要提供函数签名，由于它是一个模板所以你需要在它的模板参数里面提供。 bool(const std::unique_ptr &, //C++11 const std::unique_ptr &) //std::unique_ptr //比较函数的签名 std::function &, const std::unique_ptr &)> func; lambda表达式能产生一个可调用对象，所以我们现在可以把闭包存放到std::function对象中。 //不使用auto写出C++11版的derefUPLess std::function &, const std::unique_ptr &)> derefUPLess = [](const std::unique_ptr &p1, const std::unique_ptr &p2) { return *p1 具体实现我们得知通过std::function调用一个闭包几乎无疑比auto声明的对象调用要慢。std::function方法比auto方法要更耗空间且更慢，还可能有out-of-memory异常。 auto除了可以避免未初始化的无效变量，省略冗长的声明类型，直接保存闭包外，可以实现类型快捷方式转变 auto sz =v.size(); //sz的类型是std::vector::size_type 总结 [!note] auto变量必须初始化，通常它可以避免一些移植性和效率性的问题，也使得重构更方便，还能让你少打几个字。 正如Item2和6讨论的，auto类型的变量可能会踩到一些陷阱。 Item 6: Use the explicitly typed initializer idiom when auto deduces undesired types 假如我有一个函数，参数为Widget，返回一个std::vector，这里的bool表示Widget是否提供一个独有的特性。 std::vector features(const Widget& w); Widget w; //假设第5个bit表示Widget是否具有高优先级 … bool highPriority = features(w)[5]; //w高优先级吗？ … processWidget(w, highPriority); //根据它的优先级处理w 对std::vector的operator[]运算符返回的是一个std::vector::reference对象（是一个在std::vector中内嵌的class） bool highPriority = features(w)[5]; //显式的声明highPriority的类型 这里，features返回一个std::vector对象后再调用operator[]，operator[]将会返回一个std::vector::reference对象，然后再通过隐式转换赋值给bool变量highPriority。highPriority因此表示的是features返回的std::vector中的第五个bit，这也正如我们所期待的那样。 auto highPriority = features(w)[5]; //推导highPriority的类型 同样的，features返回一个std::vector对象，再调用operator[]，operator[]将会返回一个std::vector::reference对象，但是现在这里有一点变化了，auto推导highPriority的类型为std::vector::reference，但是highPriority对象没有第五bit的值。 原因：std::vector::reference是一个代理类 [!note] 所谓代理类就是以模仿和增强一些类型的行为为目的而存在的类。 作为一个通则，不可见的代理类通常不适用于auto。 解决：强制使用一个不同的类型推导形式，这种方法我通常称之为显式类型初始器惯用法（the explicitly typed initialized idiom)。 auto highPriority = static_cast(features(w)[5]); 这里，features(w)[5]还是返回一个std::vector::reference对象，就像之前那样，但是这个转型使得表达式类型为bool，然后auto才被用于推导highPriority。在运行时，对std::vector::operator[]返回的std::vector::reference执行它支持的向bool的转型，在这个过程中指向std::vector的指针已经被解引用。这就避开了我们之前的未定义行为。然后5将被用于指向bit的指针，bool值被用于初始化highPriority。 总结 [!note] 不可见的代理类可能会使auto从表达式中推导出“错误的”类型 显式类型初始器惯用法(static_cast)强制auto推导出你想要的结果 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - CHAPTER_2_auto "},"docs/Cpp/Effective-Modern-C++/CHAPTER_3_Moving_to_Modern_C++.html":{"url":"docs/Cpp/Effective-Modern-C++/CHAPTER_3_Moving_to_Modern_C++.html","title":"CHAPTER_3_Moving_to_Modern_C++","keywords":"","body":" 第3章 移步现代C++ Item 7: Distinguish between () and {} when creating objects 统一初始化 括号初始化的缺点 总结 Item 8: Prefer nullptr to 0 and NULL 0 and NULL nullptr 总结 Item 9: Prefer alias declarations to typedef typedef and using 总结 Item 10: Prefer scoped enums to unscoped enums (unscoped enum)and (scoped enum) 枚举类 总结 Item 11: Prefer deleted functions to private undefined ones. delete 总结 Item 12: Declare overriding functions override override final 成员函数引用限定（reference qualifiers） 总结 Item 13: Prefer const_iterators to iterators const_iterator 总结 Item 14: Declare functions noexcept if they won’t emit exceptions noexcept 展开调用栈和可能展开调用栈 swap 异常中立 宽泛契约（wild contracts）和严格契约（narrow contracts） 总结 Item 15: Use constexpr whenever possible constexpr constexpr对象 constexpr函数 总结 Item 16: Make const member functions thread safe const成员函数 总结 Item 17: Understand special member function generation 特殊成员函数 移动构造函数和移动赋值运算符 Rule of Three C++11对于特殊成员函数处理的规则 总结 [TOC] 第3章 移步现代C++ Item 7: Distinguish between () and {} when creating objects 区别赋值运算符和初始化 Widget w1; //调用默认构造函数 Widget w2 = w1; //不是赋值运算，调用拷贝构造函数 w1 = w2; //是赋值运算，调用拷贝赋值运算符（copy operator=） 统一初始化 C++11使用统一初始化（uniform initialization）来整合这些混乱且不适于所有情景的初始化语法 统一初始化是指在任何涉及初始化的地方都使用单一的初始化语法，基于花括号 //使用花括号，创建并指定一个容器的初始元素 std::vector v{ 1, 3, 5 }; //v初始内容为1,3,5 //为非静态数据成员指定默认初始值 class Widget{ … private: int x{ 0 }; //没问题，x初始值为0 int y = 0; //也可以 int z(0); //错误！ } 一方面，不可拷贝的对象（例如std::atomic——见Item40）可以使用花括号初始化或者圆括号初始化，但是不能使用\"=\"初始化： std::atomic ai1{ 0 }; //没问题 std::atomic ai2(0); //没问题 std::atomic ai3 = 0; //错误！ 括号表达式还有一个少见的特性:不允许内置类型间隐式的变窄转换（narrowing conversion)，而使用圆括号和\"=\"的初始化不检查是否转换为变窄转换。 double x, y, z; int sum1{ x + y + z }; //错误！double的和可能不能表示为int 另一个值得注意的特性：免疫解析问题（C++规定任何可以被解析为一个声明的东西必须被解析为声明） Widget w2(); //最令人头疼的解析！声明一个函数w2，返回Widget //函数声明中形参列表不能带花括号，所以使用花括号初始化表明你想调用默认构造函数构造对象 Widget w3{}; 括号初始化的缺点 Item2解释了当auto声明的变量使用花括号初始化，变量类型会被推导为std::initializer_list，但是使用相同内容的其他初始化方式会产生更符合直觉的结果。 你越喜欢用auto，你就越不能用括号初始化。 如果有一个或者多个构造函数的声明包含一个std::initializer_list形参，那么使用括号初始化语法的调用更倾向于选择带std::initializer_list的那个构造函数 class Widget { public: Widget(int i, bool b); //同之前一样 Widget(int i, double d); //同之前一样 Widget(std::initializer_list il); //同之前一样 operator float() const; //转换为float … }; Widget w1(10, true); //使用圆括号初始化，同之前一样 //调用第一个构造函数 Widget w2{10, true}; //使用花括号初始化，但是现在 //调用带std::initializer_list的构造函数 //(10 和 true 转化为long double) Widget w3(10, 5.0); //使用圆括号初始化，同之前一样 //调用第二个构造函数 Widget w4{10, 5.0}; //使用花括号初始化，但是现在 //调用带std::initializer_list的构造函数 //(10 和 5.0 转化为long double) 普通构造函数和移动构造函数都会被带std::initializer_list的构造函数劫持 Widget w5(w4); //使用圆括号，调用拷贝构造函数 Widget w6{w4}; //使用花括号，调用std::initializer_list构造 //函数（w4转换为float，float转换为double） Widget w7(std::move(w4)); //使用圆括号，调用移动构造函数 Widget w8{std::move(w4)}; //使用花括号，调用std::initializer_list构造 //函数（与w6相同原因） 就算带std::initializer_list的构造函数不能被调用，它也会硬选。 class Widget { public: Widget(int i, bool b); //同之前一样 Widget(int i, double d); //同之前一样 Widget(std::initializer_list il); //现在元素类型为bool … //没有隐式转换函数 }; Widget w{10, 5.0}; //错误！要求变窄转换 只有当没办法把括号初始化中实参的类型转化为std::initializer_list时，编译器才会回到正常的函数决议流程中。 class Widget { public: Widget(int i, bool b); //同之前一样 Widget(int i, double d); //同之前一样 //现在std::initializer_list元素类型为std::string Widget(std::initializer_list il); … //没有隐式转换函数 }; //没有办法把int和bool转换为std::string: Widget w1(10, true); // 使用圆括号初始化，调用第一个构造函数 Widget w2{10, true}; // 使用花括号初始化，现在调用第一个构造函数 Widget w3(10, 5.0); // 使用圆括号初始化，调用第二个构造函数 Widget w4{10, 5.0}; // 使用花括号初始化，现在调用第二个构造函数 空的花括号意味着没有实参，不是一个空的std::initializer_list class Widget { public: Widget(); //默认构造函数 Widget(std::initializer_list il); //std::initializer_list构造函数 … //没有隐式转换函数 }; Widget w1; //调用默认构造函数 Widget w2{}; //也调用默认构造函数 Widget w3(); //最令人头疼的解析！声明一个函数 //想用空std::initializer来调用std::initializer_list构造函数 Widget w4({ }); //使用空花括号列表调用std::initializer_list构造函数 Widget w5{ { } }; //同上 [!warning] 如果一堆重载的构造函数中有一个或者多个含有std::initializer_list形参，用户代码如果使用了括号初始化，可能只会看到你std::initializer_list版本的重载的构造函数。 最好把你的构造函数设计为不管用户是使用圆括号还是使用花括号进行初始化都不会有什么影响 认真的在花括号和圆括号之间选择一个来创建对象 默认使用花括号初始化的开发者主要被适用面广、禁止变窄转换、免疫C++最令人头疼的解析这些优点所吸引。 总结 [!note] 花括号初始化是最广泛使用的初始化语法，它防止变窄转换，并且对于C++最令人头疼的解析有天生的免疫性 在构造函数重载决议中，编译器会尽最大努力将括号初始化与std::initializer_list参数匹配，即便其他构造函数看起来是更好的选择 对于数值类型的std::vector来说使用花括号初始化和圆括号初始化会造成巨大的不同 在模板类选择使用圆括号初始化或使用花括号初始化创建对象是一个挑战。 Item 8: Prefer nullptr to 0 and NULL 0 and NULL 一般来说C++的解析策略是把0看做int而不是指针。 0和NULL都不是指针类型。 void f(int); //三个f的重载函数 void f(bool); void f(void*); f(0); //调用f(int)而不是f(void*) f(NULL); //可能不会被编译，一般来说调用f(int)， //绝对不会调用f(void*) f(NULL)的不确定行为是由NULL的实现不同造成的。 nullptr nullptr的优点是它不是整型，可以把它认为是所有类型的指针。 nullptr的真正类型是std::nullptr_t(std::nullptr_t可以隐式转换为指向任何内置类型的指针)，在一个完美的循环定义以后，std::nullptr_t又被定义为nullptr。 void f(int); //三个f的重载函数 void f(bool); void f(void*); f(nullptr); //调用重载函数f的f(void*)版本 使代码表意明确，尤其是当涉及到与auto声明的变量一起使用时。 auto result = findRecord( /* arguments */ ); //result的结果一定是指针类型。 if (result == nullptr) { … } 模板里的nullptr int f1(std::shared_ptr spw); //只能被合适的 double f2(std::unique_ptr upw); //已锁互斥量 bool f3(Widget* pw); //调用 template decltype(auto) lockAndCall(FuncType func, //C++14 MuxType& mutex, PtrType ptr) { MuxGuard g(mutex); return func(ptr); } auto result1 = lockAndCall(f1, f1m, 0); //错误！ ... auto result2 = lockAndCall(f2, f2m, NULL); //错误！ ... auto result3 = lockAndCall(f3, f3m, nullptr); //没问题 当nullptr传给lockAndCall时，ptr被推导为std::nullptr_t。当ptr被传递给f3的时候，隐式转换使std::nullptr_t转换为Widget*，因为std::nullptr_t可以隐式转换为任何指针类型。 模板类型推导将0和NULL推导为一个错误的类型（即它们的实际类型，而不是作为空指针的隐含意义） 想用一个空指针，使用nullptr，不用0或者NULL。 总结 [!note] 优先考虑nullptr而非0和NULL 避免重载指针和整型 Item 9: Prefer alias declarations to typedef typedef and using typedef是C++98的东西 typedef std::unique_ptr> UPtrMapSS; C++11也提供了一个别名声明（alias declaration）：using 声明 using UPtrMapSS = std::unique_ptr>; 声明一个函数指针时别名声明更容易理解： //FP是一个指向函数的指针的同义词，它指向的函数带有 //int和const std::string&形参，不返回任何东西 typedef void (*FP)(int, const std::string&); //typedef //含义同上 using FP = void (*)(int, const std::string&); //别名声明 别名声明可以被模板化（这种情况下称为别名模板alias templates）但是typedef不能 当编译器处理Widget模板时遇到MyAllocList（使用模板别名声明的版本），它们知道MyAllocList是一个类型名，因为MyAllocList是一个别名模板：它一定是一个类型名。 但是如果使用typedef编译器不能确定MyAllocList::type是一个类型而非特化版本的数据成员 template using MyAllocList = std::list>; //同之前一样 template class Widget { private: MyAllocList list; //没有“typename” … //没有“::type” }; C++11在type traits（类型特性）中给了你一系列工具去实现类型转换，些模板请包含头文件 C++11的type traits是通过在struct内嵌套typedef来实现的 C++14才提供了使用别名声明的版本 std::remove_const::type //C++11: const T → T std::remove_const_t //C++14 等价形式 std::remove_reference::type //C++11: T&/T&& → T std::remove_reference_t //C++14 等价形式 std::add_lvalue_reference::type //C++11: T → T& std::add_lvalue_reference_t //C++14 等价形式 总结 [!note] typedef不支持模板化，但是别名声明支持。 别名模板避免了使用“::type”后缀，而且在模板中使用typedef还需要在前面加上typename C++14提供了C++11所有type traits转换的别名声明版本 Item 10: Prefer scoped enums to unscoped enums (unscoped enum)and (scoped enum) 通常来说，在花括号中声明一个名字会限制它的作用域在花括号之内。 C++98风格的enum中声明的枚举名的名字属于包含这个enum的作用域 enum Color { black, white, red }; //black, white, red在 //Color所在的作用域 auto white = false; //错误! white早已在这个作用 //域中声明 这些枚举名的名字泄漏进它们所被定义的enum在的那个作用域:未限域枚举(unscoped enum) 一个相似物，限域枚举(scoped enum): enum class Color { black, white, red }; //black, white, red //限制在Color域内 auto white = false; //没问题，域内没有其他“white” Color c = white; //错误，域中没有枚举名叫white Color c = Color::white; //没问题 auto c = Color::white; //也没问题（也符合Item5的建议） 限域enum是通过“enum class”声明，所以它们有时候也被称为枚举类(enum classes)。 枚举类 使用限域enum来减少命名空间污染 在它的作用域中，枚举名是强类型。 未限域enum中的枚举名会隐式转换为整型（现在，也可以转换为浮点类型） enum Color { black, white, red }; //未限域enum std::vector //func返回x的质因子 primeFactors(std::size_t x); Color c = red; … if (c 不存在任何隐式转换可以将限域enum中的枚举名转化为任何其他类型 enum class Color { black, white, red }; //Color现在是限域enum Color c = Color::red; //和之前一样，只是 ... //多了一个域修饰符 if (c 使用正确的类型转换运算符扭曲类型系统执行Color到其他类型的转换 if (static_cast(c) (c)); //能通过编译 … } 限域enum可以被前置声明，减少编译依赖 enum Color; //错误！ enum class Color; //没问题 在C++11中，非限域enum也可以被前置声明:在C++中所有的enum都有一个由编译器决定的整型的底层类型 C++11中的前置声明enums可以减少编译依赖 enum class Status; //前置声明 void continueProcessing(Status s); //使用前置声明enum 即使Status的定义发生改变，包含这些声明的头文件也不需要重新编译 限域enum的底层类型总是已知的，而对于非限域enum，你可以指定它。 enum class Status: std::uint32_t; //Status的底层类型 //是std::uint32_t //（需要包含 ） 底层类型说明也可以放到enum定义处。 限域enum并非万事皆宜 [!warning] 牵扯到C++11的std::tuple的时候 UserInfo uInfo; //tuple对象 … auto val = std::get(uInfo); //获取第一个字段 //非限域 enum UserInfoFields { uiName, uiEmail, uiReputation }; UserInfo uInfo; //同之前一样 //UserInfoFields中的枚举名隐式转换成std::size_t auto val = std::get(uInfo); //啊，获取用户email字段的值 //限域 enum class UserInfoFields { uiName, uiEmail, uiReputation }; UserInfo uInfo; //同之前一样 … auto val = std::get(UserInfoFields::uiEmail)> (uInfo); 为避免这种冗长的表示，我们可以写一个函数传入枚举名并返回对应的std::size_t值 template //C++14 constexpr auto toUType(E enumerator) noexcept { return static_cast>(enumerator); } 总结 [!note] C++98的enum即非限域enum。 限域enum的枚举名仅在enum内可见。要转换为其它类型只能使用cast。 非限域/限域enum都支持底层类型说明语法，限域enum底层类型默认是int。非限域enum没有默认底层类型。 限域enum总是可以前置声明。非限域enum仅当指定它们的底层类型时才能前置。 Item 11: Prefer deleted functions to private undefined ones. delete 在C++98中，想要禁止使用的成员函数，几乎总是拷贝构造函数或者赋值运算符，或者两者都是。防止调用这些函数的方法是将它们声明为私有（private）成员函数并且不定义 所有istream和ostream类都继承此模板类basic_ios（直接或者间接) basic_ios在C++98中是这样声明的（包括注释）： template > class basic_ios : public ios_base { public: … private: //使这些istream和ostream类不可拷贝 basic_ios(const basic_ios& ); // not defined basic_ios& operator=(const basic_ios&); // not defined }; 有代码用它们（比如成员函数或者类的友元friend），就会在链接时引发缺少函数定义（missing function definitions）错误。 在C++11中，用“= delete”将拷贝构造函数和拷贝赋值运算符标记为deleted\\函数 template > class basic_ios : public ios_base { public: … basic_ios(const basic_ios& ) = delete; basic_ios& operator=(const basic_ios&) = delete; … }; deleted函数不能以任何方式被调用，即使你在成员函数或者友元函数里面调用deleted函数也不能通过编译 任何函数（包含普通函数和成员函数等所有可声明函数的地方）都可以标记为deleted，而只有成员函数可被标记为private //假如我们有一个非成员函数，它接受一个整型参数，检查它是否为幸运数 bool isLucky(int number); 能被视作数值的任何类型都能隐式转换为int，所以 if (isLucky('a')) … //字符'a'是幸运数？ if (isLucky(true)) … //\"true\"是? if (isLucky(3.5)) … //难道判断它的幸运之前还要先截尾成3？ 创建deleted重载函数，禁止这些调用通过编译。 bool isLucky(int number); //原始版本 bool isLucky(char) = delete; //拒绝char bool isLucky(bool) = delete; //拒绝bool bool isLucky(double) = delete; //拒绝float和double deleted 禁止一些模板的实例化 假如你要求一个模板仅支持原生指针（尽管第四章建议使用智能指针代替原生指针）： template void processPointer(T* ptr); 指针的世界里有两种特殊情况 void*指针，因为没办法对它们进行解引用，或者加加减减等 char*，因为它们通常代表C风格的字符串，而不是正常意义下指向单个字符的指针 processPointer不能被void*和char*调用 template<> void processPointer(void*) = delete; template<> void processPointer(char*) = delete; //const void*和const char*也应该无效，所以这些实例也应该标注delete: template<> void processPointer(const void*) = delete; template<> void processPointer(const char*) = delete; [!tip] 做得更彻底一些，你还要删除const volatile void*和const volatile char*重载版本，另外还需要一并删除其他标准字符类型的重载版本：std::wchar_t，std::char16_t和std::char32_t 用private（经典的C++98惯例）来禁止这些函数模板实例化 class Widget { public: … template void processPointer(T* ptr) { … } private: //模板特例化必须位于一个命名空间作用域，而不是类作用域。 template<> //错误！ void processPointer(void*); }; 总结 [!note] 比起声明函数为private但不定义，使用deleted函数更好 任何函数都能被删除（be deleted），包括非成员函数和模板实例（译注：实例化的函数） Item 12: Declare overriding functions override override 最基本的概念是派生类的虚函数重写基类同名函数 class Base { public: virtual void doWork(); //基类虚函数 … }; class Derived: public Base { public: virtual void doWork(); //重写Base::doWork … //（这里“virtual”是可以省略的） }; std::unique_ptr upb = //创建基类指针指向派生类对象 std::make_unique(); //关于std::make_unique … //请参见Item21 upb->doWork(); //通过基类指针调用doWork， //实际上是派生类的doWork //函数被调用 重写一个函数： 基类函数必须是virtual 基类和派生类函数名必须完全一样（除非是析构函数) 基类和派生类函数形参类型必须完全一样 基类和派生类函数常量性constness必须完全一样 基类和派生类函数的返回值和异常说明（exception specifications）必须兼容 函数的引用限定符（reference qualifiers）必须完全一样（C++11）。 class Widget { public: … void doWork() &; //只有*this为左值的时候才能被调用 void doWork() &&; //只有*this为右值的时候才能被调用 }; … Widget makeWidget(); //工厂函数（返回右值） Widget w; //普通对象（左值） … w.doWork(); //调用被左值引用限定修饰的Widget::doWork版本 //（即Widget::doWork &） makeWidget().doWork(); //调用被右值引用限定修饰的Widget::doWork版本 //（即Widget::doWork &&） 所有重写函数后面加上override。 class Base { public: virtual void mf1() const; virtual void mf2(int x); virtual void mf3() &; virtual void mf4() const; }; class Derived: public Base { public: virtual void mf1() const override; virtual void mf2(int x) override; virtual void mf3() & override; void mf4() const override; //可以添加virtual，但不是必要 }; 给你的派生类重写函数全都加上override override还可以帮你评估后果 对于override，它只在成员函数声明结尾处才被视为关键字。 final 向虚函数添加final可以防止派生类重写。 final也能用于类，这时这个类不能用作基类 成员函数引用限定（reference qualifiers） //写一个函数只接受左值实参，声明一个non-const左值引用形参 void doSomething(Widget& w); //只接受左值Widget对象 //只接受右值实参，声明一个右值引用形参 void doSomething(Widget&& w); //只接受右值Widget对象 引用限定可以很容易的区分一个成员函数被哪个对象（即*this）调用s 指明当data被右值Widget对象调用的时候结果也应该是一个右值。现在就可以使用引用限定，为左值Widget和右值Widget写一个data的重载函数来达成这一目的： class Widget { public: using DataType = std::vector; … DataType& data() & //对于左值Widgets, { return values; } //返回左值 DataType data() && //对于右值Widgets, { return std::move(values); } //返回右值 … private: DataType values; }; 总结 [!note] 为重写函数加上override 成员函数引用限定让我们可以区别对待左值对象和右值对象（即*this) Item 13: Prefer const_iterators to iterators const_iterator STL const_iterator等价于指向常量的指针（pointer-to-const） 实践是能加上const就加上 假如你想在std::vector中查找第一次出现1983（C++代替C with classes的那一年）的位置，然后插入1998（第一个ISO C++标准被接纳的那一年）。如果vector中没有1983，那么就在vector尾部插入。 C++98 typedef std::vector::iterator IterT; //typedef typedef std::vector::const_iterator ConstIterT; std::vector values; … //用const_iterator重写这段代码 ConstIterT ci = std::find(static_cast(values.begin()), //cast static_cast(values.end()), //cast 1983); values.insert(static_cast(ci), 1998); //可能无法通过编译， //原因见下 C++11：容器的成员函数cbegin和cend产出const_iterator，甚至对于non-const容器也可用 std::vector values; //和之前一样 … auto it = //使用cbegin std::find(values.cbegin(), values.cend(), 1983);//和cend values.insert(it, 1998); C++14支持但是C++11的时候还没： 想写最大程度通用的库，并且这些库代码为一些容器和类似容器的数据结构提供begin、end（以及cbegin，cend，rbegin，rend等）作为非成员函数而不是成员函数 原生数组，还有一种情况是一些只由自由函数组成接口的第三方库 非成员函数cbegin的实现: template auto cbegin(const C& container)->decltype(std::begin(container)) { return std::begin(container); //解释见下 } 这个cbegin模板接受任何代表类似容器的数据结构的实参类型C 通过reference-to-const形参container访问这个实参 对const容器调用非成员函数begin（由C++11提供）将产出const_iterator 非成员函数cend的实现:同理 template auto cend(const C& container)->decltype(std::end(container)) { return std::end(container); //解释见下 } 总结 [!note] 优先考虑const_iterator而非iterator 在最大程度通用的代码中，优先考虑非成员函数版本的begin，end，rbegin等，而非同名成员函数 Item 14: Declare functions noexcept if they won’t emit exceptions noexcept 在C++98中，异常说明（exception specifications）是喜怒无常的野兽 不得不写出函数可能抛出的异常类型 如果函数实现有所改变，异常说明也可能需要修改 同时改变异常说明会影响客户端代码 在C++11标准化过程中，异常说明真正有用的信息是一个函数是否会抛出异常 一个函数可能抛异常，或者不会 在C++11中，无条件的noexcept保证函数不会抛出任何异常。 一个函数是否已经声明为noexcept是接口设计的事 函数的异常抛出行为是客户端代码最关心的 调用者可以查看函数是否声明为noexcept，这个可以影响到调用代码的异常安全性（exception safety）和效率 给不抛异常的函数加上noexcept的动机：它允许编译器生成更好的目标代码 //函数f，它保证调用者永远不会收到一个异常 int f(int x) throw(); //C++98风格，没有来自f的异常 int f(int x) noexcept; //C++11风格，没有来自f的异常 在运行时，f出现一个异常 C++98的异常说明中，用栈（the call stack）会展开至f的调用者，在一些与这地方不相关的动作后，程序被终止 C++11异常说明中，调用栈只是可能在程序终止前展开 展开调用栈和可能展开调用栈 展开调用栈和可能展开调用栈两者对于代码生成（code generation）有非常大的影响 在一个noexcept函数中，当异常可能传播到函数外时 优化器不需要保证运行时栈（the runtime stack）处于可展开状态 不需要保证当异常离开noexcept函数时，noexcept函数中的对象按照构造的反序析构 std::vector vw; … Widget w; … //用w做点事 vw.push_back(w); //把w添加进vw std::vector::push_back受益于“如果可以就移动，如果必要则复制”策略 std::vector的大小（size）等于它的容量（capacity）。这时候，std::vector会分配一个新的更大块的内存用于存放其中元素，然后将元素从老内存区移动到新内存区，然后析构老内存区里的对象。 这种方法使得push_back可以提供很强的异常安全保证：如果在复制元素期间抛出异常，std::vector状态保持不变 在C++11中，一个很自然的优化就是将上述复制操作替换为移动操作，这会破坏push_back的异常安全保证 swap swap函数是noexcept的另一个绝佳用地。 swap是STL算法实现的一个关键组件，它也常用于拷贝运算符重载中 标准库的swap是否noexcept有时依赖于用户定义的swap是否noexcept 数组和std::pair的swap声明如下 template void swap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b))); //见下文 template struct pair { … void swap(pair& p) noexcept(noexcept(swap(first, p.first)) && noexcept(swap(second, p.second))); … }; 这些函数视情况noexcept：它们是否noexcept依赖于noexcept声明中的表达式是否noexcept。 事实上交换高层次数据结构是否noexcept取决于它的构成部分的那些低层次数据结构是否noexcept 异常中立 仅当你保证一个函数实现在长时间内不会抛出异常时才声明noexcept。 大多数函数都是异常中立（exception-neutral）的 这些函数自己不抛异常，但是它们内部的调用可能抛出异常。 异常中立函数允许那些抛出异常的函数在调用链上更进一步直到遇到异常处理程序，而不是就地终止。 异常中立函数决不应该声明为noexcept 为了noexcept而扭曲函数实现来达成目的是本末倒置 为了讨好调用者隐藏了这个（比如捕获所有异常，然后替换为状态码或者特殊返回值），这不仅会使你的函数实现变得复杂，还会让调用点的代码变得复杂 调用者可能不得不检查状态码或特殊返回值 一些函数，使其成为noexcept是很重要的 在C++98，允许内存释放（memory deallocation）函数（即operator delete和operator delete[]）和析构函数抛出异常是糟糕的代码设计 C++11，默认情况下，内存释放函数和析构函数——不管是用户定义的还是编译器生成的——都是隐式noexcept [!tip] 析构函数非隐式noexcept的情况： 仅当类的数据成员（包括继承的成员还有继承成员内的数据成员）明确声明它的析构函数可能抛出异常（如声明“noexcept(false)”） 宽泛契约（wild contracts）和严格契约（narrow contracts） 有宽泛契约的函数没有前置条件 这种函数不管程序状态如何都能调用，它对调用者传来的实参不设约束 “不管程序状态如何”和“不设约束”对已经行为未定义的程序无效: 宽泛契约的函数决不表现出未定义行为。 没有宽泛契约的函数就有严格契约 这些函数，如果违反前置条件，结果将会是未定义的。 区分严格/宽泛契约库设计者一般会将noexcept留给宽泛契约函数 总结 [!note] noexcept是函数接口的一部分，这意味着调用者可能会依赖它 noexcept函数较之于non-noexcept函数更容易优化 noexcept对于移动语义，swap，内存释放函数和析构函数非常有用 大多数函数是异常中立的（译注：可能抛也可能不抛异常）而不是noexcept Item 15: Use constexpr whenever possible constexpr 当用于对象上面，constexpr本质上就是const的加强形式 从概念上来说，constexpr表明一个值不仅仅是常量，还是编译期可知的。 你不能假设constexpr函数的结果是const，也不能保证它们的（译注：返回）值是在编译期可知的。 关于constexpr函数返回的结果不需要是const，也不需要编译期可知这一点是良好的行为！ constexpr对象 这些constexpr对象，实际上，和const一样，它们是编译期可知的。 技术上来讲，它们的值在翻译期（translation）决议，所谓翻译不仅仅包含是编译（compilation）也包含链接（linking) 编译期可知的值“享有特权”，它们可能被存放到只读存储空间中。 “其值编译期可知”的常量整数会出现在需要“整型常量表达式（integral constant expression）的上下文中 包括数组大小，整数模板参数（包括std::array对象的长度），枚举名的值，对齐修饰符（译注：alignas(val)），等等 int sz; //non-constexpr变量 … constexpr auto arraySize1 = sz; //错误！sz的值在 //编译期不可知 std::array data1; //错误！一样的问题 constexpr auto arraySize2 = 10; //没问题，10是 //编译期可知常量 std::array data2; //没问题, arraySize2是constexpr 所有constexpr对象都是const，但不是所有const对象都是constexpr 想编译器保证一个变量有一个值可以放到那些需要编译期常量（compile-time constants）的上下文的地方，你需要的工具是constexpr而不是const constexpr函数 如果实参是编译期常量，这些函数将产出编译期常量 如果实参是运行时才能知道的值，它们就将产出运行时值 constexpr函数可以用于需求编译期常量的上下文。如果你传给constexpr函数的实参在编译期可知，那么结果将在编译期计算。 当一个constexpr函数被一个或者多个编译期不可知值调用时，它就像普通函数一样，运行时计算它的结果。 pow 存所有实验结果的所有组合需要足够存放3n个值的数据结构。假设每个结果都是int并且n是编译期已知的（或者可以被计算出的） 我们需要一个方法在编译期计算3n，但是这里有两个问题 std::pow是为浮点类型设计的，我们需要整型结果。 std::pow不是constexpr（即，不保证使用编译期可知值调用而得到编译期可知的结果），所以我们不能用它作为std::array的大小 constexpr //pow是绝不抛异常的 int pow(int base, int exp) noexcept //constexpr函数 { … //实现在下面 } constexpr auto numConds = 5; //（上面例子中）条件的个数 std::array results; //结果有3^numConds个元素 pow不止可以用于像std::array的大小这种需要编译期常量的地方，它也可以用于运行时环境 constexpr函数限制 C++11中，constexpr函数的代码不超过一行语句：一个return。 有两个技巧可以扩展constexpr函数的表达能力 使用三元运算符“?:”来代替if-else语句 使用递归代替循环 constexpr int pow(int base, int exp) noexcept { return (exp == 0 ? 1 : base * pow(base, exp - 1)); } 在C++14中，constexpr函数的限制变得非常宽松 constexpr int pow(int base, int exp) noexcept //C++14 { auto result = 1; for (int i = 0; i constexpr函数限制为只能获取和返回字面值类型 在C++11中，除了void外的所有内置类型，以及一些用户定义类型都可以是字面值类型，因为构造函数和其他成员函数可能是constexpr class Point { public: constexpr Point(double xVal = 0, double yVal = 0) noexcept : x(xVal), y(yVal) {} constexpr double xValue() const noexcept { return x; } constexpr double yValue() const noexcept { return y; } void setX(double newX) noexcept { x = newX; } void setY(double newY) noexcept { y = newY; } private: double x, y; }; 类似的，xValue和yValue的getter（取值器）函数也能是constexpr，这使得我们可以写一个constexpr函数，里面调用Point的getter并初始化constexpr的对象： constexpr Point midpoint(const Point& p1, const Point& p2) noexcept { return { (p1.xValue() + p2.xValue()) / 2, //调用constexpr (p1.yValue() + p2.yValue()) / 2 }; //成员函数 } constexpr auto mid = midpoint(p1, p2); //使用constexpr函数的结果 //初始化constexpr对象 意味着以前相对严格的编译期完成的工作和运行时完成的工作的界限变得模糊，一些传统上在运行时的计算过程能并入编译时。越多这样的代码并入，你的程序就越快。（然而，编译会花费更长时间） [!warning] 在C++11中，有两个限制使得Point的成员函数setX和setY不能声明为constexpr 它们修改它们操作的对象的状态， 并且在C++11中，constexpr成员函数是隐式的const void类型不是C++11中的字面值类型。 总结 [!note] constexpr对象是const，它被在编译期可知的值初始化 当传递编译期可知的值时，constexpr函数可以产出编译期可知的结果 constexpr对象和函数可以使用的范围比non-constexpr对象和函数要大 constexpr是对象和函数接口的一部分 Item 16: Make const member functions thread safe const成员函数 class Polynomial { public: using RootsType = //数据结构保存多项式为零的值 std::vector; //（“using” 的信息查看条款9） … RootsType roots() const; … }; 这样的一个函数它不会更改多项被声明为const函数。 缓存多项式的根，然后实现roots来返回缓存的值 class Polynomial { public: using RootsType = std::vector; RootsType roots() const { if (!rootsAreValid) { //如果缓存不可用 … //计算根 //用rootVals存储它们 rootsAreValid = true; } return rootVals; } private: //mutable的经典使用样例,在被const修饰的函数里面也能被修改。 mutable bool rootsAreValid{ false }; //初始化器（initializer）的 mutable RootsType rootVals{}; //更多信息请查看条款7 }; [!warning] mutable关键词 mutable只能作用在类成员上，指示其数据总是可变的。 const修饰的方法（常成员函数）中，mutable修饰的成员数据可以发生改变 假设现在有两个线程同时调用Polynomial对象的roots方法: Polynomial p; … /*------ Thread 1 ------*/ /*-------- Thread 2 --------*/ auto rootsOfp = p.roots(); auto valsGivingZero = p.roots(); 这些线程中的一个或两个可能尝试修改成员变量rootsAreValid和rootVals。 没有同步的情况下，这些代码会有不同的线程读写相同的内存，这就是数据竞争（data race）的定义 问题就是roots被声明为const，但不是线程安全的。 解决这个问题最普遍简单的方法就是——使用mutex（互斥量）： class Polynomial { public: using RootsType = std::vector; RootsType roots() const { //自动管理互斥锁的机制，确保互斥锁在作用域结束时自动释放 std::lock_guard g(m); //锁定互斥量 if (!rootsAreValid) { //如果缓存无效 … //计算/存储根值 rootsAreValid = true; } return rootsVals; } //解锁互斥量 private: mutable std::mutex m; mutable bool rootsAreValid { false }; mutable RootsType rootsVals {}; }; std::mutex 既不可移动，也不可复制。因而包含他们的类也同时是不可移动和不可复制的。 如果你所做的只是计算成员函数被调用了多少次，使用std::atomic 修饰的计数器 开销更小 class Point { //2D点 public: … double distanceFromOrigin() const noexcept //noexcept的使用 { //参考条款14 ++callCount; //atomic的递增 return std::sqrt((x * x) + (y * y)); } private: mutable std::atomic callCount{ 0 }; double x, y; }; 实际上 std::atomic 既不可移动，也不可复制 因为对std::atomic变量的操作通常比互斥量的获取和释放的消耗更小，所以你可能会过度倾向与依赖std::atomic 在一个类中，缓存一个开销昂贵的int，你就会尝试使用一对std::atomic变量而不是互斥量。 class Widget { public: … int magicValue() const { if (cacheValid) return cachedValue; else { auto val1 = expensiveComputation1(); auto val2 = expensiveComputation2(); cachedValue = val1 + val2; //第一步 cacheValid = true; //第二步 return cachedValid; } } private: mutable std::atomic cacheValid{ false }; mutable std::atomic cachedValue; }; 难以避免有时出现重复计算的情况: 一个线程调用Widget::magicValue，将cacheValid视为false，执行这两个昂贵的计算，并将它们的和分配给cachedValue。 第二个线程调用Widget::magicValue，也将cacheValid视为false，因此执行刚才完成的第一个线程相同的计算。（这里的“第二个线程”实际上可能是其他几个线程。） 将cachedValue和CacheValid的赋值顺序交换可以解决这个问题，但结果会更糟： class Widget { public: … int magicValue() const { if (cacheValid) return cachedValue; else { auto val1 = expensiveComputation1(); auto val2 = expensiveComputation2(); cacheValid = true; //第一步 return cachedValue = val1 + val2; //第二步 } } … } 一个线程调用Widget::magicValue，刚执行完将cacheValid设置true的语句。 在这时，第二个线程调用Widget::magicValue，检查cacheValid。看到它是true，就返回cacheValue，即使第一个线程还没有给它赋值。因此返回的值是不正确的。 [!warning] 对于需要同步的是单个的变量或者内存位置，使用std::atomic就足够了。 一旦你需要对两个以上的变量或内存位置作为一个单元来操作的话，就应该使用互斥量 所以对于Widget::magicValue是这样的： class Widget { public: … int magicValue() const { std::lock_guard guard(m); //锁定m if (cacheValid) return cachedValue; else { auto val1 = expensiveComputation1(); auto val2 = expensiveComputation2(); cachedValue = val1 + val2; cacheValid = true; return cachedValue; } } //解锁m … private: mutable std::mutex m; mutable int cachedValue; //不再用atomic mutable bool cacheValid{ false }; //不再用atomic }; const成员函数应支持并发执行，这就是为什么你应该确保const成员函数是线程安全的。 总结 [!note] 确保const成员函数线程安全，除非你确定它们永远不会在并发上下文（concurrent context）中使用。 使用std::atomic变量可能比互斥量提供更好的性能，但是它只适合操作单个变量或内存位置。 Item 17: Understand special member function generation 特殊成员函数 特殊成员函数是指C++自己生成的函数 C++98有四个：默认构造函数，析构函数，拷贝构造函数，拷贝赋值运算符 这些函数仅在需要的时候才生成，比如某个代码使用它们但是它们没有在类中明确声明 特殊成员函数的默认特性： 隐式public且inline：编译器生成的特殊成员函数默认是公开的（public）并且是内联的（inline），这意味着它们可以在类定义中直接定义，而不需要在类外单独定义。 非虚：这些函数默认是非虚的（non-virtual），即它们不会参与多态。 特殊情况：虚析构函数，派生类继承了有虚析构函数的基类。在这种情况下，编译器为派生类生成的析构函数是虚的。 移动构造函数和移动赋值运算符 C++11两个新的特殊成员函数：移动构造函数和移动赋值运算符 class Widget { public: … Widget(Widget&& rhs); //移动构造函数 Widget& operator=(Widget&& rhs); //移动赋值运算符 … }; 对不可移动类型（即对移动操作没有特殊支持的类型，比如大部分C++98传统类）使用“移动”操作实际上执行的是拷贝操作 逐成员移动的核心是对对象使用std::move 支持移动就会逐成员移动类成员和基类成员，如果不支持移动就执行拷贝操作 生成默认移动构造或者赋值函数的精确条件与拷贝操作的条件有点不同。 两个拷贝操作是独立的：声明一个不会限制编译器生成另一个。 两个移动操作不是相互独立的。如果你声明了其中一个，编译器就不再生成另一个。 如果一个类显式声明了拷贝操作，编译器就不会生成移动操作 同样，声明移动操作（构造或赋值）使得编译器禁用拷贝操作。 Rule of Three 如果你声明了拷贝构造函数，拷贝赋值运算符，或者析构函数三者之一，你应该也声明其余两个。 用户接管拷贝操作的需求几乎都是因为该类会做其他资源的管理 无论哪种资源管理如果在一个拷贝操作内完成，也应该在另一个拷贝操作内完成 类的析构函数也需要参与资源的管理（通常是释放）。通常要管理的资源是内存 只要出现用户定义的析构函数就意味着简单的逐成员拷贝操作不适用于该类。 如果一个类声明了析构，拷贝操作可能不应该自动生成，因为它们做的事情可能是错误的 Rule of Three规则背后的解释依然有效，再加上对声明拷贝操作阻止移动操作隐式生成的观察 C++11不会为那些有用户定义的析构函数的类生成移动操作。 所以仅当下面条件成立时才会生成移动操作（当需要时）： 类中没有拷贝操作 类中没有移动操作 类中没有用户定义的析构 类似的规则也会扩展至拷贝操作上面 如果你的某个声明了析构或者拷贝的类依赖自动生成的拷贝操作，你应该考虑升级这些类，消除依赖。 假设编译器生成的函数行为是正确的（即逐成员拷贝类non-static数据是你期望的行为），C++11的= default就可以： class Widget { public: … ~Widget(); //用户声明的析构函数 … //默认拷贝构造函数 Widget(const Widget&) = default; //的行为还可以 Widget& //默认拷贝赋值运算符 operator=(const Widget&) = default; //的行为还可以 … }; 除非类继承了一个已经是virtual的析构函数，否则要想析构函数为虚函数的唯一方法就是加上virtual关键字。 用户声明的析构函数会抑制编译器生成移动操作，所以如果该类需要具有移动性，就为移动操作加上= default 声明移动会抑制拷贝生成，所以如果拷贝性也需要支持，再为拷贝操作加上= default： class Base { public: virtual ~Base() = default; //使析构函数virtual Base(Base&&) = default; //支持移动 Base& operator=(Base&&) = default; Base(const Base&) = default; //支持拷贝 Base& operator=(const Base&) = default; … }; 应该手动声明它们然后加上= default，让你的意图更明确 C++11对于特殊成员函数处理的规则 [!tip] 默认构造函数：和C++98规则相同。仅当类不存在用户声明的构造函数时才自动生成。 析构函数：基本上和C++98相同；稍微不同的是现在析构默认noexcept（参见Item14）。和C++98一样，仅当基类析构为虚函数时该类析构才为虚函数。 拷贝构造函数：和C++98运行时行为一样：逐成员拷贝non-static数据。仅当类没有用户定义的拷贝构造时才生成。如果类声明了移动操作它就是delete的。当用户声明了拷贝赋值或者析构，该函数自动生成已被废弃。 拷贝赋值运算符：和C++98运行时行为一样：逐成员拷贝赋值non-static数据。仅当类没有用户定义的拷贝赋值时才生成。如果类声明了移动操作它就是delete的。当用户声明了拷贝构造或者析构，该函数自动生成已被废弃。 移动构造函数和移动赋值运算符：都对非static数据执行逐成员移动。仅当类没有用户定义的拷贝操作，移动操作或析构时才自动生成。 注意没有“成员函数模版阻止编译器生成特殊成员函数”的规则 class Widget { … template //从任何东西构造Widget Widget(const T& rhs); template //从任何东西赋值给Widget Widget& operator=(const T& rhs); … }; 编译器仍会生成移动和拷贝操作（假设正常生成它们的条件满足），即使可以模板实例化产出拷贝构造和拷贝赋值运算符的函数签名。 总结 [!note] 特殊成员函数是编译器可能自动生成的函数：默认构造函数，析构函数，拷贝操作，移动操作。 移动操作仅当类没有显式声明移动操作，拷贝操作，析构函数时才自动生成。 拷贝构造函数仅当类没有显式声明拷贝构造函数时才自动生成，并且如果用户声明了移动操作，拷贝构造就是delete。拷贝赋值运算符仅当类没有显式声明拷贝赋值运算符时才自动生成，并且如果用户声明了移动操作，拷贝赋值运算符就是delete。当用户声明了析构函数，拷贝操作的自动生成已被废弃。 成员函数模板不抑制特殊成员函数的生成。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - CHAPTER_3_Moving_to_Modern_C++ "},"docs/Cpp/Effective-Modern-C++/CHAPTER_4_Smart_Pointers.html":{"url":"docs/Cpp/Effective-Modern-C++/CHAPTER_4_Smart_Pointers.html","title":"CHAPTER_4_Smart_Pointers","keywords":"","body":" 第4章 智能指针 Item 18: Use std::unique_ptr for exclusive-ownership resource management std::unique_ptr std::unique_ptr的常见用法 std::unique_ptr形式 总结 Item 19: Use std::shared_ptr for shared-ownership resource management std::shared_ptr std::shared_ptr的引用计数 引用计数性能问题 std::shared_ptr销毁机制 std::enable_shared_from_this std::shared_ptr开销 总结 Item 20: Use std::weak_ptr for std::shared_ptr-like pointers that can dangle std::weak_ptr std::weak_ptr过期问题 std::weak_ptr用例 总结 Item 21: Prefer std::make_unique and std::make_shared to direct use of new std::make_unique ans std::make_shared make函数缺点 边缘情况 总结 Item 22: When using the Pimpl Idiom, define special member functions in the implementation file Pimpl（pointer to implementation）惯用法 换成std::shared_ptr 总结 [TOC] 第4章 智能指针 原始指针的缺点 它的声明不能指示所指到底是单个对象还是数组。 它的声明没有告诉你用完后是否应该销毁它，即指针是否拥有所指之物。 如果你决定你应该销毁指针所指对象，没人告诉你该用delete还是其他析构机制（比如将指针传给专门的销毁函数）。 如果你发现该用delete。 原因1说了可能不知道该用单个对象形式（“delete”）还是数组形式（“delete[]”）。如果用错了结果是未定义的。 假设你确定了指针所指，知道销毁机制，也很难确定你在所有执行路径上都执行了恰为一次销毁操作（包括异常产生后的路径）。少一条路径就会产生资源泄漏，销毁多次还会导致未定义行为。 一般来说没有办法告诉你指针是否变成了悬空指针（dangling pointers），即内存中不再存在指针所指之物。在对象销毁后指针仍指向它们就会产生悬空指针。 智能指针 智能指针包裹原始指针，它们的行为看起来像被包裹的原始指针，但避免了原始指针的很多陷阱 在C++11中存在四种智能指针 std::auto_ptr是来自C++98的已废弃遗留物，它是一次标准化的尝试，后来变成了C++11的std::unique_ptr。拷贝一个std::auto_ptr会将它本身设置为null！）和令人沮丧的使用限制（比如不能将std::auto_ptr放入容器）。 std::unique_ptr在所有方面它都比std::auto_ptr好。 在std::auto_ptr唯一合法的使用场景就是代码使用C++98编译器编译。 Item 18: Use std::unique_ptr for exclusive-ownership resource management std::unique_ptr 默认情况下，std::unique_ptr大小等同于原始指针，而且对于大多数操作（包括取消引用） 可以在内存和时间都比较紧张的情况下使用它。如果原始指针够小够快，那么std::unique_ptr一样可以。 std::unique_ptr体现了专有所有权（exclusive ownership）语义。 具体来说，一个non-null std::unique_ptr始终拥有其指向的内容。 移动一个std::unique_ptr将所有权从源指针转移到目的指针。（源指针被设为null。） 拷贝一个std::unique_ptr是不允许的， std::unique_ptr是一种只可移动类型（move-only type）。当析构(原始指针调用delete)时，一个non-null std::unique_ptr销毁它指向的资源。 std::unique_ptr的常见用法 std::unique_ptr的常见用法是作为继承层次结构中对象的工厂函数返回类型。 假设我们有一个投资类型（比如股票、债券、房地产等）的继承结构，使用基类Investment。 class Investment { … }; class Stock: public Investment { … }; class Bond: public Investment { … }; class RealEstate: public Investment { … }; 这种继承关系的工厂函数在堆上分配一个对象然后返回指针，调用方在不需要的时候有责任销毁对象。 使用场景完美匹配std::unique_ptr，因为调用者对工厂返回的资源负责（即对该资源的专有所有权），并且std::unique_ptr在自己被销毁时会自动销毁指向的内容。 //Investment继承关系的工厂函数 template //返回指向对象的std::unique_ptr， std::unique_ptr //对象使用给定实参创建 makeInvestment(Ts&&... params); 但是也可以在所有权转移的场景中使用它 比如将工厂返回的std::unique_ptr移入容器中，然后将容器元素移入一个对象的数据成员中，然后对象过后被销毁。 发生这种情况时，这个对象的std::unique_ptr数据成员也被销毁，并且智能指针数据成员的析构将导致从工厂返回的资源被销毁。 默认情况下，销毁将通过delete进行，但是在构造过程中，std::unique_ptr对象可以被设置为使用（对资源的）自定义删除器：当资源需要销毁时可调用的任意函数（或者函数对象，包括lambda表达式） auto delInvmt = [](Investment* pInvestment) //自定义删除器 { //（lambda表达式） makeLogEntry(pInvestment); delete pInvestment; }; template std::unique_ptr //更改后的返回类型 makeInvestment(Ts&&... params) { std::unique_ptr //应返回的指针 //makeInvestment的基本策略是创建一个空的std::unique_ptr，然后指向一个合适类型的对象，然后返回。 pInv(nullptr, delInvmt); //过reset来让pInv接管通过new创建的对象的所有权 if (/*一个Stock对象应被创建*/) { pInv.reset(new Stock(std::forward(params)...)); } else if ( /*一个Bond对象应被创建*/ ) { pInv.reset(new Bond(std::forward(params)...)); } else if ( /*一个RealEstate对象应被创建*/ ) { pInv.reset(new RealEstate(std::forward(params)...)); } return pInv; } 们通过基类指针删除派生类实例，为此，基类Investment必须有虚析构函数： class Investment { public: … virtual ~Investment(); //关键设计部分！ … }; 在C++14中，函数返回类型推导的存在（参阅Item3），意味着makeInvestment可以以更简单，更封装的方式实现： template auto makeInvestment(Ts&&... params) //C++14 { auto delInvmt = [](Investment* pInvestment) //现在在 { //makeInvestment里 makeLogEntry(pInvestment); delete pInvestment; }; std::unique_ptr //同之前一样 pInv(nullptr, delInvmt); if ( … ) //同之前一样 { pInv.reset(new Stock(std::forward(params)...)); } else if ( … ) //同之前一样 { pInv.reset(new Bond(std::forward(params)...)); } else if ( … ) //同之前一样 { pInv.reset(new RealEstate(std::forward(params)...)); } return pInv; //同之前一样 } 对于函数对象形式的删除器来说，变化的大小取决于函数对象中存储的状态多少，无状态函数（stateless function）对象（比如不捕获变量的lambda表达式）对大小没有影响 这意味当自定义删除器可以实现为函数或者lambda时，尽量使用lambda： auto delInvmt1 = [](Investment* pInvestment) //无状态lambda的 { //自定义删除器 makeLogEntry(pInvestment); delete pInvestment; }; template //返回类型大小是 std::unique_ptr //Investment*的大小 makeInvestment(Ts&&... args); void delInvmt2(Investment* pInvestment) //函数形式的 { //自定义删除器 makeLogEntry(pInvestment); delete pInvestment; } template //返回类型大小是 std::unique_ptr //Investment*的指针 makeInvestment(Ts&&... params); //加至少一个函数指针的大小 工厂函数不是std::unique_ptr的唯一常见用法。作为实现Pimpl Idiom（译注：pointer to implementation，一种隐藏实际实现而减弱编译依赖性的设计思想 std::unique_ptr形式 用于单个对象（std::unique_ptr）， 用于数组（std::unique_ptr） [!tip] std::unique_ptr的API设计会自动匹配你的用法， 比如operator[]就是数组对象，解引用操作符（operator*和operator->）就是单个对象专有。 std::unique_ptr是C++11中表示专有所有权的方法，但是其最吸引人的功能之一是它可以轻松高效的转换为std::shared_ptr： std::shared_ptr sp = //将std::unique_ptr makeInvestment(arguments); //转为std::shared_ptr 通过返回std::unique_ptr，工厂为调用者提供了最有效的智能指针，但它们并不妨碍调用者用其更灵活的兄弟替换它。 总结 [!note] std::unique_ptr是轻量级、快速的、只可移动（move-only）的管理专有所有权语义资源的智能指针 默认情况，资源销毁通过delete实现，但是支持自定义删除器。有状态的删除器和函数指针会增加std::unique_ptr对象的大小 将std::unique_ptr转化为std::shared_ptr非常简单 Item 19: Use std::shared_ptr for shared-ownership resource management std::shared_ptr 一个自动工作的世界（像是垃圾回收），一个销毁可预测的世界（像是析构) C++11中的std::shared_ptr将两者组合了起来。 一个通过std::shared_ptr访问的对象其生命周期由指向它的有共享所有权（shared ownership）的指针们来管理 没有特定的std::shared_ptr拥有该对象。 当最后一个指向某对象的std::shared_ptr不再指向那（比如因为std::shared_ptr被销毁或者指向另一个不同的对象），std::shared_ptr会销毁它所指向的对象。 就垃圾回收来说，客户端不需要关心指向对象的生命周期，而对象的析构是确定性的（没有std::unique_ptr指向该对象） std::shared_ptr的引用计数 std::shared_ptr通过引用计数（reference count）来确保它是否是最后一个指向某种资源的指针，引用计数关联资源并跟踪有多少std::shared_ptr指向该资源。 std::shared_ptr构造函数递增引用计数值（注意是通常——原因参见下面），析构函数递减值，拷贝赋值运算符做前面这两个工作。 具体来说，sp1和sp2是std::shared_ptr并且指向不同对象 赋值“sp1 = sp2;”会使sp1指向sp2指向的对象。直接效果就是sp1引用计数减一，sp2引用计数加一 如果std::shared_ptr在计数值递减后发现引用计数值为零，没有其他std::shared_ptr指向该资源，它就会销毁资源。 引用计数性能问题 std::shared_ptr大小是原始指针的两倍，因为它内部包含一个指向资源的原始指针，还包含一个指向资源的引用计数值的原始指针。 引用计数的内存必须动态分配。被指向的对象不知道有一个关联到自己的计数值，所以任何对象——甚至是内置类型的——都可以由std::shared_ptr管理 递增递减引用计数必须是原子性的，多个reader、writer可能在不同的线程，即指向某种资源的std::shared_ptr可能在一个线程执行析构（于是递减指向的对象的引用计数），在另一个不同的线程执行的却是拷贝操作（因此递增了同一个引用计数）。而原子操作比非原子操作慢 为什么std::shared_ptr构造函数只是“通常”递增指向对象的引用计数？ 原因是移动构造函数的存在。 从另一个std::shared_ptr移动构造新std::shared_ptr会将原来的std::shared_ptr设置为null，那意味着老的std::shared_ptr不再指向资源，同时新的std::shared_ptr指向资源。结果就是不需要修改引用计数值 因此移动std::shared_ptr会比拷贝它要快 std::shared_ptr销毁机制 std::shared_ptr使用delete作为资源的默认销毁机制，但是它也支持自定义的删除器。 对于std::unique_ptr来说，删除器类型是智能指针类型的一部分。对于std::shared_ptr则删除器类型不是智能指针类型的一部分 auto loggingDel = [](Widget *pw) //自定义删除器 { //（和条款18一样） makeLogEntry(pw); delete pw; }; std::unique_ptr upw(new Widget, loggingDel); std::shared_ptr //删除器类型不是 spw(new Widget, loggingDel); //指针类型的一部分 考虑有两个std::shared_ptr，每个自带不同的删除器（比如通过lambda表达式自定义删除器） auto customDeleter1 = [](Widget *pw) { … }; //自定义删除器， auto customDeleter2 = [](Widget *pw) { … }; //每种类型不同 std::shared_ptr pw1(new Widget, customDeleter1); std::shared_ptr pw2(new Widget, customDeleter2); //pw1和pw2有相同的类型，所以它们都可以放到存放那个类型的对象的容器中 std::vector> vpw{ pw1, pw2 }; 同样，它们也能相互赋值，也可以传入一个形参为std::shared_ptr的函数。 但是自定义删除器类型不同的std::unique_ptr就不行，因为std::unique_ptr把删除器视作类型的一部分。 另一个不同于std::unique_ptr的地方是，指定自定义删除器不会改变std::shared_ptr对象的大小。 不管删除器是什么，一个std::shared_ptr对象都是两个指针大小。 每个std::shared_ptr管理的对象都有个相应的控制块。 控制块除了包含引用计数值外还有一个自定义删除器的拷贝，当然前提是存在自定义删除器。 对于一个创建指向对象的std::shared_ptr的函数来说不可能知道是否有其他std::shared_ptr早已指向那个对象，所以控制块的创建会遵循下面几条规则： std::make_shared（参见Item21）总是创建一个控制块。因为std::make_shared调用时创建一个要指向的新对象。 当从独占指针（即std::unique_ptr或者std::auto_ptr）上构造出std::shared_ptr时会创建控制块。因为独占指针没有使用控制块，所以指针指向的对象没有关联控制块。 当从原始指针上构造出std::shared_ptr时会创建控制块。相反，用std::shared_ptr或者std::weak_ptr作为构造函数实参创建std::shared_ptr不会创建新控制块，因为它可以依赖传递来的智能指针指向控制块。 这些规则造成的后果就是从原始指针上构造超过一个std::shared_ptr就会让你走上未定义行为的快车道 因为指向的对象有多个控制块关联。多个控制块意味着多个引用计数值，多个引用计数值意味着对象将会被销毁多次（每个引用计数一次） auto pw = new Widget; //pw是原始指针 … std::shared_ptr spw1(pw, loggingDel); //为*pw创建控制块 … std::shared_ptr spw2(pw, loggingDel); //为*pw创建第二个控制块 因此*pw有两个引用计数值，每一个最后都会变成零，然后最终导致*pw销毁两次。第二个销毁会产生未定义行为。 [!warning] 第一，避免传给std::shared_ptr构造函数原始指针。通常替代方案是使用std::make_shared（参见Item21） 第二，如果你必须传给std::shared_ptr构造函数原始指针，直接传new出来的结果，不要传指针变量。 std::shared_ptr spw1(new Widget, //直接使用new的结果 loggingDel); std::enable_shared_from_this 错误的部分是传递this，而不是使用了emplace_back。 void Widget::process() { … //处理Widget processedWidgets.emplace_back(this); //然后将它加到已处理过的Widget } //的列表中，这是错的！ std::shared_ptr会由此为指向的Widget（*this）创建一个控制块 如果成员函数外面早已存在指向那个Widget对象的指针，它是未定义行为 如果你想创建一个用std::shared_ptr管理的类，这个类能够用this指针安全地创建一个std::shared_ptr，std::enable_shared_from_this就可作为基类的模板类。 class Widget: public std::enable_shared_from_this { public: … void process(); … }; std::enable_shared_from_this定义了一个成员函数，成员函数会创建指向当前对象的std::shared_ptr却不创建多余控制块。 void Widget::process() { //和之前一样，处理Widget … //把指向当前对象的std::shared_ptr加入processedWidgets processedWidgets.emplace_back(shared_from_this()); } 从内部来说，shared_from_this查找当前对象控制块，然后创建一个新的std::shared_ptr关联这个控制块。 但是没有std::shared_ptr指向当前对象（即当前对象没有关联控制块），行为是未定义的，shared_from_this通常抛出一个异常。 防止客户端在存在一个指向对象的std::shared_ptr前先调用含有shared_from_this的成员函数，继承自std::enable_shared_from_this的类通常将它们的构造函数声明为private，并且让客户端通过返回std::shared_ptr的工厂函数创建对象。 class Widget: public std::enable_shared_from_this { public: //完美转发参数给private构造函数的工厂函数 template static std::shared_ptr create(Ts&&... params); … void process(); //和前面一样 … private: … //构造函数 }; std::shared_ptr开销 在通常情况下，使用默认删除器和默认分配器，使用std::make_shared创建std::shared_ptr，产生的控制块只需三个word大小。 对std::shared_ptr解引用的开销不会比原始指针高。 对于每个被std::shared_ptr指向的对象来说，控制块中的虚函数机制产生的开销通常只需要承受一次，即对象销毁的时候。 [!tip] 想想你是否需要共享所有权。如果独占资源可行或者可能可行，用std::unique_ptr是一个更好的选择。 std::unique_ptr的性能表现更接近于原始指针，并且从std::unique_ptr升级到std::shared_ptr也很容易， 反之不行。当你的资源由std::shared_ptr管理，现在又想修改资源生命周期管理方式是没有办法的。 std::shared_ptr不能处理的另一个东西是数组。 自 C++17 起 std::shared_ptr 可以用于管理动态分配的数组，使用 std::shared_ptr 总结 [!note] std::shared_ptr为有共享所有权的任意资源提供一种自动垃圾回收的便捷方式。 较之于std::unique_ptr，std::shared_ptr对象通常大两倍，控制块会产生开销，需要原子性的引用计数修改操作。 默认资源销毁是通过delete，但是也支持自定义删除器。删除器的类型是什么对于std::shared_ptr的类型没有影响。 避免从原始指针变量上创建std::shared_ptr。 Item 20: Use std::weak_ptr for std::shared_ptr-like pointers that can dangle std::weak_ptr std::weak_ptr最精确的描述：std::shared_ptr的增强 像std::shared_ptr（见Item19）的但是不参与资源所有权共享的指针 类似std::shared_ptr但不影响对象引用计数的指针 在悬空时知晓，悬空（dangle）就是指针指向的对象不再存在。 std::weak_ptr不能解引用，也不能测试是否为空值。 std::weak_ptr通常从std::shared_ptr上创建。 std::weak_ptr不会影响所指对象的引用计数 auto spw = //spw创建之后，指向的Widget的 std::make_shared(); //引用计数（ref count，RC）为1。 //std::make_shared的信息参见条款21 … std::weak_ptr wpw(spw); //wpw指向与spw所指相同的Widget。RC仍为1 … spw = nullptr; //RC变为0，Widget被销毁。 //wpw现在悬空 其中，悬空的std::weak_ptr被称作已经expired（过期） if (wpw.expired()) … //如果wpw没有指向对象… std::weak_ptr过期问题 [!warning] 通常你期望的是检查std::weak_ptr是否已经过期，如果没有过期则访问其指向的对象 将检查和解引用分开会引入竞态条件：在调用expired和解引用操作之间，另一个线程可能对指向这对象的std::shared_ptr重新赋值或者析构，并由此造成对象已析构。 解引用将会产生未定义行为 一个原子操作检查std::weak_ptr是否已经过期，如果没有过期就访问所指对象 [!tip] 通过从std::weak_ptr创建std::shared_ptr来实现， 具体用哪种取决于std::weak_ptr过期时你希望std::shared_ptr表现出什么行为： 一种形式是std::weak_ptr::lock，它返回一个std::shared_ptr，如果std::weak_ptr过期这个std::shared_ptr为空： std::shared_ptr spw1 = wpw.lock(); //如果wpw过期，spw1就为空 auto spw2 = wpw.lock(); //同上，但是使用auto 另一种形式是以std::weak_ptr为实参构造std::shared_ptr。如果std::weak_ptr过期，会抛出一个异常： std::shared_ptr spw3(wpw); //如果wpw过期，抛出std::bad_weak_ptr异常 std::weak_ptr用例 考虑一个工厂函数，它基于一个唯一ID从只读对象上产出智能指针。根据Item18的描述，工厂函数会返回一个该对象类型的std::unique_ptr： std::unique_ptr loadWidget(WidgetID id); 并且调用loadWidget是一个昂贵的操作（比如它操作文件或者数据库I/O）并且重复使用ID很常见 合理的优化是再写一个函数除了完成loadWidget做的事情之外再缓存它的结果 另一个合理的优化可以是当Widget不再使用的时候销毁它的缓存。 对于可缓存的工厂函数，返回std::unique_ptr不是好的选择。 缓存对象的指针需要知道它是否已经悬空，因为当工厂客户端使用完工厂产生的对象后，对象将被销毁，关联的缓存条目会悬空。 所以缓存应该使用std::weak_ptr，这可以知道是否已经悬空。 //当对象的生命周期由std::shared_ptr管理时，std::weak_ptr才能检测到悬空。 std::shared_ptr fastLoadWidget(WidgetID id) { static std::unordered_map> cache; //译者注：这里std::weak_ptr是高亮 auto objPtr = cache[id].lock(); //objPtr是去缓存对象的 //std::shared_ptr（或 //当对象不在缓存中时为null） if (!objPtr) { //如果不在缓存中 objPtr = loadWidget(id); //加载它 cache[id] = objPtr; //缓存它 } return objPtr; } fastLoadWidget的实现忽略了以下事实：缓存可能会累积过期的std::weak_ptr，这些指针对应了不再使用的Widget（也已经被销毁了） 让我们考虑第二个用例：观察者设计模式（Observer design pattern） 此模式的主要组件是subjects（状态可能会更改的对象）和observers（状态发生更改时要通知的对象） 在大多数实现中，每个subject都包含一个数据成员，该成员持有指向其observers的指针。这使subjects很容易发布状态更改通知。 一个合理的设计是每个subject持有一个std::weak_ptrs容器指向observers，因此可以在使用前检查是否已经悬空。 最后一个使用std::weak_ptr的例子 A和C共享B的所有权，因此持有std::shared_ptr： 假定从B指向A的指针也很有用。应该使用哪种指针？ 有三种选择： 原始指针。如果A被销毁，但是C继续指向B，B就会有一个指向A的悬空指针。 std::shared_ptr。A和B都互相持有对方的std::shared_ptr，导致的std::shared_ptr环状结构（A指向B，B指向A）阻止A和B的销毁。当没有指针（C不再指向B）指向A和B的环形结构，每个的引用计数都还是1，无法降为0，A和B都被泄漏：程序无法访问它们，但是资源并没有被回收。 std::weak_ptr。则避免了上述两个问题。并且破坏了A和B的环形结构。 [!tip] 需要注意使用std::weak_ptr打破std::shared_ptr循环并不常见 在严格分层的数据结构比如树中，子节点只被父节点持有。当父节点被销毁时，子节点就被销毁。 因此没有子节点解引用一个悬垂的父节点指针这样的风险。 效率角度来看，std::weak_ptr与std::shared_ptr基本相同。 大小是相同的，使用相同的控制块（参见Item19），构造、析构、赋值操作涉及引用计数的原子操作。 [!warning] std::weak_ptr不参与对象的共享所有权，因此不影响指向对象的引用计数。实际上在控制块中还是有第二个引用计数，std::weak_ptr操作的是第二个引用计数。 总结 [!note] 用std::weak_ptr替代可能会悬空的std::shared_ptr。 std::weak_ptr的潜在使用场景包括：缓存、观察者列表、打破std::shared_ptr环状结构。 Item 21: Prefer std::make_unique and std::make_shared to direct use of new std::make_unique ans std::make_shared std::make_unique从C++14开始加入标准库。 使用C++11，自己写一个基础版本的std::make_unique如下： template std::unique_ptr make_unique(Ts&&... params) { return std::unique_ptr(new T(std::forward(params)...)); } make_unique只是将它的参数完美转发到所要创建的对象的构造函数 这种形式的函数不支持数组和自定义析构（见Item18） 三个make函数 std::make_unique和std::make_shared：接收任意的多参数集合，完美转发到构造函数去动态分配一个对象，然后返回这个指向这个对象的指针。 std::allocate_shared。它行为和std::make_shared一样，只不过第一个参数是用来动态分配内存的allocator对象。 用和不用make函数来创建智能指针的一个小小比较 auto upw1(std::make_unique()); //使用make函数 std::unique_ptr upw2(new Widget); //不使用make函数 auto spw1(std::make_shared()); //使用make函数 std::shared_ptr spw2(new Widget); //不使用make函数 用new的声明语句需要写2遍Widget，make函数只需要写一次，源代码中的重复增加了编译的时间，会导致目标代码冗余，并且通常会让代码库使用更加困难。 第二个使用make函数的原因和异常安全有关 有个函数按照某种优先级处理Widget void processWidget(std::shared_ptr spw, int priority); //计算相关的优先级 int computePriority(); processWidget(std::shared_ptr(new Widget), //潜在的资源泄漏！ computePriority()); 代码可能在new一个Widget时发生泄漏。为何？ [!tip] 答案和编译器将源码转换为目标代码有关。 一个函数的实参必须先被计算，这个函数再被调用 调用processWidget之前: 表达式“new Widget”必须计算，例如，一个Widget对象必须在堆上被创建 负责管理new出来指针的std::shared_ptr构造函数必须被执行 computePriority必须运行 编译器不需要按照执行顺序生成代码。 std::make_shared可以防止这种问题 processWidget(std::make_shared(), //没有潜在的资源泄漏 computePriority()); std::make_shared的一个特性（与直接使用new相比）是效率提升。 使用std::make_shared允许编译器生成更小，更快的代码，并使用更简洁的数据结构。 对new的直接使用:std::shared_ptr spw(new Widget);进行内存分配两次 new需要为Widget进行一次内存分配 控制块的内存在std::shared_ptr构造函数中分配 std::make_shared分配一块内存，同时容纳了Widget对象和控制块。 使用std::make_shared避免了对控制块中的某些簿记信息的需要，潜在地减少了程序的总内存占用。 效率分析同样适用于std::allocate_shared make函数缺点 make函数都不允许指定自定义删除器，但是std::unique_ptr和std::shared_ptr的构造函数可以接收一个删除器参数 auto widgetDeleter = [](Widget* pw) { … }; //只能直接使用new std::unique_ptr upw(new Widget, widgetDeleter); std::shared_ptr spw(new Widget, widgetDeleter); make函数第二个限制来自于其实现中的语法细节。 make函数会将它们的参数完美转发给对象构造函数使用小括号 花括号初始化无法完美转发。但是，Item30介绍了一个变通的方法：使用auto类型推导从花括号初始化创建std::initializer_list对象 //创建std::initializer_list auto initList = { 10, 20 }; //使用std::initializer_list为形参的构造函数创建std::vector auto spv = std::make_shared>(initList); 对于std::unique_ptr，只有这两种情景（自定义删除器和花括号初始化）使用make函数有点问题。 边缘情况 使用make函数去创建重载了operator new和operator delete类的对象 std::allocate_shared需要的内存总大小不等于动态分配的对象大小，还需要再加上控制块大小 而一些类重载了operator new和operator delete。这些函数的存在意味着对这些类型的对象的全局内存分配和释放是不合常规的。设计这种定制操作往往只会精确的分配、释放对象大小的内存。 如果对象类型非常大，而且销毁最后一个std::shared_ptr和销毁最后一个std::weak_ptr之间的时间很长，那么在销毁对象和释放它所占用的内存之间可能会出现延迟。 只要std::weak_ptrs引用一个控制块（即weak count大于零），该控制块必须继续存在。只要控制块存在，包含它的内存就必须保持分配。 确保在直接使用new时，在一个不做其他事情的语句中，立即将结果传递到智能指针构造函数。 总结 [!note] 和直接使用new相比，make函数消除了代码重复，提高了异常安全性。对于std::make_shared和std::allocate_shared，生成的代码更小更快。 不适合使用make函数的情况包括需要指定自定义删除器和希望用花括号初始化。 对于std::shared_ptrs，其他不建议使用make函数的情况包括(1)有自定义内存管理的类；(2)特别关注内存的系统，非常大的对象，以及std::weak_ptrs比对应的std::shared_ptrs活得更久。 Item 22: When using the Pimpl Idiom, define special member functions in the implementation file Pimpl（pointer to implementation）惯用法 Pimpl（pointer to implementation）惯用法是一种技巧 将类数据成员替换成一个指向包含具体实现的类（或结构体）的指针 并将放在主类（primary class）的数据成员们移动到实现类（implementation class）去 这些数据成员的访问将通过指针间接访问 class Widget() { //定义在头文件“widget.h” public: Widget(); … private: std::string name; std::vector data; Gadget g1, g2, g3; //Gadget是用户自定义的类型 }; gadget.h可能会经常修订 在C++98中使用Pimpl惯用法，可以把Widget的数据成员替换成一个原始指针，指向一个已经被声明过却还未被定义的结构体 class Widget //仍然在“widget.h”中 { public: Widget(); ~Widget(); //析构函数在后面会分析 … private: struct Impl; //声明一个 实现结构体 Impl *pImpl; //以及指向它的指针 }; Widget的使用者不再需要为了这些类型而引入头文件 可以加速编译，并且如果这些头文件中有所变动，Widget的使用者不会受到影响 (感觉类似于接口类) 一个已经被声明，却还未被实现的类型，被称为不完整类型（incomplete type）,Widget::Impl就是这种类型。 Pimpl惯用法 第一步，是声明一个数据成员，它是个指针，指向一个不完整类型。 第二步是动态分配和回收一个对象，该对象包含那些以前在原来的类中的数据成员 #include \"widget.h\" //以下代码均在实现文件“widget.cpp”里 #include \"gadget.h\" #include #include struct Widget::Impl { //含有之前在Widget中的数据成员的 std::string name; //Widget::Impl类型的定义 std::vector data; Gadget g1,g2,g3; }; Widget::Widget() //为此Widget对象分配数据成员 : pImpl(new Impl) {} Widget::~Widget() //销毁数据成员 { delete pImpl; } std::unique_ptr（见Item18）是最合适的工具。在头文件中用std::unique_ptr替代原始指针 class Widget { //在“widget.h”中 public: Widget(); … private: struct Impl; std::unique_ptr pImpl; //使用智能指针而不是原始指针 }; //实现文件 #include \"widget.h\" //在“widget.cpp”中 #include \"gadget.h\" #include #include struct Widget::Impl { //跟之前一样 std::string name; std::vector data; Gadget g1,g2,g3; }; Widget::Widget() //根据条款21，通过std::make_unique : pImpl(std::make_unique()) //来创建std::unique_ptr {} 但是，最普通的Widget用法却会导致编译出错： #include \"widget.h\" Widget w; //错误！ 在使用delete之前，通常会使默认删除器使用C++11的特性static_assert来确保原始指针指向的类型不是一个不完整类型。 当编译器为Widget w的析构生成代码时，它会遇到static_assert检查并且失败，这通常是错误信息的来源(只在对象w销毁的地方出现)。 为了解决这个问题，你只需要确保在编译器生成销毁std::unique_ptr的代码之前， Widget::Impl已经是一个完整类型（complete type） //widget.h class Widget { //跟之前一样，在“widget.h”中 public: Widget(); ~Widget(); //只声明类Widget的析构函数，但不要在这里定义它 … private: //跟之前一样 struct Impl; std::unique_ptr pImpl; }; //widget.cpp #include \"widget.h\" //跟之前一样，在“widget.cpp”中 #include \"gadget.h\" #include #include struct Widget::Impl { //跟之前一样，定义Widget::Impl std::string name; std::vector data; Gadget g1,g2,g3; } Widget::Widget() //跟之前一样 : pImpl(std::make_unique()) {} //在结构体Widget::Impl被定义之后，再定义析构函数 Widget::~Widget() {} Pimpl惯用法的类自然适合支持移动操作，声明一个类Widget的析构函数会阻止编译器生成移动操作 自己声明相关函数，把移动操作的定义移动到实现文件里 class Widget { //仍然在“widget.h”中 public: Widget(); ~Widget(); Widget(Widget&& rhs); //只有声明 Widget& operator=(Widget&& rhs); … private: //跟之前一样 struct Impl; std::unique_ptr pImpl; }; #include //跟之前一样，仍然在“widget.cpp”中 … struct Widget::Impl { … }; //跟之前一样 Widget::Widget() //跟之前一样 : pImpl(std::make_unique()) {} Widget::~Widget() = default; //跟之前一样 Widget::Widget(Widget&& rhs) = default; //这里定义 Widget& Widget::operator=(Widget&& rhs) = default; Pimpl惯用法是用来减少类的实现和类使用者之间的编译依赖的一种方法 允许复制操作，所以类Widget支持复制操作也很合理。 我们必须要自己来写这些函数 在头文件里声明函数，而在实现文件里去实现他们 class Widget { //仍然在“widget.h”中 public: … Widget(const Widget& rhs); //只有声明 Widget& operator=(const Widget& rhs); private: //跟之前一样 struct Impl; std::unique_ptr pImpl; }; #include //跟之前一样，仍然在“widget.cpp”中 … struct Widget::Impl { … }; //跟之前一样 Widget::~Widget() = default; //其他函数，跟之前一样 Widget::Widget(const Widget& rhs) //拷贝构造函数 : pImpl(std::make_unique(*rhs.pImpl)) {} Widget& Widget::operator=(const Widget& rhs) //拷贝operator= { *pImpl = *rhs.pImpl; return *this; } 换成std::shared_ptr 如果我们使用std::shared_ptr而不是std::unique_ptr来做pImpl指针， 我们会发现本条款的建议不再适用。不需要在类Widget里声明析构函数 class Widget { //在“widget.h”中 public: Widget(); … //没有析构函数和移动操作的声明 private: struct Impl; std::shared_ptr pImpl; //用std::shared_ptr }; //而不是std::unique_ptr std::unique_ptr和std::shared_ptr在pImpl指针上的表现上的区别的深层原因在于，他们支持自定义删除器的方式不同。 对std::unique_ptr而言，删除器的类型是这个智能指针的一部分 让编译器有可能生成更小的运行时数据结构和更快的运行代码 std::unique_ptr指向的类型，在编译器的生成特殊成员函数（如析构函数，移动操作）被调用时，必须已经是一个完整类型 对std::shared_ptr而言，删除器的类型不是该智能指针的一部分 会生成更大的运行时数据结构和稍微慢点的代码 当编译器生成的特殊成员函数被使用的时候，指向的对象不必是一个完整类型。 总结 [!note] Pimpl惯用法通过减少在类实现和类使用者之间的编译依赖来减少编译时间。 对于std::unique_ptr类型的pImpl指针，需要在头文件的类里声明特殊的成员函数，但是在实现文件里面来实现他们。即使是编译器自动生成的代码可以工作，也要这么做。 以上的建议只适用于std::unique_ptr，不适用于std::shared_ptr。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - CHAPTER_4_Smart_Pointers "},"docs/Cpp/Effective-Modern-C++/CHAPTER_5_RValue_References,Move_Semantics_and_Perfect_Forwarding.html":{"url":"docs/Cpp/Effective-Modern-C++/CHAPTER_5_RValue_References,Move_Semantics_and_Perfect_Forwarding.html","title":"CHAPTER_5_RValue_References,Move_Semantics_and_Perfect_Forwarding","keywords":"","body":" 第5章 右值引用，移动语义，完美转发 移动语义（move semantics）和完美转发（perfect forwarding） Item 23: Understand std::move and std::forward std::move std::forward std::move vs std::forward 总结 Item 24: Distinguish universal references from rvalue references T&& 通用引用 总结 Item 25: Use std::move on rvalue references, std::forward on universal references 右值引用和通用引用 何时使用 返回值绑定 返回值优化 总结 Item 26: Avoid overloading on universal references 示例 完美转发构造函数 总结 Item 27: Familiarize yourself with alternatives to overloading on universal references 放弃重载 传递const T& 传值 使用tag dispatch 约束使用通用引用的模板 折中 总结 Item 28: Understand reference collapsing 通用引用和对左值右值的编码 引用折叠（reference collapsing） 总结 Item 29: Assume that move operations are not present, not cheap, and not used 移动语义 \"冷水\" 移动语义并无优势? 总结 Item 30: Familiarize yourself with perfect forwarding failure cases 完美转发 无法做到完美转发的实参类型 花括号初始化器 0或者NULL作为空指针 仅有声明的整型static const数据成员 重载函数的名称和模板名称 位域 总结 [TOC] 第5章 右值引用，移动语义，完美转发 移动语义（move semantics）和完美转发（perfect forwarding） 移动语义 使编译器有可能用廉价的移动操作来代替昂贵的拷贝操作 移动构造函数和移动赋值操作符也给了你控制移动语义的权力 移动语义也允许创建只可移动（move-only）的类型，例如std::unique_ptr，std::future和std::thread。 完美转发 完美转发使接收任意数量实参的函数模板成为可能，它可以将实参转发到其他的函数，使目标函数接收到的实参与被传递给转发函数的实参保持一致。 右值引用是连接这两个截然不同的概念的胶合剂。它是使移动语义和完美转发变得可能的基础语言机制。 [!tip] 左值 (lvalue) 定义：可以取地址、有持久状态的对象（通常有名字）。 特点： 代表一个 具体的内存位置。 生命周期通常超过当前表达式。 可以出现在赋值运算符的 左侧或右侧。 int a = 10; // a 是左值 int* p = &a; // 可以取地址 a = 20; // 左值在赋值左侧 int b = a; // 左值在赋值右侧 右值 (rvalue) 定义：临时的、无法取地址的值（通常是表达式计算的中间结果）。 特点： 代表一个 临时的值，没有持久的内存地址。 生命周期仅限当前表达式。 只能出现在赋值运算符的 右侧。 int x = 5; // 5 是右值（字面量） x = 2 + 3; // 2+3 的结果是右值 std::string s = \"Hi\"; // \"Hi\" 是右值 扩展概念（C++11 后） 将亡值 (xvalue)：介于左值和右值之间（如 std::move 的结果）。 纯右值 (prvalue)：字面量、表达式结果等传统右值。 非常重要的一点是要牢记形参永远是左值，即使它的类型是一个右值引用。 void f(Widget&& w); Item 23: Understand std::move and std::forward std::move不移动（move）任何东西，std::forward也不转发（forward）任何东西。 在运行时，它们不做任何事情。它们不产生任何可执行代码，一字节也没有。 std::move和std::forward仅仅是执行转换（cast）的函数（事实上是函数模板）。 std::move无条件的将它的实参转换为右值 std::forward只在特定情况满足时下进行转换 std::move C++11的std::move的示例实现。它并不完全满足标准细则 template //在std命名空间 typename remove_reference::type&& move(T&& param) { using ReturnType = //别名声明，见条款9 typename remove_reference::type&&; return static_cast(param); } std::move接受一个对象的引用（准确的说，一个通用引用（universal reference），见Item24)，返回一个指向同对象的引用。 函数返回类型的&&部分表明std::move函数返回的是一个右值引用 但是，正如Item28所解释的那样，如果类型T恰好是一个左值引用，那么T&&将会成为一个左值引用。为了避免如此，type trait（见Item9）std::remove_reference应用到了类型T上，这保证了std::move返回的真的是右值引用。 在C++14中，函数返回值类型推导（见Item3）和标准库的模板别名std::remove_reference_t（见Item9），std::move可以这样写： template decltype(auto) move(T&& param) //C++14，仍然在std命名空间 { using ReturnType = remove_referece_t&&; return static_cast(param); } std::move除了转换它的实参到右值以外什么也不做 它只进行转换，不移动任何东西。 事实上，右值只不过经常是移动操作的候选者。 这个类的构造函数接受一个包含有注解的std::string作为形参，然后它复制该形参到数据成员。 class Annotation { public: //能使用const就使用const保持一致 explicit Annotation(const std::string text) ：value(std::move(text)) //“移动”text到value里；这段代码执行起来,当复制text到一个数据成员的时候，为了避免一次复制操作的代价 { … } //并不是看起来那样 … private: std::string value; }; 这段代码与你期望中的完美实现的唯一区别，是text并不是被移动到value，而是被拷贝。 在转换之前，text是一个左值的const std::string，而转换的结果是一个右值的const std::string class string { //std::string事实上是 public: //std::basic_string的类型别名 … string(const string& rhs); //拷贝构造函数 string(string&& rhs); //移动构造函数 … }; std::move(text)的结果是一个const std::string的右值。 该右值却可以被传递给std::string的拷贝构造函数，因为lvalue-reference-to-const允许被绑定到一个const右值上。 [!warning] 总结 第一，不要在你希望能移动对象的时候，声明他们为const。对const对象的移动请求会悄无声息的被转化为拷贝操作。 第二点，std::move不仅不移动任何东西，而且它也不保证它执行转换的对象可以被移动。 关于std::move，你能确保的唯一一件事就是将它应用到一个对象上，你能够得到一个右值。 std::forward std::forward只有在满足一定条件的情况下才执行转换。std::forward是有条件的转换。 最常见的情景是一个模板函数，接收一个通用引用形参，并将它传递给另外的函数： void process(const Widget& lvalArg); //处理左值 void process(Widget&& rvalArg); //处理右值 template //用以转发param到process的模板 void logAndProcess(T&& param) { auto now = //获取现在时间 std::chrono::system_clock::now(); makeLogEntry(\"Calling 'process'\", now); process(std::forward(param)); } Widget w; logAndProcess(w); //用左值调用 logAndProcess(std::move(w)); //用右值调用 当且仅当传递给函数logAndProcess的用以初始化param的实参是一个右值时，param会被转换为一个右值。 std::forward是一个有条件的转换：它的实参用右值初始化时，转换为一个右值。 std::move vs std::forward [!note] 它们唯一的区别就是std::move总是执行转换，而std::forward偶尔为之。 std::forward是可以完全胜任，std::move并非必须。 std::move的吸引力在于它的便利性 减少了出错的可能性，增加了代码的清晰程度。 假设static的计数器，它会在移动构造的时候自增 class Widget { public: Widget(Widget&& rhs) : s(std::move(rhs.s)) { ++moveCtorCalls; } … private: static std::size_t moveCtorCalls; std::string s; }; 如果要用std::forward来达成同样的效果 class Widget{ public: Widget(Widget&& rhs) //不自然，不合理的实现 : s(std::forward(rhs.s)) { ++moveCtorCalls; } … } std::forward不但需要一个函数实参（rhs.s），还需要一个模板类型实参std::string。 传递给std::forward的类型应当是一个non-reference 这意味着std::move比起std::forward来说需要打更少的字，并且免去了传递一个表示我们正在传递一个右值的类型实参。 它根绝了我们传递错误类型的可能性（例如，std::string&可能导致数据成员s被复制而不是被移动构造） 更重要的是，std::move的使用代表着无条件向右值的转换，而使用std::forward只对绑定了右值的引用进行到右值转换。 前者是典型地为了移动操作， 而后者只是传递（亦为转发）一个对象到另外一个函数，保留它原有的左值属性或右值属性。 总结 [!note] std::move执行到右值的无条件的转换，但就自身而言，它不移动任何东西。 std::forward只有当它的参数被绑定到一个右值时，才将参数转换为右值。 std::move和std::forward在运行期什么也不做。 Item 24: Distinguish universal references from rvalue references T&& 为了声明一个指向某个类型T的右值引用，你写下了T&&。 void f(Widget&& param); //右值引用 Widget&& var1 = Widget(); //右值引用 auto&& var2 = var1; //不是右值引用 template void f(std::vector&& param); //右值引用 template void f(T&& param); //不是右值引用 [!tip] “T&&”有两种不同的意思。 第一种，当然是右值引用。它们只绑定到右值上，并且它们主要的存在原因就是为了识别可以移动操作的对象。 “T&&”的另一种意思是，它既可以是右值引用，也可以是左值引用。它们既可以绑定到右值上（就像右值引用），也可以绑定到左值上（就像左值引用）。 此外，它们还可以绑定到const或者non-const的对象上，也可以绑定到volatile或者non-volatile的对象上，甚至可以绑定到既const又volatile的对象上。叫做通用引用（universal references） 通用引用 在两种情况下会出现通用引用。 最常见的一种是函数模板形参 template void f(T&& param); //param是一个通用引用 第二种情况是auto声明符 auto&& var2 = var1; //var2是一个通用引用 这两种情况的共同之处就是都存在类型推导（type deduction） 如果你看见“T&&”不带有类型推导，那么你看到的就是一个右值引用： void f(Widget&& param); //没有类型推导， //param是一个右值引用 Widget&& var1 = Widget(); //没有类型推导， //var1是一个右值引用 因为通用引用是引用，所以它们必须被初始化。 template void f(T&& param); //param是一个通用引用 Widget w; f(w); //传递给函数f一个左值；param的类型 //将会是Widget&，也即左值引用 f(std::move(w)); //传递给f一个右值；param的类型会是 //Widget&&，即右值引用 一个通用引用的初始值决定了它是代表了右值引用还是左值引用。 对一个通用引用而言，类型推导是必要的，但是它还不够。引用声明的形式必须正确，并且该形式是被限制的。它必须恰好为“T&&”。 没有类型推导的情况 template void f(std::vector&& param); //param是一个右值引用 std::vector v; f(v); //错误！不能将左值绑定到右值引用 一个简单的const修饰符的出现 template void f(const T&& param); //param是一个右值引用 在模板内部并不保证一定会发生类型推导。 template> //来自C++标准 class vector { public: void push_back(T&& x); … } push_back在有一个特定的vector实例之前不可能存在，而实例化vector时的类型已经决定了push_back的声明。 函数push_back不包含任何类型推导。 [!warning] emplace_back，却确实包含类型推导 template> //依旧来自C++标准 class vector { public: template void emplace_back(Args&&... args); … }; 类型参数（type parameter）Args是独立于vector的类型参数T的，所以Args会在每次emplace_back被调用的时候被推导。 类型声明为auto&&的变量是通用引用 一个C++14标准的lambda表达式，来记录任意函数调用的时间开销，你可以这样写： auto timeFuncInvocation = [](auto&& func, auto&&... params) //C++14 { start timer; std::forward(func)( //对params调用func std::forward(params)... ); stop timer and record elapsed time; }; func是一个通用引用，可以被绑定到任何可调用对象，无论左值还是右值。 args是0个或者多个通用引用（即它是个通用引用parameter pack），它可以绑定到任意数目、任意类型的对象上。 总结 [!note] 如果一个函数模板形参的类型为T&&，并且T需要被推导得知，或者如果一个对象被声明为auto&&，这个形参或者对象就是一个通用引用。 如果类型声明的形式不是标准的type&&，或者如果类型推导没有发生，那么type&&代表一个右值引用。 通用引用，如果它被右值初始化，就会对应地成为右值引用；如果它被左值初始化，就会成为左值引用。 Item 25: Use std::move on rvalue references, std::forward on universal references 右值引用和通用引用 右值引用仅绑定可以移动的对象。 如果你有一个右值引用形参就知道这个对象可能会被移动： class Widget { Widget(Widget&& rhs); //rhs定义上引用一个有资格移动的对象 … }; 这样做的方法是将绑定到此类对象的形参转换为右值 class Widget { public: Widget(Widget&& rhs) //rhs是右值引用 : name(std::move(rhs.name)), p(std::move(rhs.p)) { … } … private: std::string name; std::shared_ptr p; }; 通用引用可能绑定到有资格移动的对象上。 通用引用使用右值初始化时，才将其强制转换为右值 这正是std::forward所做的： class Widget { public: template void setName(T&& newName) //newName是通用引用 { name = std::forward(newName); } … }; [!warning] 当把右值引用转发给其他函数时，右值引用应该被无条件转换为右值（通过std::move），因为它们总是绑定到右值； 当转发通用引用时，通用引用应该有条件地转换为右值（通过std::forward），因为它们只是有时绑定到右值。 何时使用 在右值引用上使用std::forward表现出适当的行为，但是代码较长，容易出错，所以应该避免在右值引用上使用std::forward。同样在通用引用上使用std::move，这可能会意外改变左值（比如局部变量）： class Widget { public: template void setName(T&& newName) //通用引用可以编译， { name = std::move(newName); } //但是代码太太太差了！ … private: std::string name; std::shared_ptr p; }; std::string getWidgetName(); //工厂函数 Widget w; auto n = getWidgetName(); //n是局部变量 w.setName(n); //把n移动进w！ … //现在n的值未知 setName内部使用std::move无条件将传递的引用形参转换为右值，n的值被移动进w.name，调用setName返回时n最终变为未定义的值。 如果为const左值和为右值分别重载setName可以避免整个问题，比如这样： class Widget { public: void setName(const std::string& newName) //用const左值设置 { name = newName; } void setName(std::string&& newName) //用右值设置 { name = std::move(newName); } … }; 有缺点。首先编写和维护的代码更多（两个函数而不是单个模板）；其次，效率下降。 其次，比如，考虑如下场景： w.setName(\"Adela Novak\"); setName重载版本，会有一个临时std::string对象被创建，setName形参绑定到这个对象，然后这个临时std::string移动到w的数据成员中。 一次setName的调用会包括std::string构造函数调用（创建中间对象），std::string赋值运算符调用（移动newName到w.name），std::string析构函数调用（析构中间对象） 比调用接受const char*指针的std::string赋值运算符开销昂贵许多。 关于对左值和右值的重载函数最重要的问题不是源代码的数量，也不是代码的运行时性能。而是设计的可扩展性差。 Widget::setName有一个形参，因此需要两种重载实现，但是对于有更多形参的函数，每个都可能是左值或右值，重载函数的数量几何式增长：n个参数的话，就要实现2n种重载。 此类函数的典型代表是std::make_shared，还有对于C++14的std::make_unique（见Item21）。 template //来自C++11标准 shared_ptr make_shared(Args&&... args); template //来自C++14标准 unique_ptr make_unique(Args&&... args); 肯定使用std::forward传递通用引用形参给其他函数 在某些情况，你可能需要在一个函数中多次使用绑定到右值引用或者通用引用的对象，并且确保在完成其他操作前，这个对象不会被移动。 只想在最后一次使用时，使用std::move（对右值引用）或者std::forward（对通用引用） template void setSignText(T&& text) //text是通用引用 { sign.setText(text); //使用text但是不改变它 auto now = std::chrono::system_clock::now(); //获取现在的时间 signHistory.add(now, std::forward(text)); //有条件的转换为右值 } 确保text的值不会被sign.setText改变 对于std::move，同样的思路（即最后一次用右值引用的时候再调用std::move） [!warning] 在有些稀少的情况下，你需要调用std::move_if_noexcept代替std::move 返回值绑定 在按值返回的函数中，返回值绑定到右值引用或者通用引用上，需要对返回的引用使用std::move或者std::forward。 考虑两个矩阵相加的operator+函数，左侧的矩阵为右值（可以被用来保存求值之后的和）： Matrix //按值返回 operator+(Matrix&& lhs, const Matrix& rhs) { lhs += rhs; return std::move(lhs); //移动lhs到返回值中 } 在return语句中将lhs转换为右值（通过std::move），lhs可以移动到返回值的内存位置。 如果Matrix不支持移动操作，将其转换为右值不会变差，因为右值可以直接被Matrix的拷贝构造函数拷贝 使用通用引用和std::forward的情况类似。 考虑函数模板reduceAndCopy收到一个未规约（unreduced）对象Fraction，将其规约，并返回一个规约后的副本。 如果原始对象是右值，可以将其移动到返回值中（避免拷贝开销）， 但是如果原始对象是左值，必须创建副本， template Fraction //按值返回 reduceAndCopy(T&& frac) //通用引用的形参 { frac.reduce(); return std::forward(frac); //移动右值，或拷贝左值到返回值中 } 返回值优化 对我要返回的局部对象应用同样的优化。对要被拷贝到返回值的右值引用形参使用std::move，会把拷贝构造变为移动构造 Widget makeWidget() //makeWidget的移动版本 { Widget w; … return std::move(w); //移动w到返回值中（不要这样做！） } makeWidget的“拷贝”版本可以避免复制局部变量w的需要，通过在分配给函数返回值的内存中构造w来实现。这就是所谓的返回值优化（return value optimization，RVO） 编译器可能会在按值返回的函数中消除对局部对象的拷贝（或者移动） 如果满足 局部对象与函数返回值的类型相同； 局部对象就是要返回的东西。（适合的局部对象包括大多数局部变量（比如makeWidget里的w），还有作为return语句的一部分而创建的临时对象。而函数形参不满足要求。 [!tip] 一些人将RVO的应用区分为命名的和未命名的（即临时的）局部对象，限制了RVO术语应用到未命名对象上，并把对命名对象的应用称为命名返回值优化（named return value optimization，NRVO）。） 再看看makeWidget的“拷贝”版本： Widget makeWidget() //makeWidget的“拷贝”版本 { Widget w; … return w; //“拷贝”w到返回值中 } 意味着makeWidget的“拷贝”版本实际上不拷贝任何东西。 而makeWidget的移动版本不满足这条件 return std::move(w); 返回的已经不是局部对象w，而是w的引用——std::move(w)的结果。 开发者试图对要返回的局部变量用std::move帮助编译器优化，反而限制了编译器的优化选项。 应用std::move到一个局部对象上仍然是一个坏主意。 C++标准关于RVO的部分表明，如果满足RVO的条件，但是编译器选择不执行拷贝消除，则返回的对象必须被视为右值。 在某些情况下，将std::move应用于局部变量可能是一件合理的事（即，你把一个变量传给函数，并且知道不会再用这个变量），但是满足RVO的return语句或者返回一个传值形参并不在此列。 总结 [!note] 最后一次使用时，在右值引用上使用std::move，在通用引用上使用std::forward。 对按值返回的函数要返回的右值引用和通用引用，执行相同的操作。 如果局部对象可以被返回值优化消除，就绝不使用std::move或者std::forward。 Item 26: Avoid overloading on universal references 示例 假定你需要写一个函数，它使用名字作为形参，打印当前日期和时间到日志中，然后将名字加入到一个全局数据结构中。 std::multiset names; //全局数据结构 void logAndAdd(const std::string& name) { auto now = //获取当前时间 std::chrono::system_clock::now(); log(now, \"logAndAdd\"); //志记信息 names.emplace(name); //把name加到全局数据结构中； } //emplace的信息见条款42 代码没有问题，但是同样的也没有效率。考虑这三个调用： std::string petName(\"Darla\"); logAndAdd(petName); //传递左值std::string //有个拷贝代价，但是我们应该能用移动勉强应付。 logAndAdd(std::string(\"Persephone\")); //传递右值std::string //有个std::string拷贝开销，但是我们连移动开销都不想要，更别说拷贝的。 logAndAdd(\"Patty Dog\"); //传递字符串字面值 通过使用通用引用（参见Item24）重写logAndAdd来使第二个和第三个调用效率提升 template void logAndAdd(T&& name) { auto now = std::chrono::system_clock::now(); log(now, \"logAndAdd\"); names.emplace(std::forward(name)); } std::string petName(\"Darla\"); //跟之前一样 logAndAdd(petName); //跟之前一样，拷贝左值到multiset logAndAdd(std::string(\"Persephone\")); //移动右值而不是拷贝它 logAndAdd(\"Patty Dog\"); //在multiset直接创建std::string //而不是拷贝一个临时std::string 但是如果客户不总是有直接访问logAndAdd要求的名字的权限。有些客户只有索引，logAndAdd拿着索引在表中查找相应的名字。 logAndAdd需要重载为： std::string nameFromIdx(int idx); //返回idx对应的名字 void logAndAdd(int idx) //新的重载 { auto now = std::chrono::system_clock::now(); log(now, \"logAndAdd\"); names.emplace(nameFromIdx(idx)); } std::string petName(\"Darla\"); //跟之前一样 logAndAdd(petName); //跟之前一样， logAndAdd(std::string(\"Persephone\")); //这些调用都去调用 logAndAdd(\"Patty Dog\"); //T&&重载版本 logAndAdd(22); //调用int重载版本 假定一个客户将short类型索引传递给logAndAdd： short nameIdx; … //给nameIdx一个值 logAndAdd(nameIdx); //错误！ 使用通用引用的那个推导出T的类型是short，因此可以精确匹配。 对于int类型参数的重载也可以在short类型提升后匹配成功。 根据正常的重载解决规则，精确匹配优先于类型提升的匹配，所以被调用的是通用引用的重载。 但是logAndAdd调用里的multiset::emplace调用里的std::string构造函数调用失败。 使用通用引用的函数在C++中是最贪婪的函数。 几乎可以精确匹配任何类型的实参（极少不适用的实参在Item30中介绍）。 完美转发构造函数 一个更容易掉入这种陷阱的例子是写一个完美转发构造函数。 不用写接受std::string或者用索引查找std::string的自由函数，只是想一个构造函数有着相同操作的Person类： class Person { public: template //完美转发的构造函数 explicit Person(T&& n) : name(std::forward(n)) {} explicit Person(int idx); //int的构造函数 Person(const Person& rhs); //拷贝构造函数（编译器生成） Person(Person&& rhs); //移动构造函数（编译器生成） … }; Person p(\"Nancy\"); auto cloneOfP(p); //从p创建新Person；这通不过编译！ //尝试使用Person对象p初始化Person的std::string数据成员 这份代码不是调用拷贝构造函数，而是调用完美转发构造函数。 编译器的理由如下：cloneOfP被non-const左值p初始化，这意味着模板化构造函数可被实例化为采用Person类型的non-const左值。 class Person { public: explicit Person(Person& n) //由完美转发模板初始化 : name(std::forward(n)) {} explicit Person(int idx); //同之前一样 Person(const Person& rhs); //拷贝构造函数（编译器生成的） … }; //在这个语句中， auto cloneOfP(p); “拷贝”non-const左值类型的Person交由完美转发构造函数处理，而不是拷贝构造函数。 果我们将本例中的传递的对象改为const的，会得到完全不同的结果： const Person cp(\"Nancy\"); //现在对象是const的 auto cloneOfP(cp); //调用拷贝构造函数！ 被拷贝的对象是const，是拷贝构造函数的精确匹配。 当继承纳入考虑范围时，完美转发的构造函数与编译器生成的拷贝、移动操作之间的交互会更加复杂。 派生类的拷贝和移动操作的传统实现会表现得非常奇怪 class SpecialPerson: public Person { public: SpecialPerson(const SpecialPerson& rhs) //拷贝构造函数，调用基类的 : Person(rhs) //完美转发构造函数！ { … } SpecialPerson(SpecialPerson&& rhs) //移动构造函数，调用基类的 : Person(std::move(rhs)) //完美转发构造函数！ { … } }; 总结 [!note] 对通用引用形参的函数进行重载，通用引用函数的调用机会几乎总会比你期望的多得多。 完美转发构造函数是糟糕的实现，因为对于non-const左值，它们比拷贝构造函数而更匹配，而且会劫持派生类对于基类的拷贝和移动构造函数的调用。 Item 27: Familiarize yourself with alternatives to overloading on universal references Item26中说明了对使用通用引用形参的函数，无论是独立函数还是成员函数（尤其是构造函数），进行重载都会导致一系列问题。 这个条款探讨了几种，通过避免在通用引用上重载的设计，或者通过限制通用引用可以匹配的参数类型，来实现所期望行为的方法。 放弃重载 在Item26中的第一个例子中，logAndAdd是许多函数的代表，这些函数可以使用不同的名字来避免在通用引用上的重载的弊端。 两个重载的logAndAdd函数，可以分别改名为logAndAddName和logAndAddNameIdx。 template void logAndAddName(T&& name) { auto now = std::chrono::system_clock::now(); log(now, \"logAndAdd\"); names.emplace(std::forward(name)); } void logAndAddNameIdx(int idx) //新的重载 { auto now = std::chrono::system_clock::now(); log(now, \"logAndAdd\"); names.emplace(nameFromIdx(idx)); } [!important] 这种方式不能用在第二个例子，Person构造函数中，因为构造函数名与类名相同 传递const T& 退回到C++98，然后将传递通用引用替换为传递lvalue-refrence-to-const。 缺点是效率不高。 void logAndAdd(const std::string& name) { auto now = //获取当前时间 std::chrono::system_clock::now(); log(now, \"logAndAdd\"); //志记信息 names.emplace(name); //把name加到全局数据结构中； } 传值 通常在不增加复杂性的情况下提高性能的一种方法是，将按传引用形参替换为按值传递，这是违反直觉的。 该设计遵循Item41中给出的建议，即在你知道要拷贝时就按值传递 在Person的例子中展示： class Person { public: explicit Person(std::string n) //代替T&&构造函数， : name(std::move(n)) {} //std::move的使用见条款41 explicit Person(int idx) //同之前一样 : name(nameFromIdx(idx)) {} … private: std::string name; }; 因为没有std::string构造函数可以接受整型参数，所有int或者其他整型变量（比如std::size_t、short、long等）都会使用int类型重载的构造函数。 [!warning] 使用0或者NULL指代空指针会调用int重载的构造函数，而非指针类型的构造函数。 使用tag dispatch [!important] 传递lvalue-reference-to-const以及按值传递都不支持完美转发。如果使用通用引用的动机是完美转发，我们就只能使用通用引用 [!note] tag dispatch方法: 通过查看所有重载的所有形参以及调用点的所有传入实参，然后选择最优匹配的函数——考虑所有形参/实参的组合。 通用引用通常提供了最优匹配，但是如果通用引用是包含其他非通用引用的形参列表的一部分，则非通用引用形参的较差匹配会使有一个通用引用的重载版本不被运行。 std::multiset names; //全局数据结构 template //志记信息，将name添加到数据结构 void logAndAdd(T&& name) { auto now = std::chrono::system_clokc::now(); log(now, \"logAndAdd\"); names.emplace(std::forward(name)); } 如果引入一个int类型的重载来用索引查找对象，就会重新陷入Item26中描述的麻烦。 重新实现logAndAdd函数分拆为两个函数，一个针对整型值，一个针对其他。logAndAdd本身接受所有实参类型，包括整型和非整型。 真正执行逻辑的函数命名为logAndAddImpl，即我们使用重载。 其中一个函数接受通用引用。所以我们同时使用了重载和通用引用。 每个函数接受第二个形参，表征传入的实参是否为整型。 template void logAndAdd(T&& name) { //多传递了一个表示形参T是否为整型的实参 logAndAddImpl( std::forward(name), std::is_integral::type>() ); } 如果左值int被传入logAndAdd，T将被推断为int&。这不是一个整型类型，因为引用不是整型类型。所以利用std::remove_reference移除类型的引用说明符 [!tip] 在C++14中，你可以通过std::remove_reference_t来简化写法 template void logAndAdd(T&& name) { //多传递了一个表示形参T是否为整型的实参 logAndAddImpl( std::forward(name), std::is_integral>() ); } logAndAddImpl的函数 两个重载函数 第一个仅用于非整型类型（即std::is_integral::type>是false）： template //非整型实参：添加到全局数据结构中 void logAndAddImpl(T&& name, std::false_type) //译者注：高亮std::false_type { auto now = std::chrono::system_clock::now(); log(now, \"logAndAdd\"); names.emplace(std::forward(name)); } 如果T是整型，对象的类型就继承自std::true_type，反之继承自std::false_type。 [!important] 概念上，logAndAdd传递一个布尔值给logAndAddImpl表明是否传入了一个整型类型，但是true和false是运行时值，我们需要使用重载决议——编译时决策——来选择正确的logAndAddImpl重载。 标准库提供了这样两个命名std::true_type和std::false_type分别对应true和false 第二个重载覆盖了相反的场景：当T是整型类型。 std::string nameFromIdx(int idx); //与条款26一样，整型实参：查找名字并用它调用logAndAdd void logAndAddImpl(int idx, std::true_type) //译者注：高亮std::true_type { logAndAdd(nameFromIdx(idx)); } 在这个设计中，类型std::true_type和std::false_type是“标签”（tag），其唯一目的就是强制重载解析按照我们的想法来执行。 所以没有对这些参数进行命名，以此希望编译器可以意识到这些标签形参没被使用，然后在程序执行时优化掉它们 [!note] 通过创建标签对象，在logAndAdd内部将重载实现函数的调用“分发”（dispatch）给正确的重载。因此这个设计名称为：tag dispatch。 分发函数——logAndAdd——接受一个没有约束的通用引用参数，但是这个函数没有重载。实现函数——logAndAddImpl——是重载的，一个接受通用引用参数，但是重载规则不仅依赖通用引用形参，还依赖新引入的标签形参，标签值设计来保证有不超过一个的重载是合适的匹配。 约束使用通用引用的模板 [!tip] tag dispatch的关键是存在单独一个函数（没有重载）给客户端API。这个单独的函数分发给具体的实现函数。 [!important] 第二个问题案例是Person类的完美转发构造函数，是个例外。 编译器可能会自行生成拷贝和移动构造函数， 有一些对构造函数的调用也被编译器生成的函数处理，绕过了分发机制。 真正的问题不是编译器生成的函数会绕过tag dispatch设计，而是不总会绕过去。 class Person { public: template //完美转发的构造函数 explicit Person(T&& n) : name(std::forward(n)) {} explicit Person(int idx); //int的构造函数 Person(const Person& rhs); //拷贝构造函数（编译器生成） Person(Person&& rhs); //移动构造函数（编译器生成） … }; Person p(\"Nancy\"); auto cloneOfP(p); //从p创建新Person；这通不过编译！ 提供具有通用引用的构造函数，会使通用引用构造函数在拷贝non-const左值时被调用（而不是拷贝构造函数） std::enable_if std::enable_if可以给你提供一种强制编译器执行行为的方法，像是特定模板不存在一样。这种模板被称为被禁止（disabled） 默认情况下，所有模板是启用的（enabled） 使用std::enable_if可以使得仅在std::enable_if指定的条件满足时模板才启用。 如果传递的类型是Person，我们要禁止完美转发构造函数（即让编译器忽略它） class Person { public: template::type> //译者注：本行高亮，condition为某其他特定条件 explicit Person(T&& n); … }; 条件是确认T不是Person类型 Person p(\"Nancy\"); auto cloneOfP(p); //用左值初始化 T的类型在通用引用的构造函数中被推导为Person&。Person和Person&类型是不同的 [!warning] 精细考虑仅当T不是Person类型才启用模板构造函数，查看T时，应该忽略： 是否是个引用。 是不是const或者volatile。 一种方法消除对于T的引用，const，volatile修饰： std::decay::type与T是相同的，只不过会移除引用和cv限定符（cv-qualifiers，即const或volatile标识符）的修饰。 [!tip] std::decay如同其名一样，可以将数组或者函数退化成指针，参考Item1 所以condition可以为 !std::is_same::type>::value class Person { public: template::type >::value >::type > explicit Person(T&& n); … }; [!tip] std::enable_if template struct enable_if; 若 B 为 true，则 std::enable_if 拥有等同于 T 的公开成员 typedef type；否则，无成员 typedef。 假定从Person派生的类以常规方式实现拷贝和移动操作： class SpecialPerson: public Person { public: SpecialPerson(const SpecialPerson& rhs) //拷贝构造函数，调用基类的 : Person(rhs) //完美转发构造函数！ { … } SpecialPerson(SpecialPerson&& rhs) //移动构造函数，调用基类的 : Person(std::move(rhs)) //完美转发构造函数！ { … } … }; 而当我们拷贝或者移动一个SpecialPerson对象时，我们希望调用基类对应的拷贝和移动构造函数，来拷贝或者移动基类部分 现在我们意识到不只是禁止Person类型启用模板构造函数，而是禁止Person以及任何派生自Person的类型启用模板构造函数。 标准库中也有type trait判断一个类型是否继承自另一个类: std::is_base_of [!tip] std::is_base_of是true就表示T2派生自T1。 修正控制Person完美转发构造函数的启用条件: //C++11 class Person { public: template::type >::value >::type > explicit Person(T&& n); … }; //C++14 class Person { //C++14 public: template //还有这儿 >::value > //还有这儿 > explicit Person(T&& n); … }; 应用于区分整型参数和非整型参数。我们的原始目标是解决构造函数模糊性问题。 （1）加入一个Person构造函数重载来处理整型参数； （2）约束模板构造函数使其对于某些实参禁用。 class Person { public: template>::value && !std::is_integral>::value > > explicit Person(T&& n) //对于std::strings和可转化为 : name(std::forward(n)) //std::strings的实参的构造函数 { … } explicit Person(int idx) //对于整型实参的构造函数 : name(nameFromIdx(idx)) { … } … //拷贝、移动构造函数等 private: std::string name; }; 折中 [!important] 通常，完美转发更有效率，因为它避免了仅仅去为了符合形参声明的类型而创建临时对象。 完美转发也有缺点。即使某些类型的实参可以传递给接受特定类型的函数，也无法完美转发。。Item30中探索了完美转发失败的例子。 第二个问题是当客户传递无效参数时错误消息的可理解性。 假如客户传递了一个由char16_t（一种C++11引入的类型表示16位字符）来创建一个Person对象： Person p(u\"Konrad Zuse\"); //“Konrad Zuse”由const char16_t类型字符组成 本条款前三种方法，编译器将看到可用的采用int或者std::string的构造函数，会产生错误消息，表示没有可以从const char16_t[12]转换为int或者std::string的方法。 基于完美转发的方法，const char16_t不受约束地绑定到构造函数的形参。 在Person这个例子中，我们知道完美转发函数的通用引用形参要作为std::string的初始化器，所以我们可以用static_assert来确认它可以起这个作用。 std::is_constructible这个type trait执行编译时测试，确定一个类型的对象是否可以用另一个不同类型（或多个类型）的对象（或多个对象）来构造 class Person { public: template>::value && !std::is_integral>::value > > explicit Person(T&& n) : name(std::forward(n)) { //断言可以用T对象创建std::string static_assert( std::is_constructible::value, \"Parameter n can't be used to construct a std::string\" ); … //通常的构造函数的工作写在这 } … //Person类的其他东西（同之前一样） }; 客户代码尝试使用无法构造std::string的类型创建Person，会导致指定的错误消息。 总结 [!note] 通用引用和重载的组合替代方案包括使用不同的函数名，通过lvalue-reference-to-const传递形参，按值传递形参，使用tag dispatch。 通过std::enable_if约束模板，允许组合通用引用和重载使用，但它也控制了编译器在哪种条件下才使用通用引用重载。 通用引用参数通常具有高效率的优势，但是可用性就值得斟酌。 Item 28: Understand reference collapsing 通用引用和对左值右值的编码 不管传给param的实参是左值还是右值，模板形参T都会编码。 template void func(T&& param); 当左值实参被传入时，T被推导为左值引用。 当右值被传入时，T被推导为非引用。 [!warning] 注意不对称性：左值被编码为左值引用，右值被编码为非引用。 Widget widgetFactory(); //返回右值的函数 Widget w; //一个变量（左值） func(w); //用左值调用func；T被推导为Widget& func(widgetFactory()); //用右值调用func；T被推导为Widget 一个是左值，一个是右值，模板形参T被推导为不同的类型 这决定了通用引用成为左值还是右值，也是std::forward的工作基础。 [!warning] 在C++中引用的引用是非法的 int x; auto& & rx = x; //错误！不能声明引用的引用 一个左值传给接受通用引用的模板函数会发生什么： template void func(T&& param); //同之前一样 func(w); //用左值调用func；T被推导为Widget& 如果我们用T推导出来的类型（即Widget&）初始化模板 void func(Widget& && param);//引用的引用，但是编译器没有报错 param的类型应该为左值引用，而最终的函数签名也变成了 void func(Widget& param); 编译器通过引用折叠（reference collapsing）实现禁止声明引用的引用。 引用折叠（reference collapsing） [!important] 引用折叠（reference collapsing）禁止你声明引用的引用，但是编译器会在特定的上下文中产生这些，模板实例化就是其中一种情况。 当编译器生成引用的引用时，引用折叠指导下一步发生什么。 [!tip] 存在两种类型的引用（左值和右值） 所以有四种可能的引用组合（左值的左值，左值的右值，右值的右值，右值的左值） 如果一个上下文中允许引用的引用存在（比如，模板的实例化），引用根据规则折叠为单个引用： [!note] 如果任一引用为左值引用，则结果为左值引用。否则（即，如果引用都是右值引用），结果为右值引用。 引用折叠是std::forward工作的一种关键机制。 template void f(T&& fParam) { … //做些工作 someFunc(std::forward(fParam)); //转发fParam到someFunc } std::forward的作用是当且仅当传给f的实参为右值时，即T为非引用类型，才将fParam（左值）转化为一个右值。 所以std::forward可以这样实现： ////不是标准库版本的实现（忽略了一些接口描述） template //在std命名空间 T&& forward(typename remove_reference::type& param) { return static_cast(param); } //在C++14中，std::remove_reference_t的存在使得实现变得更简洁： template //C++14；仍然在std命名空间 T&& forward(remove_reference_t& param) { return static_cast(param); } 引用折叠发生在四种情况下。 第一，也是最常见的就是模板实例化。 第二，是auto变量的类型生成，具体细节类似于模板，因为auto变量的类型推导基本与模板类型推导雷同（参见Item2）。 Widget widgetFactory(); //返回右值的函数 Widget w; //一个变量（左值） auto&& w1 = w; //左值初始化w1，因此为auto推导出类型Widget& //产生了引用的引用 Widget& && w1 = w;发生引用折叠 //结果就是w1是一个左值引用。Widget& w1 = w auto&& w2 = widgetFactory(); //右值初始化w2，auto推导出非引用类型Widget。代入auto得到： //Widget&& w2 = widgetFactory()最终结果，w2是个右值引用。 [!important] 通用引用不是一种新的引用，它实际上是满足以下两个条件下的右值引用： 类型推导区分左值和右值。T类型的左值被推导为T&类型，T类型的右值被推导为T。 发生引用折叠。 第三种情况是typedef和别名声明的产生和使用中（参见Item9）。 在创建或者评估typedef过程中出现了引用的引用，则引用折叠就会起作用。 template class Widget { public: typedef T&& RvalueRefToT; … }; //使用左值引用实例化Widget Widget w; //typedef int& && RvalueRefToT;引用折叠后 //typedef int& RvalueRefToT; 最后一种引用折叠发生的情况是，decltype使用的情况。 分析decltype期间，出现了引用的引用，引用折叠规则就会起作用（关于decltype，参见Item3） 总结 [!note] 引用折叠发生在四种情况下：模板实例化，auto类型推导，typedef与别名声明的创建和使用，decltype。 当编译器在引用折叠环境中生成了引用的引用时，结果就是单个引用。有左值引用折叠结果就是左值引用，否则就是右值引用。 通用引用就是在特定上下文的右值引用，上下文是通过类型推导区分左值还是右值，并且发生引用折叠的那些地方。 Item 29: Assume that move operations are not present, not cheap, and not used 移动语义 移动语义可以说是C++11最主要的特性。 它不仅允许编译器使用开销小的移动操作代替大开销的复制操作，而且默认这么做（当特定条件满足的时候）。 [!warning] 移动语义确实可以做这些事，这把这个特性封为一代传说。 这个条款的目的就是给你泼一瓢冷水，保持理智看待移动语义。 \"冷水\" 已知很多类型不支持移动操作 对于你的应用中（或者代码库中）的类型，没有适配C++11的部分，编译器即使支持移动语义也是无能为力的。 C++11倾向于为缺少移动操作的类生成它们，但是只有在没有声明复制操作，移动操作，或析构函数的类中才会生成移动操作（参考Item17）。 对于没有明确支持移动操作的类型，并且不符合编译器默认生成的条件的类，没有理由期望C++11会比C++98进行任何性能上的提升。 显式支持了移动操作，结果可能也没有你希望的那么好。 认为移动所有容器的开销都非常小是个错误 对于某些容器来说，压根就不存在开销小的方式来移动它所包含的内容。 对另一些容器来说，容器的开销真正小的移动操作会有有些容器元素不能满足的注意条件。 std::array，这是C++11中的新容器。 std::array本质上是具有STL接口的内置数组。 存储具体数据在堆内存的容器，本身只保存了指向堆内存中容器内容的指针（真正实现更复杂一些，但基本逻辑就是这样）。 指针的存在使得在常数时间移动整个容器成为可能，只需要从源容器拷贝保存指向容器内容的指针到目标容器，然后将源指针置为空指针就可以了： std::vector vw1; //把数据存进vw1 … //把vw1移动到vw2。以常数时间运行。只有vw1和vw2中的指针被改变 auto vw2 = std::move(vw1); 但是std::array没有这种指针实现，数据就保存在std::array对象中： std::array aw1; //把数据存进aw1 … //把aw1移动到aw2。以线性时间运行。aw1中所有元素被移动到aw2 auto aw2 = std::move(aw1); 使用std::array的移动操作还是复制操作都将花费线性时间的开销，因为每个容器中的元素终归需要拷贝或移动一次 另一方面，std::string提供了常数时间的移动操作和线性时间的复制操作。 [!warning] 但是可能不一定。 许多字符串的实现采用了小字符串优化（small string optimization，SSO）。 “小”字符串（比如长度小于15个字符的）存储在了std::string的缓冲区中，并没有存储在堆内存 移动这种存储的字符串并不比复制操作更快。 移动语义并无优势? 即使对于支持快速移动操作的类型，某些看似可靠的移动操作最终也会导致复制。 Item14解释了原因，标准库中的某些容器操作提供了强大的异常安全保证，确保依赖那些保证的C++98的代码在升级到C++11且仅当移动操作不会抛出异常，从而可能替换操作时，不会不可运行。 结果就是，即使类提供了更具效率的移动操作，而且即使移动操作更合适（比如源对象是右值），编译器仍可能被迫使用复制操作，因为移动操作没有声明noexcept。 存在几种情况，C++11的移动语义并无优势： 没有移动操作：要移动的对象没有提供移动操作，所以移动的写法也会变成复制操作。 移动不会更快：要移动的对象提供的移动操作并不比复制速度更快。 移动不可用：进行移动的上下文要求移动操作不会抛出异常，但是该操作没有被声明为noexcept。 值得一提的是，还有另一个场景，会使得移动并没有那么有效率： 源对象是左值：除了极少数的情况外（例如Item25），只有右值可以作为移动操作的来源。 [!important] 但是，通常，你了解你代码里使用的类型，依赖他们的特性不变性（比如是否支持快速移动操作）。 这种情况，你无需这个条款的假设，只需要查找所用类型的移动操作详细信息。 如果类型提供了快速移动操作，并且在调用移动操作的上下文中使用对象，可以安全的使用快速移动操作替换复制操作。 总结 [!note] 假定移动操作不存在，成本高，未被使用。 在已知的类型或者支持移动语义的代码中，就不需要上面的假设。 Item 30: Familiarize yourself with perfect forwarding failure cases 完美转发 C++11最显眼的功能之一就是完美转发功能。 “完美转发”的含义: [!note] “转发”仅表示将一个函数的形参传递——就是转发——给另一个函数。 对于第二个函数（被传递的那个）目标是收到与第一个函数（执行传递的那个）完全相同的对象。 这规则排除了按值传递的形参，因为它们是原始调用者传入内容的拷贝。 指针形参也被排除在外，因为我们不想强迫调用者传入指针。 [!important] 关于通常目的的转发，我们将处理引用形参。 完美转发（perfect forwarding）意味不仅转发对象，还转发显著的特征：类型，是左值还是右值，是const还是volatile。 将使用通用引用（参见Item24），因为通用引用形参被传入实参时才确定是左值还是右值。 有一些函数f，然后想编写一个转发给它的函数 template void fwd(T&& param) //接受任何实参 { f(std::forward(param)); //转发给f } 从本质上说，转发函数是通用的。例如fwd模板，接受任何类型的实参，并转发得到的任何东西。 fwd的可变形式如下： template void fwd(Ts&&... params) //接受任何实参 { f(std::forward(params)...); //转发给f } 转发函数不仅是模板，而且是可变模板，因此可以接受任何数量的实参 无法做到完美转发的实参类型 [!warning] 如果f使用某特定实参会执行某个操作，但是fwd使用相同的实参会执行不同的操作，完美转发就会失败 f( expression ); //调用f执行某个操作 fwd( expression ); //但调用fwd执行另一个操作，则fwd不能完美转发expression给f 或者模板类型推导失败，完美转发会失败。 花括号初始化器 假定f这样声明： void f(const std::vector& v); //用花括号初始化调用 f({ 1, 2, 3 }); //可以，“{1, 2, 3}”隐式转换为std::vector //传递相同的列表初始化给fwd不能编译 fwd({ 1, 2, 3 }); //错误！不能编译 这是因为这是完美转发失效的一种情况。所有这种错误有相同的原因。 当通过调用函数模板fwd间接调用f时，编译器推导传入给fwd的实参类型，然后比较推导后的实参类型和f的形参声明类型。当下面情况任何一个发生时，完美转发就会失败： [!important] 编译器不能推导出fwd的一个或者多个形参类型。 这种情况下代码无法编译。 编译器推导“错”了fwd的一个或者多个形参类型。 在这里，“错误”可能意味着fwd的实例将无法使用推导出的类型进行编译，但是也可能意味着使用fwd的推导类型调用f，与用传给fwd的实参直接调用f表现出不一致的行为。这种不同行为的原因可能是因为f是个重载函数的名字，并且由于是“不正确的”类型推导，在fwd内部调用的f重载和直接调用的f重载不一样。 在上面的fwd({ 1, 2, 3 })例子中 问题在于，将花括号初始化传递给未声明为std::initializer_list的函数模板形参，被判定为“非推导上下文”。意味着编译器不准在对fwd的调用中推导表达式{ 1, 2, 3 }的类型 一种简单的解决方法——使用auto声明一个局部变量，然后将局部变量传进转发函数： auto il = { 1, 2, 3 }; //il的类型被推导为std::initializer_list fwd(il); //可以，完美转发il给f 0或者NULL作为空指针 [!important] Item8说明当你试图传递0或者NULL作为空指针给模板时，类型推导会出错，会把传来的实参推导为一个整型类型（典型情况为int）而不是指针类型。 解决方法非常简单，传一个nullptr而不是0或者NULL。 仅有声明的整型static const数据成员 [!important] 通常，无需在类中定义整型static const数据成员 声明就可以了。这是因为编译器会对此类成员实行常量传播（const propagation），因此消除了保留内存的需要。 [!tip] 常量传播（const propagation） 代码中存在被声明为常量（const）的值时，编译器会尝试将这些常量值直接替换到它们被使用的地方，而不是在运行时去访问存储这些常量值的内存位置。 class Widget { public: static const std::size_t MinVals = 28; //MinVal的声明 … }; … //没有MinVals定义 std::vector widgetData; widgetData.reserve(Widget::MinVals); //使用MinVals 译器通过将值28放入所有提到MinVals的位置来补充缺少的定义（就像它们被要求的那样） 上面的代码仍然可以编译，但是链接时就会报错，直到为MinVals提供定义 想象下f（fwd要转发实参给它的那个函数）这样声明： void f(std::size_t val); //使用MinVals调用f是可以的，因为编译器直接将值28代替MinVals： f(Widget::MinVals); //可以，视为“f(28)” //尝试通过fwd调用f fwd(Widget::MinVals); //错误！不应该链接 底层的问题是一样的。 代码中没有使用MinVals的地址，但是fwd的形参是通用引用，而引用，在编译器生成的代码中，通常被视作指针。 [!tip] 在程序的二进制底层代码中（以及硬件中）指针和引用是一样的。在这个水平上，引用只是可以自动解引用的指针。 通过引用传递MinVals实际上与通过指针传递MinVals是一样的，因此，必须有内存使得指针可以指向。 通过引用传递的整型static const数据成员，通常需要定义它们，这个要求可能会造成在不使用完美转发的代码成功的地方，使用等效的完美转发失败。（译者注：这里意思应该是没有定义，完美转发就会失败） [!warning] 根据标准，通过引用传递MinVals要求有定义。 但不是所有的实现都强制要求这一点。 重载函数的名称和模板名称 函数f（我们想通过fwd完美转发实参给的那个函数）可以通过向其传递执行某些功能的函数来自定义其行为。 //函数接受和返回值都是int void f(int (*pf)(int)); //pf = “process function” //也可以使用更简单的非指针语法声明 void f(int pf(int)); //与上面定义相同的f 假设我们有了一个重载函数 int processVal(int value); int processVal(int value, int priority); //传递processVal给f f(processVal); //可以 f要求一个函数指针作为实参，但是processVal不是一个函数指针或者一个函数，它是同名的两个不同函数。但是，编译器可以知道它需要哪个：匹配上f的形参类型的那个。 fwd是一个函数模板，没有它可接受的类型的信息，使得编译器不可能决定出哪个函数应被传递： fwd(processVal); //错误！那个processVal？ 单用processVal是没有类型信息的，所以就不能类型推导，完美转发失败。 试图使用函数模板而不是（或者也加上）重载函数的名字，同样的问题也会发生。 一个函数模板不代表单独一个函数，它表示一个函数族： template T workOnVal(T param) //处理值的模板 { … } fwd(workOnVal); //错误！哪个workOnVal实例？ 要让像fwd的完美转发函数接受一个重载函数名或者模板名，方法是指定要转发的那个重载或者实例。 创造与f相同形参类型的函数指针，通过processVal或者workOnVal实例化这个函数指针 using ProcessFuncType = //写个类型定义；见条款9 int (*)(int); ProcessFuncType processValPtr = processVal; //指定所需的processVal签名 fwd(processValPtr); //可以 fwd(static_cast(workOnVal)); //也可以 这要求你知道fwd转发的函数指针的类型。 位域 完美转发最后一种失败的情况是函数实参使用位域这种类型。 IPv4的头部有如下模型： struct IPv4Header { std::uint32_t version:4, IHL:4, DSCP:6, ECN:2, totalLength:16; … }; f（转发函数fwd的目标）为接收一个std::size_t的形参，则使用IPv4Header对象的totalLength字段进行调用没有问题： void f(std::size_t sz); //要调用的函数 IPv4Header h; … f(h.totalLength); //可以 //通过fwd转发 fwd(h.totalLength); //错误！ 问题在于fwd的形参是引用，而h.totalLength是non-const位域。 [!warning] C++标准非常清楚地谴责了这种组合：non-const引用不应该绑定到位域。 禁止的理由很充分。位域可能包含了机器字的任意部分（比如32位int的3-5位），但是这些东西无法直接寻址。 一旦意识到接收位域实参的函数都将接收位域的副本，就可以轻松解决位域不能完美转发的问题。 没有函数可以绑定引用到位域，也没有函数可以接受指向位域的指针 位域可以传给的形参种类只有按值传递的形参 [!tip] 传reference-to-const形参的情况中，标准要求这个引用实际上绑定到存放位域值的副本对象 但是eference-to-const不直接绑定到位域，而是绑定位域值拷贝到的一个普通对象。 可以自己创建副本然后利用副本调用完美转发。在IPv4Header的例子中，可以如下写法： //拷贝位域值；参看条款6了解关于初始化形式的信息 auto length = static_cast(h.totalLength); fwd(length); //转发这个副本 总结 大多数情况下，完美转发工作的很好。你基本不用考虑其他问题。 [!note] 当模板类型推导失败或者推导出错误类型，完美转发会失败。 导致完美转发失败的实参种类有花括号初始化，作为空指针的0或者NULL，仅有声明的整型static const数据成员，模板和重载函数的名字，位域。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - CHAPTER_5_RValue_References,Move_Semantics_and_Perfect_Forwarding "},"docs/Cpp/Effective-Modern-C++/CHAPTER_6_Lambda_Expressions.html":{"url":"docs/Cpp/Effective-Modern-C++/CHAPTER_6_Lambda_Expressions.html","title":"CHAPTER_6_Lambda_Expressions","keywords":"","body":" CHAPTER 6 Lambda Expressions Lambda Item 31: Avoid default capture modes 引用捕获 按值捕获 总结 Item 32: Use init capture to move objects into closures 初始化捕获 C++11手动实现移动捕获 总结 Item 33: Use decltype on auto&& parameters to std::forward them lambada完美转发 总结 Item 34: Prefer lambdas to std::bind std::bind 优先 lambda 复杂的lambda 占位符的行为 lambda and std::bind 总结 [TOC] CHAPTER 6 Lambda Expressions Lambda [!important] lambda表达式是C++编程中的游戏规则改变者。 lambda是创建函数对象相当便捷的一种方法 STL中的“_if”算法（比如，std::find_if，std::remove_if，std::count_if等）通常需要繁琐的谓词可以通过lambda实现 用比较函数（比如，std::sort，std::nth_element，std::lower_bound等）来自定义算法也是同样方便的。 在STL外，lambda可以快速创建std::unique_ptr和std::shared_ptr的自定义删除器（见Item18和19） 线程API中条件变量的谓词指定变得同样简单 除了标准库，lambda有利于即时的回调函数，接口适配函数和特定上下文中的一次性函数。 lambda\\表达式（lambda expression）就是一个表达式。 std::find_if(container.begin(), container.end(), [](int val){ return 0 闭包（enclosure）是lambda创建的运行时对象。依赖捕获模式，闭包持有被捕获数据的副本或者引用。在上面的std::find_if调用中，闭包是作为第三个实参在运行时传递给std::find_if的对象。 闭包类（closure class）是从中实例化闭包的类。每个lambda都会使编译器生成唯一的闭包类。lambda中的语句成为其闭包类的成员函数中的可执行指令。 lambda通常被用来创建闭包，该闭包仅用作函数的实参。 { int x; //x是局部对象 auto c1 = //c1是lambda产生的闭包的副本 [x](int y) { return x * y > 55; }; auto c2 = c1; //c2是c1的拷贝 auto c3 = c2; //c3是c2的拷贝 } 闭包通常可以拷贝，所以可能有多个闭包对应于一个lambda [!tip] 非正式的讲，模糊lambda，闭包和闭包类之间的界限是可以接受的。但是，在随后的Item中，区分什么存在于编译期（lambdas 和闭包类），什么存在于运行时（闭包）以及它们之间的相互关系是重要的。 Item 31: Avoid default capture modes [!important] C++11中有两种默认的捕获模式：按引用捕获和按值捕获。 默认按引用捕获模式可能会带来悬空引用的问题 引用捕获 按引用捕获会导致闭包中包含了对某个局部变量或者形参的引用，变量或形参只在定义lambda的作用域中可用。 该lambda创建的闭包生命周期超过了局部变量或者形参的生命周期，那么闭包中的引用将会变成悬空引用。 元素是过滤函数（filtering function）的一个容器，该函数接受一个int，并返回一个bool，该bool的结果表示传入的值是否满足过滤条件： using FilterContainer = //“using”参见条款9， std::vector>; //std::function参见条款2 FilterContainer filters; //过滤函数 //添加一个过滤器，用来过滤掉5的倍数： filters.emplace_back( //emplace_back的信息见条款42 [](int value) { return value % 5 == 0; } ); 需要的是能够在运行期计算除数（divisor），即不能将5硬编码到lambda中。 void addDivisorFilter() { auto calc1 = computeSomeValue1(); auto calc2 = computeSomeValue2(); auto divisor = computeDivisor(calc1, calc2); filters.emplace_back( //危险！对divisor的引用 [&](int value) { return value % divisor == 0; } //将会悬空！ ); } //同样显式按引用捕获也一样 filters.emplace_back( [&divisor](int value) //危险！对divisor的引用将会悬空！ { return value % divisor == 0; } ); lambda对局部变量divisor进行了引用，但该变量的生命周期会在addDivisorFilter返回时结束，因此添加到filters的函数添加完，该函数就会导致未定义行为。 通过显式的捕获，能更容易看到lambda的可行性依赖于变量divisor的生命周期。比起“[&]”传达的意思，显式捕获能让人更容易想起“确保没有悬空变量”。 一个闭包将会被马上使用（例如被传入到一个STL算法中）并且不会被拷贝 例如，我们的过滤lambda只会用做C++11中std::all_of的一个实参，返回满足条件的所有元素： template void workWithContainer(const C& container) { auto calc1 = computeSomeValue1(); //同上 auto calc2 = computeSomeValue2(); //同上 auto divisor = computeDivisor(calc1, calc2); //同上 using ContElemT = typename C::value_type; //容器内元素的类型 using std::begin; //为了泛型，见条款13 using std::end; if (std::all_of( //如果容器内所有值都为 begin(container), end(container), //除数的倍数 [&](const ContElemT& value) { return value % divisor == 0; }) ) { … //它们... } else { … //至少有一个不是的话... } } 是安全的做法，但这种安全是不确定的 发现lambda在其它上下文中很有用（例如作为一个函数被添加在filters容器中），然后拷贝粘贴到一个divisor变量已经死亡，但闭包生命周期还没结束的上下文中，又会悬空使用 从长期来看，显式列出lambda依赖的局部变量和形参，是更加符合软件工程规范的做法。 [!tip] C++14支持了在lambda中使用auto来声明变量 if (std::all_of(begin(container), end(container), [&](const auto& value) // C++14 { return value % divisor == 0; })) 按值捕获 一个解决问题的方法是，divisor默认按值捕获进去，也就是说可以按照以下方式来添加lambda到filters： filters.emplace_back( //现在divisor不会悬空了 [=](int value) { return value % divisor == 0; } ); 在通常情况下，按值捕获并不能完全解决悬空引用的问题。 如果你按值捕获的是一个指针，你将该指针拷贝到lambda对应的闭包里，但这样并不能避免lambda外delete这个指针的行为，从而导致你的副本指针变成悬空指针。 在一个Widget类，可以实现向过滤器的容器添加条目： class Widget { public: … //构造函数等 void addFilter() const; //向filters添加条目 private: int divisor; //在Widget的过滤器使用 }; void Widget::addFilter() const { filters.emplace_back( [=](int value) { return value % divisor == 0; } ); } [!warning] 捕获只能应用于lambda**被创建时所在作用域里的non-static局部变量**（包括形参）。 Widget::addFilter的视线里，divisor并不是一个局部变量，而是Widget类的一个成员变量，不能被捕获。 显式地捕获divisor变量（或者按引用或者按值），也一样会编译失败 void Widget::addFilter() const { filters.emplace_back( [divisor](int value) //错误！没有名为divisor局部变量可捕获 { return value % divisor == 0; } ); } 解释就是这里隐式使用了一个原始指针：this。 每一个non-static成员函数都有一个this指针，每次你使用一个类内的数据成员时都会使用到这个指针。 在任何Widget成员函数中，编译器会在内部将divisor替换成this->divisor void Widget::addFilter() const { auto currentObjectPtr = this; filters.emplace_back( [currentObjectPtr](int value) { return value % currentObjectPtr->divisor == 0; } ); } 真正被捕获的是Widget的this指针，而不是divisor [!note] lambda闭包的生命周期与Widget对象的关系，闭包内含有Widget的this指针的拷贝。 using FilterContainer = //跟之前一样 std::vector>; FilterContainer filters; //跟之前一样 void doSomeWork() { auto pw = //创建Widget；std::make_unique std::make_unique(); //见条款21 pw->addFilter(); //添加使用Widget::divisor的过滤器 } //销毁Widget；filters现在持有悬空指针！ 问题可以通过给你想捕获的数据成员做一个局部副本，然后捕获这个副本去解决： void Widget::addFilter() const { auto divisorCopy = divisor; //拷贝数据成员 filters.emplace_back( [divisorCopy](int value) //捕获副本 { return value % divisorCopy == 0; } //使用副本 ); } //采用这种方法，默认的按值捕获也是可行的。 void Widget::addFilter() const { auto divisorCopy = divisor; //拷贝数据成员 filters.emplace_back( [=](int value) //捕获副本 { return value % divisorCopy == 0; } //使用副本 ); } 当一开始你认为你捕获的是divisor的时候，默认捕获模式就是造成可能意外地捕获this的元凶。 [!tip] 在C++14中，一个更好的捕获成员变量的方式时使用通用的lambda捕获： void Widget::addFilter() const { filters.emplace_back( //C++14： [divisor = divisor](int value) //拷贝divisor到闭包 { return value % divisor == 0; } //使用这个副本 ); } 这种通用的lambda捕获并没有默认的捕获模式，因此在C++14中，本条款的建议——避免使用默认捕获模式——仍然是成立的。 使用默认的按值捕获还有另外的一个缺点，它们预示了相关的闭包是独立的并且不受外部数据变化的影响。 lambda可能会依赖局部变量和形参（它们可能被捕获），还有静态存储生命周期（static storage duration）的对象。 例如，这些对象定义在全局空间或者命名空间，或者在类、函数、文件中声明为static。 默认按值捕获可能会因此误导你，让你以为捕获了这些变量。 这些对象定义在全局空间或者命名空间，或者在类、函数、文件中声明为static。能在lambda里使用，但它们不能被捕获。 void addDivisorFilter() { static auto calc1 = computeSomeValue1(); //现在是static static auto calc2 = computeSomeValue2(); //现在是static static auto divisor = //现在是static computeDivisor(calc1, calc2); filters.emplace_back( [=](int value) //什么也没捕获到！ { return value % divisor == 0; } //引用上面的static ); ++divisor; //调整divisor } 这个lambda没有使用任何的non-static局部变量，所以它没有捕获任何东西 总结 [!note] 默认的按引用捕获可能会导致悬空引用。 默认的按值捕获对于悬空指针很敏感（尤其是this指针），并且它会误导人产生lambda是独立的想法。 Item 32: Use init capture to move objects into closures 初始化捕获 在某些场景下，按值捕获和按引用捕获都不是你所想要的。如果你有一个只能被移动的对象（例如std::unique_ptr或std::future）要进入到闭包里，移动该对象到闭包而不是复制它 缺少移动捕获被认为是C++11的一个缺点，标准化委员会选择了另一种方法。引入了一种新的捕获机制，移动捕获是它可以执行的技术之一。新功能被称作初始化捕获（init capture） [!important] 使用初始化捕获可以让你指定： 从lambda生成的闭包类中的数据成员名称； 初始化该成员的表达式； 初始化捕获将std::unique_ptr移动到闭包中的方法 class Widget { //一些有用的类型 public: … bool isValidated() const; bool isProcessed() const; bool isArchived() const; private: … }; auto pw = std::make_unique(); //创建Widget；使用std::make_unique //的有关信息参见条款21 … //设置*pw auto func = [pw = std::move(pw)] //使用std::move(pw)初始化闭包数据成员 { return pw->isValidated() && pw->isArchived(); }; 高亮的文本包含了初始化捕获的使用（译者注：高亮了“pw = std::move(pw)”），“=”的左侧是指定的闭包类中数据成员的名称，右侧则是初始化表达式。 =”左侧的作用域不同于右侧的作用域。左侧的作用域是闭包类，右侧的作用域和lambda定义所在的作用域相同。 [!tip] 如果std::make_unique创建的Widget处于适合被lambda捕获的状态，则不需要局部变量pw，因为闭包类的数据成员可以通过std::make_unique直接初始化： auto func = [pw = std::make_unique()] //使用调用make_unique得到的结果 { return pw->isValidated() //初始化闭包数据成员 && pw->isArchived(); }; 在C++11中，无法捕获表达式的结果。 因此，初始化捕获的另一个名称是通用*lambda*捕获（generalized lambda capture）。 C++11手动实现移动捕获 [!important] 请记住，lambda表达式只是生成一个类和创建该类型对象的一种简单方式而已。 刚刚看到的C++14的示例代码可以用C++11重新编写，如下所示： class IsValAndArch { //“is validated and archived” public: using DataType = std::unique_ptr; explicit IsValAndArch(DataType&& ptr) //条款25解释了std::move的使用 : pw(std::move(ptr)) {} bool operator()() const { return pw->isValidated() && pw->isArchived(); } private: DataType pw; }; auto func = IsValAndArch(std::make_unique())(); 坚持要使用lambda，移动捕获可以在C++11中这样模拟： 将要捕获的对象移动到由std::bind产生的函数对象中； 将“被捕获的”对象的引用赋予给lambda。 例如：假设你要创建一个本地的std::vector，在其中放入一组适当的值，然后将其移动到闭包中。 //在C++14中，这很容易实现： std::vector data; //要移动进闭包的对象 … //填充data auto func = [data = std::move(data)] //C++14初始化捕获 { /*使用data*/ }; //C++11的等效代码如下，其中我强调了相同的关键事项： std::vector data; //同上 … //同上 auto func = std::bind( //C++11模拟初始化捕获 [](const std::vector& data) //译者注：本行高亮 { /*使用data*/ }, std::move(data) //译者注：本行高亮 ); std::bind返回的函数对象称为bind对象（bind objects）。 std::bind的第一个实参是可调用对象，后续实参表示要传递给该对象的值。 一个bind对象包含了传递给std::bind的所有实参的副本。 [!warning] 添加了一个形参data来对应我们的伪移动捕获对象。此形参是对bind对象中data副本的左值引用。 因此，lambda将对绑定在对象内部的移动构造的data副本进行操作。 默认情况下，从lambda生成的闭包类中的operator()成员函数为const的 因此，为了防止在lambda内修改该data副本，lambda的形参应声明为reference-to-const。 但是，将lambda声明为mutable，则闭包类中的operator()将不会声明为const，并且在lambda的形参声明中省略const也是合适的： auto func = std::bind( //C++11对mutable lambda [](std::vector& data) mutable //初始化捕获的模拟 { /*使用data*/ }, std::move(data) ); bind对象存储着传递给std::bind的所有实参的副本 bind对象包含由lambda生成的闭包副本， 因此闭包的生命周期与bind对象的生命周期相同 只要存在闭包，包含伪移动捕获对象的bind对象也将存在。 [!important] 使用std::bind基本要点也应该清楚： 无法移动构造一个对象到C++11闭包，但是可以将对象移动构造进C++11的bind对象。 在C++11中模拟移动捕获包括将对象移动构造进bind对象，然后通过传引用将移动构造的对象传递给lambda。 由于bind对象的生命周期与闭包对象的生命周期相同，因此可以将bind对象中的对象视为闭包中的对象。 std::bind模仿移动捕获的第二个示例，这是我们之前看到的在闭包中创建std::unique_ptr的C++14代码： auto func = [pw = std::make_unique()] //同之前一样 { return pw->isValidated() //在闭包中创建pw && pw->isArchived(); }; 这是C++11的模拟实现： auto func = std::bind( [](const std::unique_ptr& pw) { return pw->isValidated() && pw->isArchived(); }, std::make_unique() ); 在Item34中，主张使用lambda而不是std::bind。 总结 [!note] 使用C++14的初始化捕获将对象移动到闭包中。 在C++11中，通过手写类或std::bind的方式来模拟初始化捕获。 Item 33: Use decltype on auto&& parameters to std::forward them lambada完美转发 [!important] 泛型*lambda*（generic lambdas）是C++14中最值得期待的特性之一——因为在lambda的形参中可以使用auto关键字。 即在闭包类中的operator()函数是一个函数模版 auto f = [](auto x){ return func(normalize(x)); }; 对应的闭包类中的函数调用操作符看来就变成这样： class SomeCompilerGeneratedClassName { public: template //auto返回类型见条款3 auto operator()(T x) const { return func(normalize(x)); } … //其他闭包类功能 }; 在这个样例中，lambda对变量x做的唯一一件事就是把它转发给函数normalize。 如果函数normalize对左值右值的方式不一样，这个lambda的实现方式就不好 正确方式是把x完美转发给函数normalize 首先，x需要改成通用引用（见Item24）， 其次，需要使用std::forward将x转发到函数normalize（见Item25）。 auto f = [](auto&& x) { return func(normalize(std::forward(x))); }; 在理论和实际之间应该传递给std::forward的什么类型? 这意味着在这个lambda中，可以通过检查形参x的类型来确定传递进来的实参是一个左值还是右值，decltype就可以实现这样的效果（见Item3）。 [!tip] 用右值引用类型和用非引用类型去初始化std::forward产生的相同的结果。 因此lambda的完美转发可以写成： auto f = [](auto&& param) { return func(normalize(std::forward(param))); }; 再加上6个点，lambda完美转发可以接受多个形参，因为C++14中的lambda也可以是可变形参的： auto f = [](auto&&... params) { return func(normalize(std::forward(params)...)); }; 总结 [!note] 对auto&&形参使用decltype以std::forward它们。 Item 34: Prefer lambdas to std::bind std::bind C++11中的std::bind是C++98的std::bind1st和std::bind2nd的后续 在头文件 中定义 template */\\* 未指定 \\*bind( F&& f, Args&&... args ); (1) (自 C++11) (自 C++20 起为 constexpr) template \\* 未指定 /* bind( F&& f, Args&&... args ); (2) (自 C++11) (自 C++20 起为 constexpr) 函数模板 std::bind 为 f 生成一个转发调用包装器。调用此包装器等效于调用 f，其中部分参数 绑定 到 args。 对于绑定参数 对于每个存储的参数 arg_i，*INVOKE* 或 *INVOKE* 操作中的相应绑定参数 v_i 按如下方式确定 情况 1：引用包装器 如果 arg_i 的类型为 std::reference_wrapper（例如，std::ref 或 std::cref 在对 std::bind 的初始调用中使用），则 v_i 是 arg_i.get()，它的类型 V_i 是 T&：存储的参数按引用传递给调用的函数对象。 情况 2：绑定表达式 如果 arg_i 的类型为 T，对于它来说，std::is_bind_expression::value 为 true（例如，另一个 std::bind 表达式直接传递给对 std::bind 的初始调用），则 std::bind 执行函数组合：它不会传递绑定子表达式将返回的函数对象，而是急切地调用该子表达式，并将它的返回值传递给外部可调用对象。如果绑定子表达式有任何占位符参数，则它们将与外部绑定共享（从 u1,u2, ... 中选取）。具体来说，v_i 是 arg_i(std::forward(uj)...)，它的类型 V_i 是 std::result_of::type&&(直到 C++17)std::invoke_result_t&&(自 C++17 起)（cv 限定符与 g 相同）。 情况 3：占位符 如果 arg_i 的类型为 T，且 std::is_placeholder::value 不为 0（意味着，在对 std::bind 的初始调用中，使用了诸如 std::placeholders::_1, _2, _3, ... 之类的占位符作为参数），则占位符指示的参数（u1 用于 _1，u2 用于 _2，等等）将传递给可调用对象：v_i 为 std::forward(uj)，其类型 V_i 为 Uj&&。 情况 4：普通参数 否则，arg_i 将作为左值参数传递给可调用对象：v_i 仅仅是 arg_i，其类型 V_i 为 T cv ﻿&，其中 cv 与 g 的 cv 限定符相同。 优先 lambda 优先lambda而不是std::bind的最重要原因是lambda更易读。 假设我们有一个设置警报器的函数： //一个时间点的类型定义（语法见条款9） using Time = std::chrono::steady_clock::time_point; //“enum class”见条款10 enum class Sound { Beep, Siren, Whistle }; //时间段的类型定义 using Duration = std::chrono::steady_clock::duration; //在时间t，使用s声音响铃时长d void setAlarm(Time t, Sound s, Duration d); 编写一个lambda来修改setAlarm的界面，以便仅需要指定声音 //setSoundL（“L”指代“lambda”）是个函数对象，允许指定一小时后响30秒的警报器的声音 auto setSoundL = [](Sound s) { //使std::chrono部件在不指定限定的情况下可用 using namespace std::chrono; setAlarm(steady_clock::now() + hours(1), //一小时后响30秒的闹钟 s, seconds(30)); //译注：setAlarm三行高亮 }; 使用标准后缀如秒（s），毫秒（ms）和小时（h）等简化在C++14中的代码，其中标准后缀基于C++11对用户自定义常量的支持。这些后缀在std::literals命名空间中实现 auto setSoundL = [](Sound s) { using namespace std::chrono; using namespace std::literals; //对于C++14后缀 setAlarm(steady_clock::now() + 1h, //C++14写法，但是含义同上 s, 30s); }; 对应的std::bind调用 using namespace std::chrono; //同上 using namespace std::literals; using namespace std::placeholders; //“_1”使用需要 auto setSoundB = //“B”代表“bind” std::bind(setAlarm, steady_clock::now() + 1h, //不正确！见下 _1, 30s); 在std::bind调用中，将steady_clock::now() + 1h作为实参传递给了std::bind 警报器将被设置为在调用std::bind后一小时发出声音，而不是在调用setAlarm一小时后发出。 需要告诉std::bind推迟对表达式的求值，直到调用setAlarm为止，而这样做的方法是将对std::bind的第二个调用嵌套在第一个调用中： //C++14 auto setSoundB = std::bind(setAlarm, std::bind(std::plus<>(), std::bind(steady_clock::now), 1h), _1, 30s); [!tip] 尖括号之间未指定任何类型，即该代码包含“std::plus<>”，而不是“std::plus”。 在C++14中，通常可以省略标准运算符模板的模板类型实参，因此无需在此处提供。 等效于lambda的C++11 std::bind为： using namespace std::chrono; //同上 using namespace std::placeholders; auto setSoundB = std::bind(setAlarm, std::bind(std::plus(), std::bind(steady_clock::now), hours(1)), _1, seconds(30)); 假设有一个重载函数，其中第四个形参指定了音量： enum class Volume { Normal, Loud, LoudPlusPlus }; void setAlarm(Time t, Sound s, Duration d, Volume v); lambda因为根据重载规则选择了setAlarm的三实参版本： auto setSoundL = //和之前一样 [](Sound s) { using namespace std::chrono; setAlarm(steady_clock::now() + 1h, //可以，调用三实参版本的setAlarm s, 30s); }; 然而，std::bind的调用将会编译失败：无法确定应将两个setAlarm函数中的哪一个传递给std::bind auto setSoundB = //错误！哪个setAlarm？ std::bind(setAlarm, std::bind(std::plus<>(), steady_clock::now(), 1h), _1, 必须将setAlarm强制转换为适当的函数指针类型： using SetAlarm3ParamType = void(*)(Time t, Sound s, Duration d); auto setSoundB = //现在可以了 std::bind(static_cast(setAlarm), std::bind(std::plus<>(), steady_clock::now(), 1h), _1, 30s); 在lambda和std::bind的使用上带来了另一个区别。 在setSoundL的函数调用操作符（即lambda的闭包类对应的函数调用操作符）内部，对setAlarm的调用是正常的函数调用，编译器可以按常规方式进行内联： setSoundL(Sound::Siren); //setAlarm函数体在这可以很好地内联 对std::bind的调用是将函数指针传递给setAlarm，在setSoundB的函数调用操作符（即绑定对象的函数调用操作符）内部，对setAlarm的调用是通过一个函数指针。 编译器不太可能通过函数指针内联函数 setSoundB(Sound::Siren); //setAlarm函数体在这不太可能内联 因此，使用lambda可能会比使用std::bind能生成更快的代码。 复杂的lambda 考虑以下C++14的lambda使用，它返回其实参是否在最小值（lowVal）和最大值（highVal）之间的结果，其中lowVal和highVal是局部变量： //在C++11中，lambda也不能采用auto形参 auto betweenL = [lowVal, highVal] (const auto& val) //C++14 { return lowVal 同理使用std::bind可以表达相同的内容 //在C++11中，我们必须指定要比较的类型 using namespace std::placeholders; //同上 auto betweenB = std::bind(std::logical_and<>(), //C++14 std::bind(std::less_equal<>(), lowVal, _1), std::bind(std::less_equal<>(), _1, highVal)); 占位符的行为 占位符（例如_1，_2等）的行为是不透明 有一个函数可以创建Widget的压缩副本： enum class CompLevel { Low, Normal, High }; //压缩等级 Widget compress(const Widget& w, //制作w的压缩副本 CompLevel lev); 创建一个函数对象允许我们指定Widget w的压缩级别 //std::bind Widget w; using namespace std::placeholders; auto compressRateB = std::bind(compress, w, _1); 将w传递给std::bind时，必须将其存储起来，以便以后进行压缩 std::bind总是拷贝它的实参，但是调用者可以使用引用来存储实参 即在std::bind中对于参数默认是按值传递，除非显示利用std::ref传引用 然而在lambda方法中，其中w是通过值还是通过引用捕获是显式的 对由std::bind生成的对象调用中，实参如何传递？ compressRateB(CompLevel::High); //实参如何传递？ 传递给bind对象的所有实参都是通过引用传递的，因为此类对象的函数调用运算符使用完美转发。 lambda and std::bind [!important] 与lambda相比，使用std::bind进行编码的代码可读性较低，表达能力较低，并且效率可能较低。 C++14中，没有std::bind的合理用例。 在C++11中，可以在两个受约束的情况下证明使用std::bind是合理的： 移动捕获。C++11的lambda不提供移动捕获，但是可以通过结合lambda和std::bind来模拟。 有关详细信息，请参阅Item32，该条款还解释了在C++14中，lambda对初始化捕获的支持消除了这个模拟的需求。 多态函数对象。因为bind对象上的函数调用运算符使用完美转发，所以它可以接受任何类型的实参（以Item30中描述的完美转发的限制为界限）。当你要绑定带有模板化函数调用运算符的对象时，此功能很有用。 对于上述多态函数对象，例如这个类 class PolyWidget { public: template void operator()(const T& param); … }; std::bind可以如下绑定一个PolyWidget对象： PolyWidget pw; auto boundPW = std::bind(pw, _1); boundPW可以接受任意类型的对象了： boundPW(1930); //传int给PolyWidget::operator() boundPW(nullptr); //传nullptr给PolyWidget::operator() boundPW(\"Rosebud\"); //传字面值给PolyWidget::operator() 这一点无法使用C++11的lambda做到。 但是，在C++14中，可以通过带有auto形参的lambda轻松实现： auto boundPW = [pw](const auto& param) //C++14 { pw(param); }; [!tip] 在C++11中增加了lambda支持，这使得std::bind几乎已经过时了，从C++14开始，更是没有很好的用例了。 总结 [!note] 与使用std::bind相比，lambda更易读，更具表达力并且可能更高效。 只有在C++11中，std::bind可能对实现移动捕获或绑定带有模板化函数调用运算符的对象时会很有用。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - CHAPTER_6_Lambda_Expressions "},"docs/Cpp/Modern-Cpp-templates-tutorial/":{"url":"docs/Cpp/Modern-Cpp-templates-tutorial/","title":"Modern-Cpp-templates-tutorial","keywords":"","body":" Modern C++ 模板教程 Modern C++ 模板教程 本文件夹包含两个关于 Modern C++ 模板的简短的教程，讲模板的基础用法，适合想了解如何写可复用代码的读者。 此教程并未学习完成，具体内容详见Modern-Cpp-templates-tutorial，介绍了大量现代的C++模板的相关内容，敬请期待后续的学习 目录： 01_函数模板：讲如何写可以接受不同类型参数的函数，一份代码用在多种数据上。 02_类模板：讲如何写可以接受不同类型成员或方法的类，方便重用和扩展。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - Modern-Cpp-templates-tutorial "},"docs/Cpp/Modern-Cpp-templates-tutorial/01_函数模板.html":{"url":"docs/Cpp/Modern-Cpp-templates-tutorial/01_函数模板.html","title":"01_函数模板","keywords":"","body":" 函数模板 定义模板 使用模板 模板参数推导 万能引用与引用折叠 有默认实参的模板类型形参 非类型模板形参 重载函数模板 可变参数模板 模板分文件 include 指令 分文件的原理是什么？ 函数模板 定义模板 函数模板不是函数，只有实例化函数模板，编译器才能生成实际的函数定义。 声明一个函数模板，我们通常要使用： template 函数声明 [!tip] C++17 之前，类型 T 必须是可复制或移动才能传递参数。C++17 以后，即使复制构造函数和移动构造函数都无效，因为 C++17 强制的复制消除，也可以传递临时纯右值。 也可以使用 class 关键字来声明模板类型形参 使用模板 template T max(T a, T b) { return a > b ? a : b; } struct Test{ int v_{}; Test() = default; Test(int v) :v_(v) {} bool operator>(const Test& t) const{ return this->v_ > t.v_; } }; int main(){ int a{ 1 }; int b{ 2 }; std::cout 编译器会实例化两个函数，也就是生成了一个参数为 int 的 max 函数，一个参数为 Test 的函数。 例如 int max(int a, int b) { return a > b ? a : b; } Test max(Test a, Test b) { return a > b ? a : b; } 模板，只有你“用”了它，才会生成实际的代码。 这里的“用”，其实就是指代会隐式实例化，生成代码。 并且需要注意，同一个函数模板生成的不同类型的函数，彼此之间没有任何关系。 [!tip] 显式的指明函数模板的形参类型 template T max(T a, T b) { return a > b ? a : b; } int main(){ int a{ 1 }; int b{ 2 }; max(a, b); // 函数模板 max 被推导为 max max(a, b); // 传递模板类型实参，函数模板 max 为 max } 模板参数推导 当使用函数模板（如 max()）时，模板参数可以由传入的参数推导。 T 可能只是类型的“一部分”。若声明 max() 使用 const& ： template T max(const T& a, const T& b) { return a > b ? a : b; } 如果我们 max(1, 2) 或者说 max(x,x)，T 当然会是 int，但是函数形参类型会是 const int&。详见Deducing Types [!warning] 有不少情况是没有办法进行推导的：即参数有多个类型并且没有显示指定类型 // 省略 max using namespace std::string_literals; int main(){ max(1, 1.2); // Error 无法确定你的 T 到底是要 int 还是 double max(\"luse\"s, \"乐\"); // Error 无法确定你的 T 到底是要 std::string 还是 const char[N] } 需要显式指定函数模板的（T）类型。 max(1, 1.2); max(\"luse\"s, \"乐\"); 又或者说显式类型转换： max(static_cast(1), 1.2); 万能引用与引用折叠 所谓的万能引用（又称转发引用，或者通用引用），即接受左值表达式那形参类型就推导为左值引用，接受右值表达式，那就推导为右值引用。 [!tip] 通用引用不是一种新的引用，它实际上是满足以下两个条件下的右值引用： 类型推导区分左值和右值。T类型的左值被推导为T&类型，T类型的右值被推导为T。 发生引用折叠。 比如： template void f(T&& t){} int a = 10; f(a); // a 是左值表达式，f 是 f 但是它的形参类型是 int& f(10); // 10 是右值表达式，f 是 f 但它的形参类型是 int&& 被推导为 f 涉及到了特殊的推导规则：如果 P 是到无 cv 限定模板形参的右值引用（也就是转发引用）且对应函数的调用实参是左值，那么将到 A 的左值引用类型用于 A 的位置进行推导。 通过模板或 typedef 中的类型操作可以构成引用的引用，此时适用引用折叠（reference collapsing）规则： 右值引用的右值引用折叠成右值引用，所有其他组合均折叠成左值引用。 typedef int& lref; typedef int&& rref; int n; lref& r1 = n; // r1 的类型是 int& lref&& r2 = n; // r2 的类型是 int& rref& r3 = n; // r3 的类型是 int& rref&& r4 = 1; // r4 的类型是 int&& template constexpr Ty&& forward(Ty& Arg) noexcept { return static_cast(Arg); } int a = 10; // 不重要 ::forward(a); // 返回 int&& 因为 Ty 是 int，Ty&& 就是 int&& ::forward(a); // 返回 int& 因为 Ty 是 int&，Ty&& 就是 int& ::forward(a); // 返回 int&& 因为 Ty 是 int&&，Ty&& 就是 int&& 有默认实参的模板类型形参 模板形参也可以有默认值 template void f(); f(); // 默认为 f f(); // 显式指明为 f using namespace std::string_literals; template RT max(const T1& a, const T2& b) { // RT 是 std::string return a > b ? a : b; } int main(){ auto ret = ::max(\"1\", \"2\"s); std::cout [!important] typename RT = decltype(true ? T1{} : T2{}) RT声明为三目运算符表达式的类型 [!tip] 三目表达式要求第二项和第三项之间能够隐式转换，然后整个表达式的类型会是 “公共”类型。 比如第二项是 int 第三项是 double，三目表达式当然会是 double。 using T = decltype(true ? 1 : 1.2); using T2 = decltype(false ? 1 : 1.2); T 和 T2 都是 double 类型。 利用auto 简化这一切。 template auto max(const T& a, const T2& b) -> decltype(true ? a : b){ return a > b ? a : b; } C++11 后置返回类型 [!warning] 后置返回类型虽然也是写的 auto ，但是它根本没推导，只是占位。 这和我们之前用默认模板实参 RT 的区别的返回类型是不一样的 如果函数模板的形参是类型相同 true ? a : b 表达式的类型是 const T& 使用 C++20 简写函数模板，我们可以直接再简化为： decltype(auto) max(const auto& a, const auto& b) { return a > b ? a : b; } C++14 引入了两个特性： 返回类型推导（也就是函数可以直接写 auto 或 decltype(auto) 做返回类型，而不是像 C++11 那样，只是后置返回类型。 decltype(auto) “如果返回类型没有使用 decltype(auto)，那么推导遵循模板实参推导的规则进行”。我们上面的 max 示例如果不使用 decltype(auto)，按照模板实参的推导规则，会忽略引用和 cv 限定符，就只能推导出返回 T 基本类型。 非类型模板形参 模板不接受类型，而是接受值或对象 非类型模板形参当然也可以有默认值： template void f() { std::cout f(); // 显式指明 f 目前，你简单认为需要参数是“常量”即可。 重载函数模板 函数模板与非模板函数可以重载。 template void test(T) { std::puts(\"template\"); } void test(int) { std::puts(\"int\"); } test(1); // 匹配到test(int) test(1.2); // 匹配到模板 test(\"1\"); // 匹配到模板 通常优先选择非模板的函数。 可变参数模板 [!important] 形参包 本节以 C++14 标准进行讲述。 模板形参包是接受零个或更多个模板实参（非类型、类型或模板）的模板形参。函数形参包是接受零个或更多个函数实参的函数形参。 template void sum(Args...args){} 这样一个函数，就可以接受任意类型的任意个数的参数调用 模板中需要 typename 后跟三个点 Args，函数形参中需要用模板类型形参包后跟着三个点 再 args。 args 是函数形参包，Args 是类型形参包，它们的名字我们可以自定义。 args 里，就存储了我们传入的全部的参数，Args 中存储了我们传入的全部参数的类型。 形参包展开 void f(const char*, int, double) { puts(\"值\"); } void f(const char**, int*, double*) { puts(\"&\"); } template void sum(Args...args){ // const char * args0, int args1, double args2 f(args...); // 相当于 f(args0, args1, args2) f(&args...); // 相当于 f(&args0, &args1, &args2) } int main() { sum(\"luse\", 1, 1.2); } sum 的 Args...args 被展开为 const char * args0, int args1, double args2。 [!tip] 定义一个术语：模式。 后随省略号且其中至少有一个形参包的名字的模式会被展开 成零个或更多个逗号分隔的模式实例。 &args... 中 &args 就是模式 展开的时候，模式，也就是省略号前面的一整个表达式，会被不停的填入对象并添加 &，然后逗号分隔。直至形参包的元素被消耗完。 template void print(const Args&...args){ // const char (&args0)[5], const int & args1, const double & args2 int _[]{ (std::cout 模式是：(std::cout [!warning] 只有在合适的形参包展开场所才能进行形参包展开。 template void print(const Args &...args) { (std::cout 一个数组的示例： template void print(const Args&...args) { int _[]{ (std::cout void f(const T(&array)[N], Args...index) { print(array[index]...); //array[index]... 是包展开 //array[index] 是模式 } int main() { int array[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; f(array, 1, 3, 5); } 实现一个 sum： #include #include template> RT sum(const Args&...args) { RT _[]{ static_cast(args)... }; RT n{}; for (int i = 0; i std::common_type_t 的作用很简单，就是确定我们传入的共用类型，说白了就是这些东西都能隐式转换到哪个，那就会返回那个类型。 [!tip] RT _[]{ static_cast(args)... }; 创建一个数组，形参包在它的初始化器中展开，初始化这个数组，数组存储了我们传入的全部的参数。 因为窄化转换禁止了列表初始化中 int 到 double 的隐式转换，所以我们需要显式的转换为“公共类型” RT。 非类型模板形参也可以使用形参包 template void f(){ std::size_t _[]{ N... }; // 展开相当于 1UL, 2UL, 3UL, 4UL, 5UL std::for_each(std::begin(_), std::end(_), [](std::size_t n){ std::cout (); 模板分文件 对模板进行分文件，写成 .h .cpp 这种形式。 这显然是不可以的 #include \"test.h\" #include \"test_template.h\" int main(){ f(); // 非模板，OK f_t(1); // 模板 链接错误 } 从头讲解编译链接，以及 #include 的知识 include 指令 预处理指令 #include 开始，就是简单的替换，但是不够明确 分文件的原理是什么？ 通常将函数声明放在 .h 文件中，将函数定义放在 .cpp 文件中，我们只需要在需要使用的文件中 include 一个 .h 文件 事实上是把函数声明复制到了我们当前的文件中。 //main.cpp #include \"test.h\" int main(){ f(); // 非模板，OK } 编译器在编译一个翻译单元（如 main.cpp）的时候，如果发现找不到函数的定义，那么就会空着一个符号地址，将它编译为目标文件。期待链接器在链接的时候去其他的翻译单元找到定义来填充符号。 不单单是函数，全局变量等都是这样，这是编译链接的基本原理和步骤。 类会有所不同，总而言之后续视频会单独讲解的。 不能模板不能分文件4的原因就显而易见了，我们在讲使用模板的时候就说了： 模板，只有你“用”了它，才会生成实际的代码。 单纯的放在一个 .cpp 文件中，它不会生成任何实际的代码，自然也没有函数定义，也谈不上链接器找符号了。 所以模板通常是直接放在 .h 文件中，而不会分文件。或者说用 .hpp 这种后缀，这种约定俗成的，代表这个文件里放的是模板。 注：函数模板自身并不是类型、函数或任何其他实体。不会从只包含模板定义的源文件生成任何代码。模板只有实例化才会有代码出现。 ↩ 注：术语“实例化”，指代的是编译器确定各模板实参（可以是根据传入的参数推导，又或者是自己显式指明模板的实参）后从模板生成实际的代码（如从函数模板生成函数，类模板生成类等），这是在编译期就完成的，没有运行时开销。实例化还分为隐式实例化和显式实例化，后面会详细聊。 ↩ 注：“重载决议”，简单来说，一个函数被重载，编译器必须决定要调用哪个重载，我们决定调用的是各形参与各实参之间的匹配最紧密的重载。 ↩ 注：这个问题可以通过显式实例化解决，在后面会讲。 [↩](https://github.com/Mq-b/Modern-Cpp-templates-tutorial/blob/main/md/第一部分-基础知识/01函数模板.md#user-content-fnref-4-3aff5140d04d84f7bex ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 01_函数模板 "},"docs/Cpp/Modern-Cpp-templates-tutorial/02_类模板.html":{"url":"docs/Cpp/Modern-Cpp-templates-tutorial/02_类模板.html","title":"02_类模板","keywords":"","body":" 类模板 初始类模板 定义类模板 使用类模板 类模板推导 有默认实参的模板形参 模板模板形参 成员函数模板 可变参数类模板 类模板分文件 类模板 初始类模板 类模板不是类，只有实例化类模板，编译器才能生成实际的类。 类似于函数模板必须实例化才有对应的函数 定义类模板 和普通类的区别只是多了一个 template 和函数模板一样，其实类模板的语法也就是： template 类声明 函数模板中形参列表能写的东西，类模板都可以 使用类模板 [!tip] 必须显式的指明类模板的类型实参，并且没有办法推导 // Test t; // Error!无法声明void变量 Test t2; // Test t3; // Error!没有显示指明类型，同时无法推导 Test t4{ 1 }; // C++17 OK！ Test t4{ 1 }; C++17 增加了类模板实参推导，也就是说类模板也可以像函数模板一样被推导，而不需要显式的写明模板类型参数了，这里的 Test 被推导为 Test。 类模板推导 对于简单的类模板，通常可以普通的类似函数模板一样的自动推导 template struct A{ A(T, T); }; auto y = new A{1, 2}; // 分配的类型是 A new 表达式中一样可以 [!important] 用户定义的推导指引 模板名称(类型a)->模板名称 如果涉及的是一类类型，那么就需要加上 template，然后使用它的模板形参。 稍微有点难度的需求： template struct array { Ty arr[size]; }; ::array arr{1, 2, 3, 4, 5}; // Error! 类模板 array 同时使用了类型模板形参与非类型模板形参，保有了一个成员是数组。 它无法被我们直接推导出类型，此时就需要定义推导指引**。 template array(T t,Args...) -> array; 让模板形参单独写一个 T 占位，放到形参列表中，并且写一个模板类型形参包用来处理任意个参数 直接使用 sizeof... 获取形参包的元素个数，然后再 +1 ，因为先前用了一个模板形参占位 有默认实参的模板形参 类模板一样可以有默认实参。 template struct X{}; X x; // x 是 X C++17 起 OK X<> x2; // x2 是 XC++14起可以省略 必须达到 C++17 有 CTAD，才可以在全局、函数作用域声明为 X 这种形式，才能省略 <>。 在类中声明一个，有默认实参的类模板类型的数据成员（静态或非静态，是否类内定义都无所谓），不管是否达到 C++17，都不能省略 <>。 [!warning] gcc13.2 有不同行为，开启 std=c++17，类内定义的静态数据成员省略 <> 可以通过编译。但是，总而言之，不要类内声明中省略 <>。 给常量模板形参以默认值：template 模板模板形参 类模板的模板类型形参可以接受一个类模板作为参数，我们将它称为：模板模板形参。 template struct X {}; template typename C> struct Test {}; Testarr; template typename C 我们分两部分看就好 前面的 template 就是我们要接受的类模板它的模板列表，是需要一模一样的，比如类模板 X 就是。 后面的 typename 是语法要求，需要声明这个模板模板形参的名字，可以自定义，这样就引入了一个模板模板形参。 详细的语法形式： template typename(C++17)|class 名字(可选) (1) template typename(C++17)|class 名字(可选) = default (2) template typename(C++17)|class ... 名字(可选) (3) (C++11 起) [!tip] 可以有名字的模板模板形参包。 其实就是形参包的一种，能接受任意个数的类模板 template struct X{}; template struct X2 {}; templatetypename...Ts> struct Test{}; Testt; // 我们可以传递任意个数的模板实参 普通的有形参包的类模板也都是同理： template struct my_array{ int arr[sizeof...(T)]; // 保有的数组大小根据模板类型形参的元素个数 }; template typename C = my_array > struct Array { Carray; }; Arrayarr; 成员函数模板 成员函数模板基本上和普通函数模板没多大区别，唯一需要注意的是，它大致有两类： 类模板中的成员函数模板 普通类中的成员函数模板 [!tip] 对于模板类里的成员函数不是函数模板，在类模板实例化为具体类型的时候，成员函数也被实例化为具体。 可变参数类模板 形参包与包展开等知识，在类模板中是通用的。 template struct X { X(Args...args) :value{ args... } {} // 参数展开 std::tuplevalue; // 类型形参包展开 }; X x{ 1,\"2\",'3',4. }; // x 的类型是 X std::cout (x.value) [!warning] 需要注意的是字符串字面量的类型是 const char[N] ，之所以被推导为 const char* 在于数组之间不能“拷贝”。它隐式转换为了指向数组首地址的指针，类型自然也被推导为 const char*。 类模板分文件 类模板也没有办法分文件。 通常就是统一写到 .h 文件中，或者大家约定俗成了一个 .hpp 后缀，这个通常用来放模板。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 02_类模板 "},"docs/Cpp/Pre-knowledge/":{"url":"docs/Cpp/Pre-knowledge/","title":"Pre-knowledge","keywords":"","body":" Pre-knowledge 简短说明 Pre-knowledge 简短说明 本文件夹包含 C++ 入门前应知道的基础知识，从基础数据类型到指针和引用，然后是类和对象，最后依据面向对象编程，详细介绍类的关系和设计。内容以简单易懂为主，适合快速回顾。主要用于初学者进行学习和了解 章节列表与简短说明： 01_Element-knowledge：基础元素和类型的简单介绍（比如数字和文本如何表示）。 02_Pointer_and_Reference：讲指针和引用是什么，什么时候用它们。 03_Class_and_Object：介绍类和对象的概念，如何用它们组织数据和功能。 04_Default_Member_Function：说明类的默认函数会做什么（构造、赋值等）。 05_Conversion_and_Namespace：讲类型之间的简单转换和命名空间的作用（避免名字冲突）。 06_Inheritance_and_Virtual：说明继承和虚函数的基本想法，怎么扩展已有功能。 07_Polymorphism：用通俗例子解释多态：同一接口，不同实现。 08_Relationship_of_Class：讲类之间常见的关系（包含、继承、关联）。 09_Diamond_Inheritance：说明菱形继承问题以及如何避免重复继承的问题（用简单比喻）。 10_dynamic_cast：介绍在运行时安全转换类型的小技巧（什么时候需要检查类型）。 11_Expressions：常见表达式和运算的写法示例，帮助阅读代码时更快理解。 12_Singleton_Pattern：讲单例模式是什么，适合什么时候使用（并提醒注意缺点）。 13_static：解释 static 的简单含义（共享或静态存储）。 14_virtual：再次用非专业语言说明虚函数和虚继承的直观效果。 15_Miscellaneous：其他零散但实用的小知识和注意事项。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - Pre-knowledge "},"docs/Cpp/Pre-knowledge/01_Element-knowledge.html":{"url":"docs/Cpp/Pre-knowledge/01_Element-knowledge.html","title":"01_Element-knowledge","keywords":"","body":" 编程泛型(10个) 编程泛型和C++语言 集成开发环境(记住顺序) : C++项目(工程）的组成: 预处理 编译过程： 链接过程： 入口函数: 预备知识（第1–3章要点） 编程范式简述 C++ 项目基本组成 编译流程（高层） 程序入口 头文件、声明与定义 抽象数据类型（ADT） typedef / using 枚举（enum） 声明与定义（要点） 存储区与生命周期 作用域与链接性 包含（include）注意事项 其他要点 编程泛型(10个) 面向+对象, 方面, 表格+编程 过程+命令+函数+编程 流程+消息+驱动编程 泛型+结构化+编程 编程泛型和C++语言 一种编程范型可以被多种语言支持, 一种语言也可以支持多种编程范型. 集成开发环境(记住顺序) : 集成代码 编辑、编译、运行、调试、测试、发布等 C++项目(工程）的组成: 实现文件cpp, 头文件hpp, h 库文件, 可执行文件(dll, lib, exe), 资源文件(rc, res) 数据文件(XML, dat), 其他... 编译为: exe, dll, lib 预处理 处理源代码中的带有#号的语句，生成编译程序可处理的文本文件； 编译过程： 对每个预处理后源程序，编译并生成相应的二进制目标文件(object文件)。此过程中，仅要求编译器能够识别每个标识符，知道其各自的类型、含义，但不要求知道存放位置. 链接过程： 对在整个程序范围内，确定各标志符所代表的地址，如变量、函数入口(找到main函数)，生成可执行文件。此过程中，要求编译器能够确定每个标识符所对应的含义或地址。 [!NOTE] C++的编译是以实现文件(.cpp文件)为基本编译单位的； 预编译、编译和链接过程，有时我们统称编译过程； 各阶段均无错误，才能生成可执行文件； 即使生成了可执行文件，不代表程序就正确； 让编译过程通过，是相对简单的；真正困难的是调试逻辑错误 入口函数: 预备知识（第1–3章要点） 本文档提取常见的语言基础、构建流程和工程约定，作为快速参考：编译流程、项目组织、声明/定义、存储与作用域、typedef/枚举等。 编程范式简述 面向对象（OOP）：类/对象、继承、多态； 过程式：函数/模块为中心； 事件/消息驱动：以事件循环和回调为主； 泛型/模板编程：类型参数化，实现可复用的算法与容器； 一门语言可以支持多种范式，C++ 就是典型的多范式语言。 C++ 项目基本组成 源文件：.cpp/.c（实现） 头文件：.h/.hpp（声明与接口） 库：.lib/.a（静态），.dll/.so（动态） 可执行文件：.exe 等 资源/数据：图像、配置、XML/JSON 等 常见工具链：gcc/clang/MSVC + make / ninja / CMake 用于生成构建系统。 编译流程（高层） 预处理（Preprocessing）：处理 #include, #define 等，展开为单一翻译单元； 编译（Compilation）：将翻译单元编译为目标文件 .o/.obj； 链接（Linking）：将目标文件与库合并，解析符号，生成可执行文件或库。 要点：编译器在编译阶段只需知道符号的类型和声明，链接阶段负责把符号绑定到具体地址。 程序入口 标准可执行程序入口为： int main(int argc, char* argv[]) { // ... } （注意：不要依赖非标准的 void main()。） 头文件、声明与定义 头文件应放声明（函数原型、类定义、常量声明、模板实现可放头文件）； 头文件不应放非 inline 的函数定义或非 inline 的全局变量定义（否则会违反 ODR）； 使用 include guard 或 #pragma once 防止重复包含，但仍需避免在头中放置会导致多重定义的实体。 示例： // header.h void f(); // 声明 // source.cpp #include \"header.h\" void f() { /* 定义 */ } 抽象数据类型（ADT） ADT = 数据集合 + 对其施加的操作。类是实现 ADT 的常见方式。 typedef / using typedef 与 using（C++11）用于创建类型别名： typedef int (*FuncPtr)(int,int); using FuncPtr2 = int(*)(int,int); int add(int a, int b){ return a+b; } FuncPtr f = add; // 调用 f(1,2) using 在模板别名时更表达性强，推荐在新代码中使用 using。 枚举（enum） C++98: enum E { A, B, C };（枚举值与整数可互转，可能导致命名污染）； C++11: enum class E : int { A, B, C };（强类型、作用域内名字、推荐使用）。 示例： enum class Day : int { Monday=1, Tuesday, Wednesday }; Day d = Day::Monday; int v = static_cast(d); 声明与定义（要点） 声明（declaration）：告诉编译器符号的类型与接口； 定义（definition）：为符号分配存储或提供实现（函数体、非-inline 变量等）。 遵循“先声明后使用”和“一处定义，多处声明”的原则。 存储区与生命周期 常见区域： 全局/静态区（static storage）：程序启动时分配，结束时释放； 常量区：只读常量等； 代码区：程序指令； 栈（自动存储）：局部变量，随函数调用创建/销毁； 堆：动态分配，程序员管理（new / delete 或智能指针）。 作用域与链接性 文件作用域（static 修饰的全局）：仅在该翻译单元可见； 外部链接（extern）：符号可在多个翻译单元间共享； 局部作用域：块作用域、函数作用域、类作用域等。 示例（extern）： // a.cpp int a = 10; // 定义 // b.cpp extern int a; // 声明 包含（include）注意事项 头文件中避免 using namespace std;，避免把名字污染到所有包含者； 将实现（非 inline）放入 .cpp，在头中放声明； #pragma once 与 include guard 都是防重复包含的手段，但不能掩盖头文件设计上的多重定义问题。 示例：错误的头文件（会导致链接错误）不应包含非-inline 函数定义。 其他要点 C++ 是编译型语言：代码需先编译为目标文件再链接生成可执行文件； Build 工具（Make/CMake/Ninja）能大幅提升构建效率并管理依赖关系； 如果你确认，我会现在读取并重写你当前打开的 chapter19-20.md（按目录顺序继续），生成更清晰的章节并保留图片引用。 } ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 01_Element-knowledge "},"docs/Cpp/Pre-knowledge/02_Pointer_and_Reference.html":{"url":"docs/Cpp/Pre-knowledge/02_Pointer_and_Reference.html","title":"02_Pointer_and_Reference","keywords":"","body":" 指针, 数组, 引用, 常量 1 指针（Pointer） 2 数组（Array） 3 引用（Reference） 4 常量与枚举 5 宏（#define）优缺点 6 数据对齐与对象大小 7 链接性（Linkage）与可见性 8 函数声明与定义（声明优先） 9 异常、默认参数与调用约定（简要） 调用协定 cdecl(调用者) stdcall fastcall 名字重整 函数重载(奥里给) 重载函数绑定 参数表 实参和形参的匹配 缺省参数： 转换： 数组传递 引用传递 返回类型 值/指针 函数link数组 步骤 1: 基本语法结构 步骤 2: 分解和重组 更具体的解释 视觉化理解 小结 指针, 数组, 引用, 常量 1 指针（Pointer） 定义形式：Type* name [= expr]; 推荐在定义时初始化。 初始化约束与常见规则： 可初始化为 nullptr（C++11 起）、0 或 NULL（旧写法）； 可初始化为对象地址（类型必须兼容）； 指针可被赋值为另一个同类型指针（前提是已初始化）。 示例： int a = 10; int* p = &a; // 指向 a int* n = nullptr; // 空指针 指针运算：p + n 会按照 sizeof(*p) 移动地址；*(p + i) 等价于 p[i]。注意运算优先级：*(p+n) != *p + n。 不要解引用无效或越界指针（UB）。 2 数组（Array） 一维数组与指针：数组名在大多数表达式中会退化为指向首元素的指针，但数组本身不是指针，大小信息会丢失。 int a[5] = {1,2,3,4,5}; int* p = a; // 等价于 &a[0] std::cout 多维数组：int a[3][4]; 在表达式中退化为 int (*)[4]（指向含 4 个 int 的数组的指针）。 指针数组与数组指针： 指针数组：int* arr[5];（数组元素是指针）； 数组指针：int (*p)[5];（p 指向一个含 5 个 int 的数组）。 数组引用示例（避免拷贝）： void g(int (&ra)[20]) { /* 直接访问原数组 */ } 注意：字符串字面量以 \\0 结尾，定义 char s[5] = \"hello\"; 会越界。 下面将用简洁的示例说明一维数组与多维数组（尤其是二维数组）的常见用法、指针关系和范围遍历。 示例：遍历二维数组的几种写法并说明指针含义 #include using namespace std; // 使用类型别名表示指向包含 4 个 int 的数组的指针 using int_row = int[4]; void example_pointer_iteration() { int a[3][4] = { {1,2,3,4}, {5,6,7,8}, {9,10,11,12} }; // 方式 1：使用显式指针遍历（int_row* 指向每一行） for (int_row *p = a; p != a + 3; ++p) { for (int *q = *p; q != *p + 4; ++q) cout 要点总结： 对二维数组 int a[3][4]，表达式 a 的类型是 int[3][4]，在大多数表达式中会退化为 int (*)[4]（指向含 4 个 int 的数组的指针）。 a + 1 指向第二行；*(a + 1) 的类型是 int[4]，在表达式中又可退化为 int* 指向该行第一个元素。 数组名在多数表达式中会退化为指针，但在 sizeof、取地址 &、以及作为初始值的数组拷贝（constexpr 情况除外）时不退化。 示例：一维数组与“超尾”元素 int arr[4] = {1,2,3,4}; int *p = arr; // 指向 arr[0] int *q = arr + 4; // 指向“超尾”位置 &arr[4]，不能解引用，但用于范围判断是合法的 3 引用（Reference） 引用是已初始化的别名，语法为 T& r = obj;。引用必须在定义时初始化，初始化后不能重新绑定。引用不能为“空引用”。 引用与指针的主要区别： 引用更像别名，使用更安全（不可为 null、不可变绑定）； 指针可为空、可重新赋值，适合遍历数据结构与可选引用场合。 示例： int x = 1; int &r = x; r = 2; // x == 2 4 常量与枚举 使用 const 声明常量：const int N = 10;；在文件作用域下非 extern 的 const 默认为内部链接（每个翻译单元一个拷贝）；要跨文件共享请使用 extern const 或 inline const（C++17）。 枚举：enum Color { RED, GREEN, BLUE };。 枚举类（scoped enum）：enum class Color { RED, GREEN };，更安全且不导出名字到外部作用域。 常量折叠：编译器会在编译期计算常量表达式并进行折叠优化，但 const 变量与宏不同，前者仍是语言符号可被类型系统识别。 5 宏（#define）优缺点 缺点： 只是文本替换、无类型检查； 调试困难、易引入命名冲突； 优点： 条件编译、编译期替换与编译器内置宏（如 __FILE__、__LINE__）对调试有用。 示例（条件编译）： #define DEBUG #ifdef DEBUG // debug code #endif 优先使用 constexpr、const、inline 常量与模板替代宏。 6 数据对齐与对象大小 结构体/类成员会按对齐规则排列，编译器可能插入填充字节以满足对齐要求。对象大小受成员类型、对齐以及是否有虚函数（vptr）影响。空类大小至少为 1 字节。 7 链接性（Linkage）与可见性 内部链接（internal linkage）：标识符仅在当前翻译单元可见，例如 static 自由函数或命名空间中未显式 extern 的 const 对象（老规则）； 外部链接（external linkage）：标识符可跨翻译单元链接，如普通非 inline 函数与非静态全局变量（定义唯一）。 注意：C++17 引入 inline 变量允许在头文件中定义全局变量而不违反 ODR（One Definition Rule）。 8 函数声明与定义（声明优先） 函数应在使用前声明（通常放在头文件），在实现文件定义； 声明与定义可以分离，链接时将把声明绑定到唯一的定义； inline 函数允许在多个翻译单元中定义相同实现（用于头文件）。 示例： // header.h void f(); // source.cpp #include \"header.h\" void f(){ /* ... */ } 9 异常、默认参数与调用约定（简要） 异常处理为语言级机制，异常传播会进行栈展开并调用析构函数； 默认参数在编译期决定，不能作为函数重载的区分条件； 调用约定（ABI）决定参数压栈和清栈方是谁，平台相关，通常由编译器控制。 如果你同意，我将按目录顺序继续处理下一个文件 oop6-7.md（若还未处理则按顺序跳过已处理文件）。 同一个项目中的函数名字表示，限定名不同即可区分；不同项目中的函数名字表示，需要区分； 调用协定 这种协议规定了该语言函数调用时的参数传送方式、参数是否可变和由谁来处理堆栈等问题. 约定有cdecl、stdcall、fastcall、pascal、thiscall等几种 cdecl(调用者) 函数参数按照从右到左的顺序入栈，并且由调用函数者负责把参数弹出栈以清理堆栈 stdcall 函数参数按照从右到左的顺序入栈，没有显式定义非成员函数的调用约定, 并且由被调用的函数负责在返回前清理传送参数的栈，函数参数个数固定 fastcall 用于对性能要求非常高的场合, 通常将函数的从左边开始的两个大小不大于4个字节的参数通过寄存器传递，其余的参数仍旧自右向左压栈传递，并且由被调用的函数负责在返回前清理传送参数的堆栈。 名字重整 编译器通常会在生成源程序的目标文件阶段，将其中具有存储性质的对象的名字按照某种既定规则进行改写 所谓的具有存储性质的对象，即左值对象 函数重载(奥里给) [!tip] 兼容性原则: 只要有一个变量可以使之重载, 便是合法重载. 重载函数不会满足所有变量的情况. [!warning] 函数参数的个数、类型、顺序、const修饰、异常等不完全相同 返回值类型不作为区分标志 缺省参数不作为区分标志 值类型参数的const型与非const型不作为区分标志 引用和指针类型参数，是否可以改变实参，可作为区分标志 根据操作数的类型来区分不同的操作，并应用适当的操作，是编译器的责任，而不是程序员的事情. 通过省去为函数起名并记住函数名字的麻烦，函数重载简化了程序的实现，使程序更容易理解 int Func(); int Func(int); int Func(int,int); int Func(int,int) const; //只能是成员函数 int Func(int) throw( ); int Func(int) throw(int,MyE,YourE); int Func(MyClass obj); 函数重载和作用域 重载函数应在同一个作用域中声明。如果局部地声明一个函数，则该函数将屏蔽而不是重载在外层作用域中声明的同名函数 例: void print( const string& ); void print( double ); //重载 void foobar( int i ) { extern void print(int); //隐藏print() or int print=0; print(“Value”); //错误 print(i); //正确 } 重载函数绑定 [!note] 确定候选函数、选择可行函数、寻找最佳匹配. 例: void f(); void f(int); void f(int, int); void f(double, double = 3.14); f(5.6); // calls void f(double, double) f(42, 2.56); // error f(static_cast(42), 2.56); // calls f(double, double) f(42, static_cast(2.56)); // calls f(int, int) 参数表 函数的缺省参数既可以在函数声明也可以在函数定义中指定默认实参。但是，在一个文件中，只能为形参指定默认实参一次. [!tip] 应在函数声明中指定默认实参，并将该声明放在合适的头文件中。如果在函数定义的形参表中提供默认实参，那么只有在包含该函数定义的源文件中调用该函数时，默认实参才是有效的. 如果一个函数被声明多次并出现在不同的作用域内，则允许分别为它们指定不同的默认实参. int f(int a=6,float b=5.0,char c='.',int d=10); int main( ) { int f(int a=3,float b=2.0,char c='n',int d=20); cout 实参和形参的匹配 [!note] 压栈顺序由调用约定确定 但计算顺序是不确定的 错误的例子 int a =10; f(++a,++a,++a); func( MyF(a),YourF(a)+6 ); 当一个函数有多个形参时，C++语言没有规定函数调用时实参的求值顺序，编译器根据对代码进行优化的需要自行规定对实参的求值顺序 在实参中注意不要使用带有副作用的运算符，此时可能产生二义性. [!note] 缺省参数的匹配 实参的类型转换 缺省参数： 在编译时匹配，而不是运行时； 第一个带缺省值参数的右侧必须都有缺省值； void f(int,char=‘c’,int); //非法 void f(int,char=‘c’,int=9);//正确 转换： 若不存在完全匹配的函数，尝试类型转换（每个参数只一次）。 void f(int); void f(double); 实际调用：f(2.5f); [!note] 值传递 指针传递 数组的传递 引用传递 数组传递 可将使用数组语法定义的形参看作指向数组元素类型的指针。上面的几种定义是等价的，形参类型都是 int* int a[3]={1,2,3}; 编译器只会检查实参是不是指针、指针的类型和数组元素的类型是否匹配，而不会检查数组的长度 以下几个等价: void f(int[ ]); void f(int a[ ]); void f(int a[3]); void f(int a[5]); void f(int * a); //二维 void fun(int array[5][10]); //第一维的大小通常省略 void fun(int array[][10], int i); //fun(int array[][]);是错误的 仅能省略第一维 void fun(int (*array)[10], int i); void fun(int *array[5], int j); void fun(int *array[], int i, int j); void fun(int **array, int i, int j); 引用传递 引用对实参的要求 [!caution] 不允许传递一个右值或具有需要转换的类型的对象(类型不匹配的对象) 非const 引用形参只能与完全同类型的非const 对象关联 应该传入一个有效的对象 [!tip] 为避免限制对函数的使用，应该将不修改相应实参的形参定义为 const 引用 返回类型 值/指针 返回引用的函数返回一个左值。因此，这样的函数可用于任何要求使用左值的地方. 函数link数组 理解 int * (*T[5])(void); 这种复杂的C++声明需要一步步分析。我们可以从内到外逐层解读每个部分的含义。为了更清晰地解释，我们可以遵循以下步骤： 步骤 1: 基本语法结构 从最内层开始，逐步解释并扩展： T[5]: 这是一个数组声明。T 是一个包含 5 个元素的数组。 (*T[5]): 这表明数组 T 中的每个元素是一个指针。 (*T[5])(void): 进一步表明，T 中每个指针指向的是一个函数，该函数没有参数（void 表示函数没有参数）。 int * (*T[5])(void): 最外层表明，这些函数返回一个 int 类型的指针。 步骤 2: 分解和重组 让我们从里到外一步步解析 int * (*T[5])(void);： T[5]: 声明 T 是一个包含 5 个元素的数组。 *T[5]: 数组中的每个元素是一个指针。 (*T[5])(void): 每个指针指向一个接受 void 参数的函数。 int * (*T[5])(void): 每个函数返回一个指向 int 类型的指针。 因此，int * (*T[5])(void); 声明了一个包含 5 个元素的数组 T，其中每个元素是一个指向函数的指针，这些函数不接受参数并返回一个指向 int 的指针。 更具体的解释 为了更好地理解这种声明，可以考虑以下具体的例子： int* func1(void) { static int x = 10; return &x; } int* func2(void) { static int y = 20; return &y; } int* func3(void) { static int z = 30; return &z; } int* func4(void) { static int w = 40; return &w; } int* func5(void) { static int v = 50; return &v; } int* (*T[5])(void) = { func1, func2, func3, func4, func5 }; int main() { for (int i = 0; i 在这个例子中： 定义了5个函数 func1 到 func5，每个函数返回一个指向 int 的指针。 声明了一个数组 T，并将这5个函数的地址赋给数组 T 的每个元素。 在 main 函数中，通过调用 T 中的每个函数，打印返回的 int 值。 视觉化理解 如果用图表来表示 int * (*T[5])(void); 的结构，它可以如下图所示： T: +-----------+ +-----------+ +-----------+ +-----------+ +-----------+ | T[0] | | T[1] | | T[2] | | T[3] | | T[4] | | function* | | function* | | function* | | function* | | function* | +-----|-----+ +-----|-----+ +-----|-----+ +-----|-----+ +-----|-----+ | | | | | v v v v v +---|---+ +---|---+ +---|---+ +---|---+ +---|---+ | func1 | | func2 | | func3 | | func4 | | func5 | +---|---+ +---|---+ +---|---+ +---|---+ +---|---+ | | | | | v v v v v +---|---+ +---|---+ +---|---+ +---|---+ +---|---+ | int* | | int* | | int* | | int* | | int* | +-------+ +-------+ +-------+ +-------+ +-------+ 小结 T 是一个指针数组：T 是一个包含 5 个元素的数组。 每个元素是一个函数指针：数组中的每个元素是一个指向函数的指针。 这些函数无参数并返回 int 指针：每个函数都不接受参数，并返回一个指向 int 类型的指针。 理解这些复杂的声明，需要分解每个部分，逐步解析和组合，才能彻底理解其含义。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 02_Pointer_and_Reference "},"docs/Cpp/Pre-knowledge/03_Class_and_Object.html":{"url":"docs/Cpp/Pre-knowledge/03_Class_and_Object.html","title":"03_Class_and_Object","keywords":"","body":" 类和对象 类和对象 1. ADT 与类的组成 2. this 指针 3. 类的定义与组织 4. 成员与对象访问 5. 对象的存储大小与对齐 6. 成员函数：外联实现与内联实现 7. 封装与信息隐藏 8. 常量成员函数与 this 的类型 9. 静态成员（类变量与类方法） 10. 小结 类和对象 本节整理类与对象的核心概念：ADT（抽象数据类型）、this 指针、成员与访问方式、对象内存布局、成员函数的外联/内联实现、封装与静态成员等。 1. ADT 与类的组成 抽象数据类型（ADT）：由数据和对数据的操作组成（数据成员 + 成员函数）。 类是 ADT 在 C++ 中的表现形式，包含数据成员和成员函数（行为）。 示例： class Counter { int value{}; public: void inc() { ++value; } int get() const { return value; } }; 2. this 指针 在非静态成员函数内部，this 指向当前对象（类型为 T* const 或 const T* const 于 const 成员函数）。 this 不能用于静态成员函数。 示例： struct S { int x; void set(int v){ this->x = v; } }; 3. 类的定义与组织 类通常放在头文件（.h/.hpp），成员函数实现放在源文件（.cpp），可以使用前置声明（forward declaration）降低编译依赖。` 使用 #pragma once 或 include guard 防止重复包含。 示例： // foo.h #pragma once class Bar; class Foo { Bar* b; public: void f(); }; 4. 成员与对象访问 数据成员：普通类型、数组、指针、引用、其它类类型； 成员函数可以通过对象、指针或引用调用： obj.f(), p->f(), r.f()。 面向对象编程强调通过接口（方法）与对象交互，具体实现由对象本身决定（多态时行为在运行时可能不同）。 5. 对象的存储大小与对齐 对象大小受非静态数据成员的类型与顺序、对齐规则、以及是否含虚函数（通常添加 vptr）影响； 成员函数、静态成员与访问控制不会改变对象实例大小； 空类至少占 1 字节以保证不同对象有不同地址。 对齐规则（概念性）：成员按其对齐要求放置，结构整体大小对齐到最大成员的对齐值。不同编译器/平台可能差异，需以 sizeof 和编译器文档为准。 6. 成员函数：外联实现与内联实现 外联实现：在类外定义成员函数（通常放在 .cpp），有外部链接。优点：隐藏实现、减少头文件体积； 内联实现：在类体内定义或用 inline 指定，允许编译器在调用处展开代码（仅建议用于小函数或模板）。 示例： // 外联 // foo.h class Foo{ public: void f(); }; // foo.cpp // void Foo::f(){ /* ... */ } // 内联（可放在头文件） class Small{ public: int id() const { return 42; } }; 注意：C++ 中 inline 更重要的语义是允许跨编译单元多重定义（只要定义相同），而非强制内联展开。 7. 封装与信息隐藏 封装（encapsulation）：将数据与操作打包为整体，降低外部依赖； 信息隐藏（information hiding）：通过 public/protected/private 控制可见性，尽量暴露稳定接口，隐藏实现细节以降低耦合。 设计建议：使用最小可见性原则（最少公开），通过接口隔离实现细节；对跨模块接口，暴露稳定、简单的函数签名。 8. 常量成员函数与 this 的类型 常成员函数（T::f() const）中，this 的类型为 const T* const；因此只能调用其它 const 函数或访问可变成员。 示例： struct R{ int get() const { return 0; } }; 9. 静态成员（类变量与类方法） 静态数据成员属于类本身，所有实例共享；非内联静态成员需在类外定义并初始化（C++17 起可用 inline static 在类内初始化）； 静态成员函数没有 this，不能直接访问非静态成员。 示例： struct C{ static int cnt; static void inc(){ ++cnt; } }; int C::cnt = 0; 10. 小结 通过前置声明与把实现放入源文件可以降低编译耦合； 使用初始化列表、const 成员函数以及合适的访问控制能提高类型的鲁棒性； 明确静态/非静态语义，优先使用智能指针与 RAII 管理资源。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 03_Class_and_Object "},"docs/Cpp/Pre-knowledge/04_Default_Member_Function.html":{"url":"docs/Cpp/Pre-knowledge/04_Default_Member_Function.html","title":"04_Default_Member_Function","keywords":"","body":" 类的默认成员函数 1 构造函数（构造与初始化） 默认构造、=default 与 =delete 初始化列表（member initializer list） 2 析构函数 3 拷贝构造与赋值 所有权转移（移动语义）简介 4 规则三/五/零（Rule of Three/Five/Zero） 5 小结与建议 类的默认成员函数 本章总结构造与析构的规则、初始化列表、拷贝构造/赋值、以及何时需要自定义这些特殊函数。示例采用现代 C++ 风格并给出建议。 1 构造函数（构造与初始化） 构造函数用于对象创建时初始化成员。构造函数特点：同名于类，无返回值，为非静态成员函数，可声明为 explicit 防止隐式转换。 要点： 可以重载多个构造函数； 可以设置访问控制（public/private）以实现模式如单例； 若没有用户自定义构造函数，编译器会生成默认构造函数（默认构造）； C++11 提供 =default 和 =delete 用于显式控制特殊成员函数的生成。 示例：Meyers 单例（线程安全，自 C++11 起局部静态变量初始化是线程安全的） #include class Singleton { public: static Singleton& instance() { static Singleton inst; // 局部静态，延迟初始化且线程安全（C++11+） return inst; } int value() const { return v; } private: Singleton() : v(42) {} ~Singleton() = default; Singleton(const Singleton&) = delete; Singleton& operator=(const Singleton&) = delete; int v; }; int main(){ auto &s = Singleton::instance(); std::cout 默认构造、=default 与 =delete 如果类没有任何用户声明的构造函数，编译器会生成默认构造函数。使用 =default 可显式要求编译器生成默认实现；使用 =delete 可禁止生成或使用某个特殊函数（例如禁止拷贝）。 struct A { A() = default; A(int)=delete; }; 初始化列表（member initializer list） 常量成员 (const)、引用成员、以及没有默认构造函数的成员对象必须在初始化列表中初始化； 成员按声明顺序初始化，与列表顺序无关（以定义顺序为准），因此应按声明顺序写初始化列表以避免混淆； 初始化列表可以避免先默认构造再赋值的开销。 示例： struct S { const int k; std::string &r; S(int v, std::string &s): k(v), r(s) {} }; 2 析构函数 析构函数用于对象销毁时释放资源：析构函数应为 virtual 当且仅当类将被作为基类并通过基类指针删除派生对象。 要点： 析构函数没有返回值，不能被声明为 static； 如果基类有虚函数，通常应声明虚析构 virtual ~Base()； 自动变量（栈上对象）析构由语言自动管理；堆上对象需 delete 来释放并调用析构函数。 3 拷贝构造与赋值 拷贝构造（copy ctor）用于“从无到有”创建新对象；拷贝赋值（operator=）用于已有对象间的赋值。编译器在未声明时会生成默认的拷贝构造与拷贝赋值，执行成员逐个拷贝（浅拷贝行为）。 签名示例： T(const T& other); // 拷贝构造 T& operator=(const T&); // 拷贝赋值 何时需要自定义： 管理资源（裸指针、文件句柄、网络句柄等）时需要深拷贝或移动语义； 需要禁止拷贝时使用 =delete； 示例：深拷贝 struct Buffer { Buffer(size_t n): n(n), data(new int[n]){} Buffer(const Buffer& o): n(o.n), data(new int[o.n]){ std::copy(o.data, o.data+o.n, data); } Buffer& operator=(const Buffer& o){ if(this==&o) return *this; delete[] data; n = o.n; data = new int[n]; std::copy(o.data, o.data+o.n, data); return *this; } ~Buffer(){ delete[] data; } private: size_t n; int* data; }; 所有权转移（移动语义）简介 现代 C++ 提倡实现移动构造与移动赋值以高效转移资源： Buffer(Buffer&& o) noexcept : n(o.n), data(o.data){ o.n=0; o.data=nullptr; } Buffer& operator=(Buffer&& o) noexcept { if(this!=&o){ delete[] data; n=o.n; data=o.data; o.n=0; o.data=nullptr;} return *this; } 4 规则三/五/零（Rule of Three/Five/Zero） 如果需要自定义拷贝构造、拷贝赋值或析构函数，通常需要同时自定义三者（Rule of Three）； 在引入移动语义后，扩展为 Rule of Five（拷贝/移动 构造与赋值 + 析构）； 如果类不管理资源，尽量遵循 Rule of Zero，依赖编译器生成的特殊函数与 RAII 类型。 5 小结与建议 尽量使用初始化列表初始化成员，按声明顺序书写； 使用 =default/=delete 明确意图； 管理资源时优先使用智能指针（unique_ptr/shared_ptr），避免手动管理裸指针； 若类管理资源，考虑实现移动构造与移动赋值以提高性能； 对单例使用局部静态（Meyers 单例）并禁止拷贝。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 04_Default_Member_Function "},"docs/Cpp/Pre-knowledge/05_Conversion_and_Namespace.html":{"url":"docs/Cpp/Pre-knowledge/05_Conversion_and_Namespace.html","title":"05_Conversion_and_Namespace","keywords":"","body":" 转换、名字空间、友元与嵌套类 转换、名字空间、友元与嵌套类 1 转换函数（Conversion） 2 名字空间（namespace） 3 嵌套类（Nested classes） 4 友元（friend） 5 简短笔记：第13、14 章 转换、名字空间、友元与嵌套类 本章摘取常用要点并给出安全的示例，重点在于可读性与现代 C++ 的建议用法（C++11 及以后）。 1 转换函数（Conversion） 1) 内置 -> 自定义：通过构造函数实现。 struct A { explicit A(int x) : a(x) {} // 推荐 explicit 避免不必要的隐式转换 int a; }; // 显式构造 int main() { A a1{42}; // 直接列表初始化 // A a2 = 42; // 若构造函数不是 explicit，则允许隐式转换 } 2) 自定义 -> 内置 或 自定义 -> 自定义：通过 operator T() 定义。推荐： 标注为 explicit（C++11）以防止意外的隐式转换； 对于不会修改对象状态的操作，声明为 const； 避免模糊/二义性的多重转换。 示例： struct B { B(int v = 0) : v(v) {} explicit operator int() const { return v; } // 需要显式转换 explicit operator std::string() const { return std::to_string(v); } private: int v; }; int main() { B b(7); int x = static_cast(b); // OK // int y = b; // 错误（explicit） std::string s = static_cast(b); } 示例：类型间转换（类到类） struct A { A(int, std::string) {} }; struct C { operator A() const { return A(1, \"ok\"); } // 将 C 转换为 A }; void f(A){ } int main(){ C c; f(c); /* 隐式可行，若不希望隐式转换请加 explicit */ } 注意：若定义多个转换函数可能引起二义性，尽量只提供必要的转换，并 prefer explicit。 2 名字空间（namespace） 命名空间用于组织符号并避免命名冲突。常见用法：嵌套命名空间、别名、匿名命名空间。 namespace lib { namespace detail { void impl() {} }} namespace ld = lib::detail; // 别名 int main(){ ld::impl(); } 匿名命名空间等价于将符号限定为当前翻译单元的内部链接（比 static 更现代）： // 在 my.h 中不要放匿名命名空间（会导致每个包含者有不同实体） using 声明与 using 指令： using std::string;（把单个名字引入）更安全； using namespace std;（把整个命名空间引入）在头文件中应避免，以免污染所有包含者。 示例（using 的坑）：若两个命名空间都有同名符号，using namespace 会导致二义性。 3 嵌套类（Nested classes） 嵌套类的访问权限遵循 C++ 的成员访问规则：嵌套类本身的可见性依赖于声明位置。 struct Outer { struct PublicInner { int v; }; private: struct PrivateInner { int v; }; }; int main() { Outer::PublicInner pi{42}; // Outer::PrivateInner x; // 错误：PrivateInner 对外不可见 } 嵌套类并不是自动成为外层类的成员函数或友元；需要显式声明。 4 友元（friend） 友元可以是自由函数、类的成员函数或整个类。友元使其能够访问类的私有/受保护成员。 要点： 友元声明不改变被声明实体的位置或所有权； 友元关系是单向且不传递； 友元应谨慎使用——它破坏封装，但在需要测试或紧密耦合实现时很实用。 示例： class Box { int secret = 42; friend int get_secret(const Box& b); // 自由函数成为友元 }; int get_secret(const Box& b) { return b.secret; } class Owner { friend class Inspector; // Inspector 的所有成员都是 Box 的友元 }; 注意：友元声明常放在类定义内部，若友元为函数，需要在使用前确保名称已声明或前向声明。 5 简短笔记：第13、14 章 chapter13（类间关系）：通常讨论组合/聚合/依赖/关联与生命周期管理，常配合 smart pointer 讨论所有权； chapter14（类的设计）：关注接口与实现分离、构造/析构语义、拷贝/移动与异常安全、最小暴露原则等。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 05_Conversion_and_Namespace "},"docs/Cpp/Pre-knowledge/06_Inheritance_and_Virtual.html":{"url":"docs/Cpp/Pre-knowledge/06_Inheritance_and_Virtual.html","title":"06_Inheritance_and_Virtual","keywords":"","body":" 继承、类型转换与虚基类 继承、类型转换与虚基类 15 继承（Inheritance） 派生类的成员集合 构造与析构顺序 成员函数的覆盖与隐藏 对象切片（Object slicing） 16 类型转换与 C++ 四大 cast 17 虚基类（Virtual inheritance）与多重继承要点 继承、类型转换与虚基类 下文将继承相关概念按主题整理：继承语义、派生成员、构造/析构顺序、对象切片、类型转换操作符（四大 cast）以及虚基类的要点。保留原图示位置供参考。 15 继承（Inheritance） 目的：代码/行为复用与多态。常见对比： 黑盒复用（组合/聚合/依赖）：通过接口使用其他类，而不依赖其内部实现； 白盒复用（继承）：子类可访问基类受保护成员并扩展/重用实现。 总体建议：优先使用组合（has-a），仅当存在 true 的 is-a 关系并需要多态行为时才使用公有继承（public）。 派生类的成员集合 派生类包含： 派生类自己定义的成员（函数/数据）； 从基类继承的成员（除构造、析构、拷贝/赋值函数外），其中访问性受 public/protected/private 控制； 基类静态成员在继承层次间只有一份实例。 构造与析构顺序 构造顺序：先构造基类子对象（按继承声明顺序），再构造派生类成员，最后派生类本体； 析构顺序：与构造相反，先派生类析构，再基类析构。 示例：基类成员应通过初始化列表由基类构造函数初始化，而不是在派生构造体内赋值。 struct Base { Base(int v):v(v){} int v; }; struct Derived : Base { Derived(): Base(42) {} }; 成员函数的覆盖与隐藏 隐藏（name hiding）：派生类定义与基类同名但不同参数列表的函数，会隐藏基类同名所有重载；可用 using Base::f; 将基类重载引入派生类作用域。 覆盖（override）：当基类函数为 virtual，派生类实现相同签名即为覆盖，推荐在 C++11 之后使用 override 关键字以获得编译器检查。 示例： struct B { virtual void f() {} }; struct D : B { void f() override {} }; // 推荐 对象切片（Object slicing） 当把派生类对象赋值/拷贝到基类对象时，派生部分被裁剪（slicing）。因此应尽量通过指针或引用传递基类类型以保留多态性。 struct Base { int b; virtual ~Base()=default; }; struct Derived : Base { int d; }; Derived dd; Base b = dd; // slicing：b 不含 d 16 类型转换与 C++ 四大 cast 常用转换运算符：static_cast、const_cast、reinterpret_cast、dynamic_cast。选择合适的 cast 能提高可读性并限制错误。 static_cast(e)：编译期转换（隐式/显式转换的显式写法），用于上下行转换（在安全可控情形）。 const_cast(e)：用于移除或添加 const/volatile 修饰，仅用于调整限定符，不改变对象实际类型。 reinterpret_cast(e)：低级别的重新解释，通常用于与底层/平台相关代码（指针整数等），应谨慎使用。 dynamic_cast(e)：运行时安全的下行转换（基类指针/引用 -> 派生类指针/引用），要求基类具有多态（至少一个虚函数），失败时指针返回 nullptr，引用抛出 std::bad_cast。 示例：安全的向上与向下转换 struct Base { virtual ~Base() = default; }; struct Derived : Base { void only_in_d() {} }; Base* up = new Derived(); // 向上转换（安全） Derived* down = dynamic_cast(up); // 向下转换（运行时检查） if(down) down->only_in_d(); delete up; 注意：对象型（按值）转换会触发裁剪或调用转换构造，通常不建议用于多态传递。 17 虚基类（Virtual inheritance）与多重继承要点 多重继承允许类同时继承自多个基类。问题示例：菱形（diamond）继承会产生重复的虚基子对象，需要虚继承（virtual）解决共享基类实例的问题。 缺点与权衡： 虚继承增加对象模型复杂性与运行时开销（可能需要额外指针/偏移来定位共享基子对象）； 使基类设计需要提前考虑是否用于多重继承； 编译器实现细节（对象布局）平台相关。 替代策略（当多重继承过于昂贵或复杂时）： 限定只使用单继承并通过组合实现多态行为； 使用接口类（纯虚基类，只有虚函数、无数据）与组合组合实现类似效果，避免数据冲突。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 06_Inheritance_and_Virtual "},"docs/Cpp/Pre-knowledge/07_Polymorphism.html":{"url":"docs/Cpp/Pre-knowledge/07_Polymorphism.html","title":"07_Polymorphism","keywords":"","body":" 多态性与虚函数 一、什么是多态 二、静态多态示例 三、动态多态（虚函数） 四、子类型化与接口设计 五、示例场景：接口与实现分离 六、虚拟拷贝（克隆）与限制 七、使用继承与虚机制的注意事项与不足 多态性与虚函数 本章汇总“多态”相关概念、在 C++ 中的实现方式与使用注意点，并给出可编译的示例与设计建议。 一、什么是多态 多态（polymorphism）指相同的接口调用在不同类型的对象上产生不同行为的能力。常见分类：静态多态与动态多态。 简要区分： 静态多态（compile-time polymorphism）：由模板或函数重载实现，调用的具体代码在编译期决定。常见形式：模板实例化、函数重载、内联等。 动态多态（run-time polymorphism）：通过基类指针/引用和虚函数实现，运行时决定调用哪一个覆盖了的实现。 二、静态多态示例 1) 模板（template） #include #include template class My { public: void f(const T &x) { std::cout m1; My m2; m1.f(10); // 输出 int（实现由编译器为 My 生成） m2.f(20.0f); // 输出 float } 2) 函数重载（示例略：原则是根据参数的静态类型在编译期选择重载） 说明：静态多态在运行时没有虚表开销，但缺乏运行时类型灵活性。 三、动态多态（虚函数） 动态多态依赖虚函数表（vtable）来在运行时选择合适的函数实现。重要规则： 重载解析（overload resolution）在编译期进行，基于表达式的静态类型和参数的静态类型； 一旦选择了某个虚函数签名，虚调用会在运行时根据对象的动态类型进行分派。 下面给出一个常用的示例，展示重载解析与虚调度如何配合工作： #include using namespace std; class B; // 前向声明 class A { public: virtual ~A() {} virtual void f(A*) { cout f(&b); // 编译期选择 A::f(B*)（因为参数是 B*），运行期分派到 B::f(B*) -> 输出 4 pa->f(pa); // 编译期选择 A::f(A*)，运行期分派到 B::f(A*) -> 输出 3 b.f(pa); // 对象是 B，且表达式的静态类型为 B，编译期选择 B::f(A*) -> 输出 3 } 要点回顾： 重载解析使用表达式的静态类型（例如 pa 是 A*），因此决定了将调用哪个重载签名；随后再做虚调度（dynamic dispatch）以选择派生类的实现。 C++ 默认只做单分派（single dispatch）：虚函数基于调用对象的动态类型进行分派，但参数的动态类型不参与重载选择。如果需要基于参数动态类型（双重分派），常用的解决方案包括 Visitor 模式 或 显式的动态类型检测（dynamic_cast）。 四、子类型化与接口设计 通过基类指针/引用访问派生类实现是一种常见模式，示例： Parent *p = new Child1; p->Func(); delete p; // 基类析构函数应为虚析构，以避免资源泄露 Child2 myObj; Parent &obj = myObj; obj.Func(); void Proc(Parent *p) { p->Func(); } 设计建议： 基类若存在多态删除（delete p），必须声明 virtual ~Parent()； 将接口（抽象行为）放在基类，把具体实现放在派生类，保持对客户端的透明。 五、示例场景：接口与实现分离 示例（更安全的设计：使用虚函数或抽象基类）： class Fruit { public: virtual ~Fruit() = default; virtual int Energy() const = 0; // 抽象接口 }; class Apple : public Fruit { int m_energy; public: Apple(int e): m_energy(e) {} int Energy() const override { return m_energy; } }; class Mouse { int weight = 0; public: void eat(const Fruit &fruit) { weight += static_cast(fruit.Energy() * 0.15); } }; 六、虚拟拷贝（克隆）与限制 C++ 中拷贝构造函数不能是虚的；若需要从基类指针复制得到派生类的完整对象，常用做法是定义虚拟 clone()： struct Base { virtual ~Base() = default; virtual Base* clone() const = 0; }; struct Derived : Base { Derived* clone() const override { return new Derived(*this); } }; 七、使用继承与虚机制的注意事项与不足 常见问题与建议： 虚函数会引入运行时开销（vtable），但在大多数场景这是可接受的； 过度使用继承会增加耦合，优先考虑组合（composition）和接口设计； 需要双分派场景可考虑 Visitor 模式或使用 std::variant + std::visit（在支持的场景下优先考虑类型安全的替代方案）。 如果你希望，我可以继续： 为本章补充更多可编译的小示例（如 Visitor 模式示例、clone 工厂、线程安全的多态使用注意）； 将本章拆成更小的子文件，便于单独维护与阅读。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 07_Polymorphism "},"docs/Cpp/Pre-knowledge/08_Relationship_of_Class.html":{"url":"docs/Cpp/Pre-knowledge/08_Relationship_of_Class.html","title":"08_Relationship_of_Class","keywords":"","body":" 第20章：类关系 1. 概念回顾 2. 依赖 + 继承（基础形式） 3. 依赖 + 继承（演化/变化） 4. 关联 + 继承：委托与代理 5. 关联 + 继承：组合（组合是关联的强所有权形式） 6. 关联 + 继承（变化示意） 7. 设计建议 第20章：类关系 本章整理常见的类之间关系及其与继承的组合使用方式，给出概念解释、设计建议和简单代码示例。图片保留原始引用路径（未改动）。 1. 概念回顾 依赖（Dependency）：某类在实现或函数参数中暂时使用另一类。 关联（Association）：类之间存在长期联系（成员指针或引用）。 聚合（Aggregation）：弱拥有关系，整体与部分生命周期可独立（通常用裸指针或智能指针表示）。 组合（Composition）：强拥有关系，整体负责部分的生命周期（成员对象作为值或独占智能指针）。 继承（Inheritance）：表示“is-a”关系，用于重用行为并表示子类型化（subtyping）。 这些关系可单独使用，也可以与继承组合以表达更丰富的设计。 2. 依赖 + 继承（基础形式） 依赖通常出现在函数签名或实现内部，例如： struct Helper { void assist(); }; class Base { public: virtual ~Base() = default; virtual void doWork(Helper &h) { h.assist(); } }; class Derived : public Base { void doWork(Helper &h) override { /* 用派生类实现替换行为 */ } }; 3. 依赖 + 继承（演化/变化） 当设计需要在多处分派以不同方式使用某些辅助类时，可以将依赖项通过参数传入，从而使得派生类可以灵活组合行为。 4. 关联 + 继承：委托与代理 示例（委托）： class Worker { public: void work() {/*...*/} }; class Manager { Worker *w; // 关联关系：Manager 拥有或引用 Worker public: Manager(Worker *ptr): w(ptr) {} void manage() { if (w) w->work(); } }; 代理（Proxy）通常在不改变接口的前提下间接控制对真实对象的访问（常见于延迟初始化、访问控制、远程代理等）。 5. 关联 + 继承：组合（组合是关联的强所有权形式） 组合示例： class Engine { public: void start(){} }; class Car { Engine engine; // 组合：Car 直接包含 Engine 的实例，Engine 的生命周期受 Car 控制 public: void start() { engine.start(); } }; 如果需要将部件作为指针持有以便共享或延迟创建，可使用 std::unique_ptr（独占）或 std::shared_ptr（共享），分别对应组合与聚合的不同语义。 6. 关联 + 继承（变化示意） 图片展示了在继承结构中使用不同关联模式（弱引用、聚合、组合）的场景与生命周期差异。设计时需注意所有权语义：谁负责销毁对象，是否允许共享，是否允许为空等。 7. 设计建议 优先使用组合/聚合来重用实现，优先考虑 has-a 而非 is-a，除非确实满足里氏替换原则（Liskov Substitution Principle）。 明确所有权：使用值成员、unique_ptr、shared_ptr 或裸指针来表达不同语义；尽量避免裸新的返回与裸指针的不明确所有权。 接口（抽象基类）应只暴露需要的行为，隐藏实现细节。 在需要运行时灵活替换实现时使用多态（虚函数）；在性能敏感、类型已知的情况下优先静态多态（模板、内联）。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 08_Relationship_of_Class "},"docs/Cpp/Pre-knowledge/09_Diamond_Inheritance.html":{"url":"docs/Cpp/Pre-knowledge/09_Diamond_Inheritance.html","title":"09_Diamond_Inheritance","keywords":"","body":" 菱形继承（Diamond Inheritance）与虚拟继承 1. 问题描述 2. 解决办法：虚拟继承（virtual inheritance） 3. 构造顺序与虚基类初始化规则 4. 虚继承与虚函数的区别与组合 5. 性能与内存开销 6. 常见替代方案 7. 小结 菱形继承（Diamond Inheritance）与虚拟继承 本节解释 C++ 中的菱形继承问题（又称钻石问题），展示非虚继承与虚拟继承的区别，说明构造顺序与虚基类初始化规则，并给出实践建议与示例代码。 1. 问题描述 当一个类通过两条不同路径继承自同一个基类时，会形成菱形继承结构： A / \\ B C \\ / D 如果 B 与 C 都直接继承自 A（非虚继承），那么 D 中会包含两个独立的 A 子对象，这会导致成员重复与二义性：调用 show() 时编译器无法确定访问哪一个 A::show()。 示例（非虚继承，存在二义性且会产生两个 A 子对象）： #include struct A { void show(){ std::cout 此外，sizeof(D) 会包含两个 A 子对象的大小（取决于成员和对齐），这在语义上通常不是想要的行为。 2. 解决办法：虚拟继承（virtual inheritance） 通过将对 A 的继承声明为虚继承，可以使 B 与 C 在 D 中共享同一个 A 子对象，从而消除二义性和重复子对象： #include struct A { void show(){ std::cout 要点：虚拟继承使得在最终最派生类（most-derived）中只存在一个共享的虚基类子对象。 3. 构造顺序与虚基类初始化规则 虚基类由最派生类（most-derived class）负责初始化。也就是说，当存在虚基类时，最底层类的构造函数应明确或隐式地初始化虚基类；中间派生类不能重复初始化该虚基类（但可以在构造函数的成员初始化表中列出它，通常会被忽略，取决于编译器）。 示例： #include struct A { A(int x=0){ std::cout 预期输出顺序（示例，具体实现可能略有差异）： A(42) constructed B constructed C constructed D constructed 说明：如果最派生类没有显式初始化虚基类，虚基类会被其默认构造函数初始化（若存在）。 4. 虚继承与虚函数的区别与组合 虚函数用于运行时多态（dynamic dispatch）；虚继承用于确保虚基类在最派生对象中只有一份子对象。两者解决的是不同的问题，但常常可以一起使用：虚继承不会改变虚函数本身的分派机制。 5. 性能与内存开销 虚拟继承通常会引入额外的指针或偏移（实现依赖），从而增大对象大小并带来额外的间接访问开销。除非确有必要（确需多重继承并共享基子对象），否则优先考虑组合、接口与单一继承。 6. 常见替代方案 使用组合（has-a）代替多重继承以降低复杂度； 若需要双重分派（基于调用对象和参数的动态类型），优先考虑 Visitor 模式、std::variant+std::visit 或显式的 dynamic_cast 实现而非复杂的多重继承体系。 7. 小结 菱形继承会产生重复基类子对象与二义性； 虚拟继承能保证共享单一虚基类子对象，并由最派生类负责初始化该虚基类； 虚拟继承带来实现与性能代价，因此仅在确有必要时使用。 如果你要，我可以为本章补充： 比较不同编译器下 sizeof(派生类) 的差异示例（注：与实现相关）； 更复杂的构造/析构顺序示例或实际场景（GUI、组件系统）代码。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 09_Diamond_Inheritance "},"docs/Cpp/Pre-knowledge/10_dynamic_cast.html":{"url":"docs/Cpp/Pre-knowledge/10_dynamic_cast.html","title":"10_dynamic_cast","keywords":"","body":" 主要用途 语法 使用示例 向下转换 横向转换 include include 多重继承与 dynamic_cast 何时使用 dynamic_cast 类型转换操作符概览（简要） 继承与类型转换（要点） 抽象类与接口注意事项 dynamic_cast dynamic_cast 是 C++ 中的一个运算符，用于在运行时进行类型安全的向下转换（downcasting）或横向转换（cross-casting）。它主要用于处理含有继承关系的类对象。dynamic_cast 的使用主要集中在以下几个方面： 主要用途 向下转换（Downcasting）： 从基类指针或引用转换为派生类指针或引用。 横向转换（Cross-casting）： 在同一个继承体系内，从一个指向基类的指针或引用转换为另一个派生类的指针或引用。 语法 dynamic_cast(expression) new_type：目标类型，必须是指针或引用类型。 expression：要转换的表达式。 使用示例 向下转换 class Base { public: virtual ~Base() {} // 必须有虚函数，通常是虚析构函数 }; class Derived : public Base { public: void derivedFunction() { std::cout (basePtr); if (derivedPtr) { derivedPtr->derivedFunction(); } else { std::cout 横向转换 class AnotherDerived : public Base { public: void anotherFunction() { std::cout (basePtr); # dynamic_cast（与类型转换概览） `dynamic_cast` 是 C++ 中用于在运行时进行安全的多态类型转换的运算符，常用于： - 向下转换（downcast）：从基类指针/引用转换为派生类指针/引用； - 横向转换（cross-cast）：在同一多态继承体系内，通过基类指针/引用转换为其他派生类指针/引用（当类型关系允许时）。 注意：`dynamic_cast` 只适用于多态类型（即类中至少有一个虚函数），因为它依赖 RTTI（运行时类型信息）。 ## 语法与行为 ```cpp dynamic_cast(expression); new_type 必须是指针或引用类型（或 void* 指针）； 对指针的转换失败返回 nullptr；对引用的转换失败会抛出 std::bad_cast； 要求被转换的类型是多态类型（类中含虚函数），否则对指针的 dynamic_cast 在编译期对基类指针向派生类指针的转换会被拒绝。 示例：向下转换（指针与引用） #include #include struct Base { virtual ~Base() = default; }; struct Derived : Base { void foo(){ std::cout(p)) { d->foo(); // 安全 } try { Base &r = *p; Derived &dr = dynamic_cast(r); // 成功 (void)dr; } catch(const std::bad_cast &e){ std::cerr 如果 p 指向的是非 Derived 对象，指针转换将返回 nullptr，引用转换将抛出 std::bad_cast。 示例：横向转换（通过基类进行） struct Another : Base { void bar(){ std::cout(p) 成功，除非 p 实际指向 Another 对象 Another* a = dynamic_cast(p); if (!a) std::cout 多重继承与 dynamic_cast dynamic_cast 可以处理带有虚继承或非虚继承的复杂继承图，但行为依赖于对象的真实动态类型和类的多态性。对于跨子层次结构的转换，RTTI 提供了必要信息来判断是否允许转换并计算正确的偏移。 何时使用 dynamic_cast 当只在运行时才能确定对象的实际类型时； 在需要安全检查并根据对象动态类型执行特定操作时； 在使用第三方库或大型继承体系时，为了防止未定义行为而选择安全转换。 注意：dynamic_cast 会带来运行时开销（RTTI 查询与指针偏移计算），应权衡性能与安全性。 类型转换操作符概览（简要） static_cast(expr)：编译期转换，速度快，但不做运行时类型检查； const_cast(expr)：移除或添加 const/volatile 修饰； reinterpret_cast(expr)：重新解释位模式，一般不可移植，应慎用； dynamic_cast(expr)：运行时类型安全转换，需多态类型支持（虚函数/RTTI）。 继承与类型转换（要点） 向上转换（derived -> base）：在 public 继承下总是安全且隐式可行； 向下转换（base -> derived）：只有在运行时确认对象真实类型时才安全，使用 dynamic_cast 可进行检查； protected/private 继承会影响访问权限，决定是否允许隐式转换（编译期规则）。 抽象类与接口注意事项 抽象类用于定义接口（含纯虚函数）； 基类应提供虚析构函数以确保通过基类指针删除派生类对象时能正确析构。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 10_dynamic_cast "},"docs/Cpp/Pre-knowledge/11_Expressions.html":{"url":"docs/Cpp/Pre-knowledge/11_Expressions.html","title":"11_Expressions","keywords":"","body":" 表达式 4.1 求值顺序与未定义行为 4.2 算术运算符与常见注意点 4.3 关系运算符（与空指针检查） 4.4 赋值运算符 4.5 递增和递减运算符 4.6 成员访问与求值顺序 4.7 条件（三元）运算符 ?: 4.8 位运算符 4.9 sizeof 运算符 4.10 逗号运算符 4.11 类型转换（概述） 表达式 本章摘录要点并给出准确表述与示例，便于复习。注意：现代 C++（自 C++11 起）对求值顺序有更精细的规定，但单个表达式中既修改又使用同一对象仍应避免未定义行为。 4.1 求值顺序与未定义行为 如果在同一表达式中对同一对象既有修改操作又有未被序列化（sequenced）使用，可能导致未定义行为。示例（不要写成这样）： cout 更安全的写法是将修改和读取分开为不同语句。 4.2 算术运算符与常见注意点 加、减、乘、除、取模等。除法在整数间是整数除法。注意溢出和除以 0。 4.3 关系运算符（与空指针检查） 示例：既要判空又要判非空字符串时常见写法： void test03() { const char *cp = \"hello world\"; if (cp && *cp) // cp 非空且首字符非 '\\0' cout 4.4 赋值运算符 赋值运算符的优先级通常低于关系运算符，因此 if (a = b) 会先执行赋值再判断结果是否为零，请谨慎使用。 4.5 递增和递减运算符 前置（++i）返回已递增后的左值，后置（i++）返回递增前的值（作为右值）；对用户自定义类型而言，前置通常更高效。 示例说明： cout 4.6 成员访问与求值顺序 当一个子表达式会修改对象而另一个子表达式使用该对象时，求值顺序决定行为是否定义。建议避免在单个表达式中同时修改并使用同一对象。 4.7 条件（三元）运算符 ?: 三元运算符等价于简短的 if-else，可嵌套使用，但为了可读性，深度嵌套应避免。 示例： std::string finalgrade = (grade > 90) ? \"highGrade\" : (grade 4.8 位运算符 常见位运算：&（按位与）、|（按位或）、^（按位异或）、~（按位取反）、（左移）、>>（右移）。 移位运算的优先级介于算术与关系运算之间；注意对符号位的影响以及移位超过类型位宽会产生未定义行为。 4.9 sizeof 运算符 sizeof 在编译期通常产生常量表达式（对动态大小数组的例外除外）。对数组使用 sizeof 可得到整个数组大小（字节数），不是元素个数。 示例： int b[10]; size_t bytes = sizeof(b); // 10 * sizeof(int) size_t elems = sizeof(b) / sizeof(b[0]); 4.10 逗号运算符 逗号运算符从左到右求值，丢弃左侧结果，返回最右侧表达式的值，常用于较低层面的表达式组合；不要与逗号分隔符混淆（函数参数、初始化列表使用的逗号）。 示例： int x = (f(), g()); // 会先调用 f()，然后调用 g()，x 取 g() 的返回值 4.11 类型转换（概述） 常见规则：整型提升（promotions）、算术转换（usual arithmetic conversions）、以及显式转换（static_cast, reinterpret_cast, const_cast）。 布尔上下文中会将非布尔值转换为 bool（0 -> false，非 0 -> true）。 简要示例： int a = 3; unsigned int b = 5u; auto r = a + b; // usual arithmetic conversions: int -> unsigned int (可能导致符号相关行为) double d = static_cast(a) / 2; // 更明确的浮点除法 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 11_Expressions "},"docs/Cpp/Pre-knowledge/12_Singleton_Pattern.html":{"url":"docs/Cpp/Pre-knowledge/12_Singleton_Pattern.html","title":"12_Singleton_Pattern","keywords":"","body":" 单例模式 单例模式的实现步骤 经典的单例实现 解释 线程安全 C++11的懒汉式单例 [JLUtech]懒汉单例(莫名相似) 常对象, 常指针, 常引用 常对象的声明和使用 常对象的限制 示例代码 关键点 常指针和常引用 常引用 常指针 总结 复用 异常 异常处理的基本概念 C++中的异常处理 基本语法 示例 异常处理的步骤 常见异常类 多重捕获 异常处理的优点 异常的名称 尝试整活 总结 .h and .cpp 头文件（Header Files） 内容 示例 实现文件（Source Files） 内容 示例 包含警戒（Include Guards） 使用方法 使用注意事项 总结 extern用法 使用 extern 的场景 示例 解释 注意事项 总结 虚函数 虚函数表 基类虚函数表的作用 动态内存管理 主要内容 类的设计 主要内容 单例模式 在C++中，单例模式（Singleton Pattern）是一种创建型设计模式，旨在确保一个类只有一个实例，并提供全局访问点。这在需要全局状态或资源管理的场景中非常有用，例如日志记录、数据库连接池、配置管理等。 单例模式的实现步骤 实现单例模式主要包括以下三个步骤： 构造函数私有化：防止通过外部代码直接创建实例。 删除复制构造函数和赋值运算符：防止通过复制或赋值创建新的实例。 提供一个访问实例的静态方法：通常是 getInstance() 方法，该方法在第一次调用时创建唯一的实例，并在后续调用中返回该实例。 经典的单例实现 下面是一个简单的单例模式实现示例： #include #include class Singleton { private: // 私有构造函数 Singleton() { std::cout lock(mtx); // 线程安全 if (instance == nullptr) { instance = new Singleton(); } } return instance; } }; // 初始化静态成员 Singleton* Singleton::instance = nullptr; std::mutex Singleton::mtx; int main() { Singleton* s1 = Singleton::getInstance(); Singleton* s2 = Singleton::getInstance(); // 输出指针地址，验证两个指针是否指向同一个实例 std::cout 解释 私有构造函数：防止外部直接创建 Singleton 类的实例。 删除拷贝构造函数和赋值运算符：防止通过复制或赋值创建新的实例。 静态指针 instance：用于指向唯一的 Singleton 实例。 静态方法 getInstance()：提供获取唯一实例的途径，使用双重检查锁（Double-checked locking）确保线程安全。 线程安全 上述示例中使用了 std::mutex 和 std::lock_guard 来确保在多线程环境中实例创建的线程安全性。双重检查锁机制（Double-checked locking）通过减少锁的开销来提高性能。 C++11的懒汉式单例 在C++11及之后的版本中，可以利用静态局部变量的特性简化单例模式的实现，因为静态局部变量在第一次使用时才初始化，并且是线程安全的。 class Singleton { private: Singleton() { std::cout 在这种实现中，静态局部变量 instance 保证了线程安全性，并且代码更加简洁。 [JLUtech]懒汉单例(莫名相似) //狗屁不是, 不想写了 常对象, 常指针, 常引用 在C++中，常对象（constant object）是指使用 const 关键字修饰的对象。一旦对象被声明为常对象，它的状态就不能被修改。也就是说，常对象的成员变量不能被更改，且只能调用其 const 成员函数（常函数）。 常对象的声明和使用 常对象可以通过在对象声明时添加 const 关键字来创建。例如： const MyClass obj(42); 在上面的例子中，obj 是一个常对象，其状态在生命周期内不能被修改。 常对象的限制 不能修改成员变量：常对象的成员变量不能被修改，即使是通过对象的方法。 只能调用常函数：常对象只能调用 const 成员函数，不能调用非常函数（非 const 成员函数）。 示例代码 以下是一个包含常对象的示例： #include class MyClass { private: int value; public: // 构造函数 MyClass(int val) : value(val) {} // 常函数 int getValue() const { return value; } // 非常函数 void setValue(int val) { value = val; } }; int main() { const MyClass obj(42); // 声明常对象 std::cout 关键点 声明常对象：使用 const 关键字修饰对象声明。 const MyClass obj(42); 调用常函数：常对象只能调用 const 成员函数。 std::cout 禁止修改状态：常对象不能调用非常函数，也不能直接修改成员变量。 // obj.setValue(84); // 错误：不能调用非常函数 常指针和常引用 常对象通常与常指针和常引用一起使用，以提供额外的语义约束和安全性。 常引用 常引用指向常对象，保证引用指向的对象状态不会被修改。 void printValue(const MyClass& obj) { std::cout 常指针 常指针不能通过指针修改指向的对象。 const MyClass* ptr = &obj; std::cout getValue() setValue(84); // 错误：不能调用非常函数 总结 常对象 是使用 const 关键字修饰的对象，其状态在整个生命周期内不能被修改。 作用 是确保对象的不可变性，防止意外修改对象状态，提高代码的安全性和可维护性。 限制 是常对象只能调用 const 成员函数，不能调用非常函数或直接修改成员变量。 常指针和常引用 提供了更强的语义约束，使代码更加安全和可靠。 常对象在C++编程中用于保证对象状态的不可变性，是编写稳定和安全代码的重要工具。 复用 复用一个已有的类时，应优先选择组合方式，而不是继承方式. 组合耦合性更低. 异常 异常处理机制是编程语言中用于处理程序运行时错误的一种结构化方式。通过异常处理，程序可以捕获和处理错误，而不是在遇到错误时崩溃。这提高了程序的健壮性和用户体验。 异常处理的基本概念 异常（Exception）：程序运行过程中发生的错误或异常情况，如除零错误、数组越界、文件未找到等。 抛出（Throwing）：当程序遇到错误时，通过抛出异常通知异常的发生。 捕获（Catching）：程序中指定的代码块，用于捕获和处理异常。 C++中的异常处理 在C++中，异常处理通过 try、throw 和 catch 关键字实现。 基本语法 try { // 可能抛出异常的代码 } catch (const std::exception& e) { // 异常处理代码 } 示例 #include #include void divide(int a, int b) { if (b == 0) { throw std::runtime_error(\"Division by zero\"); // 抛出异常 } std::cout 异常处理的步骤 try 块：包含可能抛出异常的代码。 throw 语句：在检测到错误时，抛出一个异常对象。 catch 块：捕获特定类型的异常，并执行相应的处理代码。 常见异常类 C++ 标准库中定义了一些常见的异常类，位于 头文件中，如： std::exception：所有标准C++异常的基类。 std::runtime_error：表示运行时错误。 std::logic_error：表示逻辑错误。 多重捕获 可以为不同类型的异常定义多个 catch 块： try { // 可能抛出多个不同类型的异常 } catch (const std::runtime_error& e) { // 处理 runtime_error 类型的异常 } catch (const std::logic_error& e) { // 处理 logic_error 类型的异常 } catch (const std::exception& e) { // 处理所有其他 std::exception 派生类的异常 } 异常处理的优点 代码清晰：将正常逻辑与错误处理逻辑分离，使代码更清晰易读。 集中处理：在一个地方处理错误，使代码更易于维护。 提高健壮性：程序可以优雅地处理错误，而不是在遇到错误时崩溃。 异常的名称 常见的异常类包括 std::invalid_argument、std::logic_error、std::runtime_error 以及 std::exception。 其他的异常类为前三者的子类. 尝试整活 #include using namespace std; #include void ShalangBaizi() { cout> n; if (n == 430) throw runtime_error(\"Shalang Baizi is a magician!\"); else if (n == 423) throw logic_error(\"Shalang Baizi is a mathematician!\"); else if(n==424) throw invalid_argument(\"Shalang Baizi is a physicist!\"); else if(n==420) throw domain_error(\"Shalang Baizi is a chemist!\"); } int main() { try { ShalangBaizi(); } catch (runtime_error& e) { cout 总结 异常处理机制通过 try、throw 和 catch 关键字提供了一种结构化的错误处理方式。它使得程序可以捕获和处理运行时错误，提高了程序的健壮性和可维护性。在C++中，异常处理是一个重要的编程技术，可以帮助程序员编写更健壮和可靠的代码。 .h and .cpp 头文件和实现文件在C++编程中扮演了不同的角色，正确使用它们可以提高代码的可读性、可维护性和可重用性。下面我来详细介绍一下它们以及如何正确使用包含警戒。 头文件（Header Files） 头文件通常包含了类声明、函数声明、常量、宏定义等代码，供其他源文件包含和使用。头文件的主要作用是声明接口，使得代码模块化、可重用，并且提供了对外的公共接口。 内容 类声明：类的成员函数和成员变量的声明。 函数声明：函数的声明，包括函数名、参数列表和返回类型。 常量声明：常量的声明，如 const int MAX_SIZE = 100;。 宏定义：宏定义，如 #define PI 3.1415926。 内联函数定义：在头文件中定义的短小的函数可以直接在头文件中实现。 [JLUtech]extern变量声明: 在头文件加入extern 变量, 并在任意.cpp文件中写入该文件定义 extern int header; int header = 200; 示例 // MyClass.h #ifndef MYCLASS_H #define MYCLASS_H class MyClass { public: void myFunction(); // 函数声明 static const int MAX_SIZE = 100; // 常量声明 private: int myVariable; // 成员变量 }; #endif 实现文件（Source Files） 实现文件包含了类的具体实现、函数的具体定义等。它一般用来定义头文件中声明的函数和类的具体实现细节。 内容 类成员函数的定义：类的成员函数的具体实现。 函数定义：函数的具体实现。 全局变量的定义：全局变量的定义，应尽量避免全局变量的使用。 静态成员变量的定义：静态成员变量的定义。 示例 // MyClass.cpp #include \"MyClass.h\" void MyClass::myFunction() { // 函数的具体实现 } 包含警戒（Include Guards） 包含警戒是一种预处理指令，用于防止头文件被重复包含。这在大型项目中尤其重要，因为头文件可能会被多个源文件包含，如果不加以控制，可能会导致重复定义的错误。 使用方法 #ifndef MYHEADER_H #define MYHEADER_H // 头文件内容 #endif 使用注意事项 只包含必要的内容：头文件中应该只包含其他文件需要的内容，避免包含过多的内容，导致编译时间增加和不必要的依赖。 避免在头文件中定义函数体：尽量避免在头文件中定义函数体，否则会导致多个源文件包含同一个头文件时，产生重复定义的错误。 正确使用包含警戒：在每个头文件的开头和结尾都应该使用包含警戒，以防止头文件被多次包含。 总结 头文件用于声明接口，包含类声明、函数声明等。 实现文件用于定义接口的具体实现。 包含警戒用于防止头文件被多次包含。 使用时注意：合理划分头文件和实现文件，只包含必要的内容，并正确使用包含警戒。 extern用法 extern 关键字用于声明一个全局变量或函数，但不定义它。它告诉编译器，该变量或函数在其他文件中有定义，需要在链接时找到其定义。extern 的使用可以使得变量或函数在多个文件之间共享。 使用 extern 的场景 声明全局变量：在一个文件中声明一个全局变量，然后在其他文件中使用 extern 声明该变量，以便在链接时找到它的定义。 声明全局函数：在一个文件中声明一个全局函数，然后在其他文件中使用 extern 声明该函数，以便在链接时找到它的定义。 示例 假设有两个源文件 file1.cpp 和 file2.cpp： // file1.cpp #include // 声明全局变量 extern int globalVariable; // 声明全局函数 extern void globalFunction(); int main() { // 使用全局变量 std::cout // file2.cpp #include // 定义全局变量 int globalVariable = 42; // 定义全局函数 void globalFunction() { std::cout 解释 在 file1.cpp 中，使用 extern 声明了全局变量 globalVariable 和全局函数 globalFunction。 在 file2.cpp 中，定义了全局变量 globalVariable 和全局函数 globalFunction。 当编译 file1.cpp 和 file2.cpp 时，编译器会将 file1.cpp 中的 extern 声明与 file2.cpp 中的定义进行链接。 注意事项 仅声明，不定义：extern 声明仅用于声明，不用于定义变量或函数。 一次声明，多次使用：可以在多个文件中使用同一个 extern 声明。 正确链接：需要确保所有的 extern 声明都能够与相应的定义进行正确链接，否则会导致链接错误。 总结 extern 关键字用于声明全局变量或函数，告诉编译器它们的定义在其他文件中。通过 extern 声明，可以实现全局变量和函数在多个文件之间的共享。 虚函数 虚函数是C++中实现多态性的关键概念之一，用于在基类和派生类之间建立动态绑定的机制。简单来说，虚函数允许在基类中声明函数，然后在派生类中重新定义该函数，使得通过基类指针或引用调用这个函数时，根据指针或引用实际指向的对象类型来决定调用哪个函数的版本。 在C++中，将基类的函数声明为虚函数的语法如下： class Base { public: virtual void func() { // 基类函数实现 } }; 派生类可以覆盖基类中的虚函数，并且使用 override 关键字来明确表明这是对基类虚函数的重写： class Derived : public Base { public: void func() override { // 派生类函数实现 } }; 通过使用虚函数，可以实现运行时多态性，即在程序运行时根据实际对象的类型来确定调用哪个函数版本，而不是在编译时确定。这种灵活性使得C++能够更好地支持面向对象编程中的多态性特性。 虚函数表 假设我们有一个基类 Shape 和两个派生类 Circle 和 Rectangle，它们都包含一个虚函数 draw() 用于绘制图形。 #include class Shape { public: virtual void draw() { std::cout draw(); // 输出 \"Drawing a circle\" shape2->draw(); // 输出 \"Drawing a rectangle\" delete shape1; delete shape2; return 0; } 在上面的示例中，我们创建了两个指向基类 Shape 的指针 shape1 和 shape2，分别指向派生类 Circle 和 Rectangle 的对象。当我们调用 shape1->draw() 和 shape2->draw() 时，由于 draw() 是虚函数，程序会根据对象的实际类型调用正确的 draw() 函数版本。 现在让我们来详细阐述虚函数表在这个示例中的作用： 编译阶段： 当编译器编译 Circle 和 Rectangle 类时，它会生成两个虚函数表，每个表中包含一个指向 draw() 函数的指针。 编译器还会在基类 Shape 中生成一个虚函数表，并在其中填充指向 Shape::draw() 函数的指针。 运行时阶段： 当我们创建 Circle 或 Rectangle 的对象时，对象的内存布局中会有一个指向虚函数表的指针（虚指针）。 当我们调用 shape1->draw() 时，程序会使用 shape1 对象的虚指针来确定正确的虚函数表，并从中找到指向 Circle::draw() 函数的指针，并调用该函数。 同样，当我们调用 shape2->draw() 时，程序会使用 shape2 对象的虚指针来确定正确的虚函数表，并从中找到指向 Rectangle::draw() 函数的指针，并调用该函数。 这样，通过虚函数表的机制，我们实现了基类指针在运行时根据实际对象的类型来调用正确的函数版本，实现了多态性的特性。 基类虚函数表的作用 在基类 Shape 中生成一个虚函数表，并在其中填充指向 Shape::draw() 函数的指针的作用在于为基类和其派生类提供一个统一的接口。具体来说，这个虚函数表的作用有以下几点： 定义接口：虚函数表定义了基类 Shape 的接口，即它表示了所有派生类都应该具有的公共行为。在虚函数表中，通过将 draw() 函数的指针指向 Shape::draw() 函数，表明了所有派生类都应该实现 draw() 函数，并且应该具有相同的接口。 实现多态：虚函数表为运行时多态性提供了基础。当我们使用基类指针或引用调用虚函数时，实际调用的是对象的虚函数表中相应函数的版本。在基类中定义虚函数表，并将其填充为指向基类函数的指针，保证了即使通过基类指针或引用调用虚函数时，也能够调用到正确的函数版本。 提供默认实现：虚函数表中指向 Shape::draw() 函数的指针，提供了一个默认的实现。如果某个派生类没有覆盖 draw() 函数，那么将会调用基类的 draw() 函数，保证了程序的正确性和稳定性。 总的来说，基类 Shape 中生成一个虚函数表，并在其中填充指向 Shape::draw() 函数的指针，使得基类和其派生类之间建立了一个统一的接口，并为实现多态性提供了基础。 动态内存管理 内动态内存管理在面向对象程序设计中的应用，具体内容包括内存分配与释放、内存泄漏的预防、指针与引用的使用等。 主要内容 动态内存管理的基本概念： 动态内存分配是指在程序运行时根据需要分配和释放内存。 C++中主要使用new和delete操作符进行动态内存管理。 内存分配与释放： 使用new操作符为单个变量或数组分配内存。 使用delete操作符释放为单个变量或数组分配的内存。 示例代码展示了如何正确使用new和delete进行内存管理。 内存泄漏： 内存泄漏指程序在不再需要某块动态分配的内存时未能及时释放，导致内存无法被回收利用。 介绍了预防内存泄漏的方法，例如：使用智能指针（如std::unique_ptr和std::shared_ptr）管理动态内存。 指针与引用： 讲解了指针与引用的基本概念及其区别。 介绍了如何使用指针和引用进行动态内存管理，并提供了示例代码。 智能指针： 详细介绍了C++11引入的智能指针，包括std::unique_ptr、std::shared_ptr和std::weak_ptr。 讨论了智能指针的使用场景及其优缺点。 动态内存管理的常见问题： 讨论了常见的动态内存管理问题，如野指针、重复释放内存等，并提供了相应的解决方案。 类的设计 面向对象编程中类的设计原则与方法，重点讨论了抽象与封装、信息隐蔽、类的使用与实现分离、以及单个类和多个类的设计等内容。 主要内容 面向对象的三大基本特征： 封装与信息隐蔽：通过类和对象对客观事物进行抽象，隐藏内部实现细节，只公开必要的行为和属性。 继承：子类继承父类的属性和方法，支持代码重用。 多态：通过接口实现不同子类的多态性行为。 抽象与表示： 讲解了类型、行为和数据的抽象及其在类设计中的应用。 提供了小球碰撞问题和游戏中的怪物战斗问题作为例子，展示了如何将抽象的概念具体化为类的实现。 信息隐蔽： 讨论了如何通过隐藏类的内部实现细节，提高类的安全性和可维护性。 提供了示例代码，展示了如何隐藏类的私有成员和方法。 分离使用和实现： 强调了类的使用者与实现者之间的分离，减少耦合度。 提供了示例代码，展示了如何将类的声明和实现分离开来。 多个类的设计： 讨论了类之间的关系，包括类的拆分与合并、数据关系和行为关系。 提供了一个应用程序的例子，展示了如何设计多个类并处理它们之间的关系。 单个类的设计： 讨论了单个类的设计原则，包括行为的可见性、行为参数的抽象与封装、依赖与关联、实现的抽象与封装、数据的抽象与封装、类方法与实例方法等。 提供了示例代码，展示了如何设计一个功能完善的类。 创建方法与构造函数： 介绍了创建方法和构造函数的设计原则。 讨论了如何使用工厂方法模式创建对象，提供了示例代码。 单件模式的实现： 讲解了单件模式的概念及其实现方法，确保类只有一个实例。 提供了使用静态成员变量和方法实现单件模式的示例代码。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 12_Singleton_Pattern "},"docs/Cpp/Pre-knowledge/13_static.html":{"url":"docs/Cpp/Pre-knowledge/13_static.html","title":"13_static","keywords":"","body":" static 1. static 局部变量 定义与用法 特点： 例子： 2. static 全局变量 定义与用法 特点： 例子： 3. static 类成员变量和成员函数 静态成员变量 定义与用法 例子： 静态成员函数 定义与用法 例子： 4. static 函数 定义与用法 特点： 例子： 什么时候可以返回局部变量 返回静态局部变量 总结 static 在C++中，static 关键字有多种用途，适用于不同的上下文：局部变量、全局变量、类成员和函数。每种情况下，static 都有独特的行为和作用。下面详细阐述 static 关键字在不同上下文中的用法和作用。 1. static 局部变量 定义与用法 当在一个函数内部定义一个局部变量时，如果加上 static 关键字，这个局部变量将拥有静态存储周期。意味着该变量在程序的整个运行过程中保持其值，并且在函数每次调用时，该变量不会重新分配和初始化。 特点： 生命周期：从程序开始到结束（与全局变量类似）。 作用域：局限于声明它的函数内部。 初始化：只在第一次调用时初始化，以后调用时保留其之前的值。 例子： #include void increment() { static int count = 0; // 静态局部变量，只初始化一次 count++; std::cout 输出： Count: 1 Count: 2 Count: 3 Count: 4 Count: 5 解释： count 是一个静态局部变量，只在第一次调用 increment 时初始化。 每次调用 increment，count 的值都会递增，但不会重新初始化。 2. static 全局变量 定义与用法 在函数外部定义的全局变量，如果加上 static 关键字，该变量的作用域将被限制在定义它的文件内。这意味着这个变量不能被其他文件访问，即使其他文件通过 extern 声明也无法访问。 特点： 生命周期：从程序开始到结束。 作用域：限制在变量定义的文件内（文件作用域）。 例子： file1.cpp: #include static int fileScopedVar = 10; // 静态全局变量，只能在这个文件中访问 void printFileScopedVar() { std::cout file2.cpp: #include // extern int fileScopedVar; // 错误：无法访问 file1.cpp 中的静态全局变量 extern void printFileScopedVar(); int main() { // std::cout 解释： fileScopedVar 在 file1.cpp 中声明为静态全局变量，所以它只在 file1.cpp 内可见。 file2.cpp 尝试通过 extern 访问 fileScopedVar 会导致编译错误。 但是，file2.cpp 可以通过 printFileScopedVar 函数间接访问 fileScopedVar。 3. static 类成员变量和成员函数 在类内部，static 关键字可以应用于成员变量和成员函数。它们与类的具体实例无关，而是属于整个类。 静态成员变量 定义与用法 共享：静态成员变量在所有对象间共享同一个实例。 类级别访问：可以通过类名访问，而不需要创建类的实例。 初始化：必须在类外进行初始化。 例子： #include class MyClass { public: static int sharedValue; // 静态成员变量声明 void show() { std::cout 解释： sharedValue 是 MyClass 的静态成员变量，对所有实例共享。 通过 MyClass::sharedValue 修改静态成员变量后，所有实例访问该变量时都会看到修改后的值。 静态成员函数 定义与用法 不依赖对象：可以在没有创建类的实例时调用。 只能访问静态成员：静态成员函数只能访问静态成员变量和其他静态成员函数，不能访问非静态成员。 例子： #include class MyClass { public: static int counter; static void increment() { counter++; } static void showCounter() { std::cout 解释： increment 和 showCounter 是静态成员函数，可以直接通过类名调用。 静态成员函数只能访问静态成员变量 counter，不能访问非静态成员。 4. static 函数 定义与用法 在文件作用域中，static 关键字可以用于函数定义，限制该函数的作用域只在定义它的文件内。这类似于静态全局变量的文件作用域。 特点： 作用域：函数仅在声明它的文件内可见，不能被其他文件访问。 不影响生命周期：静态函数和普通函数的生命周期相同。 例子： file1.cpp: #include static void hiddenFunction() { std::cout file2.cpp: #include // extern void hiddenFunction(); // 错误：无法访问 file1.cpp 中的静态函数 extern void callHiddenFunction(); int main() { // hiddenFunction(); // 错误：无法直接调用 file1.cpp 中的静态函数 callHiddenFunction(); // 间接调用静态函数 return 0; } 解释： hiddenFunction 在 file1.cpp 中声明为静态函数，只能在 file1.cpp 中使用。 file2.cpp 尝试通过 extern 访问 hiddenFunction 会导致编译错误。 但可以通过 callHiddenFunction 间接调用 hiddenFunction。 什么时候可以返回局部变量 返回静态局部变量 静态局部变量的生命周期是全局的，尽管它们的作用域是局部的。这意味着它们在程序的整个生命周期内都有效，所以可以安全地返回它们的指针或引用。 总结 局部变量的 static：延长局部变量的生命周期，使其在函数调用之间保持值。 全局变量的 static：限制全局变量的作用域，使其只能在定义它的文件中可见。 类成员的 static：允许成员变量在所有对象之间共享，允许成员函数不依赖于对象访问。 函数的 static：限制函数的作用域，使其只能在定义它的文件中可见。 static 关键字的灵活性使得它在控制作用域、生命周期和访问权限方面非常有用，理解它的不同用法对于掌握C++编程是至关重要的。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 13_static "},"docs/Cpp/Pre-knowledge/14_virtual.html":{"url":"docs/Cpp/Pre-knowledge/14_virtual.html","title":"14_virtual","keywords":"","body":" virtual — 虚函数与多态 1 虚函数与动态绑定 2 纯虚函数与抽象类 3 虚析构函数 4 名称隐藏与覆盖（hiding vs overriding） 5 vtable / vptr（实现细节） 6 虚继承（解决菱形继承） 7 性能与设计权衡 8 常见陷阱 virtual — 虚函数与多态 virtual 是实现运行时多态的核心关键词。下文整理常见概念、正确示例和实务建议，便于快速查阅。 1 虚函数与动态绑定 当基类的成员函数被声明为 virtual 时，通过基类指针或引用调用该函数会在运行时根据对象的实际类型选择具体实现（动态绑定）。 示例： #include struct Base { virtual void show() { std::cout show(); // 调用 Derived::show delete b; // 正确析构 } 使用 override 可以让编译器在签名不匹配时给出错误，建议在派生类重写虚函数时总使用。 2 纯虚函数与抽象类 纯虚函数使用 = 0 声明，含纯虚函数的类称为抽象类，不能被实例化： struct Interface { virtual void f() = 0; }; struct Impl : Interface { void f() override { /* ... */ } }; 抽象类常用于定义接口或策略。 3 虚析构函数 如果一个类有可能通过基类指针被删除，那么基类应声明虚析构函数以保证派生类的析构函数被调用，防止资源泄露。 struct B { virtual ~B() = default; }; struct D : B { ~D() { /* 清理 */ } }; 4 名称隐藏与覆盖（hiding vs overriding） 覆盖（override）：当基类函数为 virtual，派生类提供相同签名的实现；使用 override 明确意图。 隐藏（hiding）：如果派生类定义了同名但不同签名的函数，会隐藏基类所有同名重载，可用 using Base::f; 引入基类重载。 示例（using 引入基类重载）： struct A { virtual void f(int); }; struct B : A { using A::f; void f(double); }; // 保留 A::f(int) 5 vtable / vptr（实现细节） 大多数实现为每个多态类生成一张虚表（vtable），对象包含一条指向该表的指针（vptr）。这是实现动态分派的常见机制，但具体布局由编译器决定，不要依赖实现细节。 6 虚继承（解决菱形继承） 虚继承用于共享菱形继承中的共同基类实例，避免多份基类子对象。但它增加了复杂性与运行时开销： struct A { int x; }; struct B : virtual A { }; struct C : virtual A { }; struct D : B, C { }; 在 D 中只有一份 A 子对象（由虚继承保证）。 7 性能与设计权衡 虚调用会带来一次间接调用（通过 vptr），比非虚函数略慢； 对象需要额外存储 vptr（通常为一个指针）； 设计时应权衡：使用虚函数以换取可扩展性与清晰的接口，避免在性能敏感的内联小函数上使用虚。对于替代方案，可用模板/CRTP 实现静态多态。 8 常见陷阱 构造/析构期间不会做动态分派（在基类构造/析构中调用虚函数会按当前构造阶段使用基类版本）； 未提供虚析构会导致通过基类指针删除派生对象时发生未定义行为（资源泄漏）； 不要依赖 vtable 布局或用 reinterpret_cast 操作 vptr。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 14_virtual "},"docs/Cpp/Pre-knowledge/15_Miscellaneous.html":{"url":"docs/Cpp/Pre-knowledge/15_Miscellaneous.html","title":"15_Miscellaneous","keywords":"","body":" 杂项 1. 类的大小（影响因素） 2. 数据成员规则 3. 对象实例化与访问 4. 常见基本类型与指针大小（平台相关） 5. 虚机制（动态绑定） 虚函数的基本规则 虚函数表（vtable）与 vptr 注意事项 杂项 1. 类的大小（影响因素） 类对象的大小（sizeof(T)）主要受以下因素影响： 非静态数据成员的数量与类型（不同类型有不同对齐与大小）； 对齐与填充（编译器的对齐策略会在成员之间插入填充字节）； 是否包含虚函数（通常对象会包含一个指向虚函数表的指针 vptr）； 不影响对象大小的因素： 成员函数的个数（成员函数存在于类的代码区，而非对象实例中）； 静态数据成员（静态成员属于类而非对象实例）； 访问控制（public/protected/private 不改变对象布局）。 注意：空类在 C++ 中至少占用 1 字节以保证 distinct address（不同对象有不同地址）。 2. 数据成员规则 普通数据成员可为内置类型、数组、指针、引用或其它类类型； enum、const、static 等修饰不会改变类型本身的内存占用（但 static 成员不算作对象的一部分）； 结构体或类不能直接递归包含自身的对象成员，但可包含指向自身的指针或引用。 示例： struct Node { int value; Node* next; }; // 允许指针递归，但不能写成 Node child; 3. 对象实例化与访问 对象是类的实例，任何对象都有确定的静态类型； 一个类型可以实例化零个或多个对象； 访问对象的常见方式：直接调用成员、通过指针或引用访问、通过消息（多态调用）等。 示例： struct S { void f(){} }; S obj; obj.f(); S* p = &obj; p->f(); S& r = obj; r.f(); 面向对象风格强调通过接口（消息）与对象交互，具体实现由对象自身决定（可能导致不同的运行时行为）。 4. 常见基本类型与指针大小（平台相关） 不同平台与编译器下基本类型大小可能不同，下列为常见值（仅作参考）： char : 1 字节 short : 通常 2 字节 int : 通常 4 字节 long : 32 位系统通常 4 字节，64 位系统视实现可能为 8 字节 long long : 通常 8 字节 float : 4 字节 double : 8 字节 long double : 平台相关（通常 8、12 或 16 字节） 指针 : 平台相关（32 位系统通常 4 字节，64 位系统通常 8 字节） 要获得精确大小，请在目标平台上使用 sizeof 运算符测试。 5. 虚机制（动态绑定） 静态绑定（early binding）：在编译期决定调用哪个函数实现。 动态绑定（late binding）：在运行期根据对象的动态类型决定调用哪个函数实现，C++ 通过虚函数机制实现动态绑定。 虚函数的基本规则 虚函数必须是非静态成员函数；构造函数与拷贝构造函数不能是虚的；析构函数可以且在有派生类时应声明为 virtual； 虚函数可被 const 修饰；访问控制（public/protected/private）对虚函数无特殊限制； 在派生类中覆盖基类虚函数时，virtual 关键字可以省略，但建议使用 override 明确意图并让编译器检查。 示例： struct Base { virtual ~Base() = default; virtual void f() { std::cout 虚函数表（vtable）与 vptr 实现细节（依赖于编译器）：包含虚函数的类通常有一张虚函数表（vtable），对象实例包含一个指向该表的指针（vptr）； vtable 存放指向具体虚函数实现的指针，运行时通过 vptr 查表并间接调用实现； vtable/vptr 的存在会影响对象的大小（通常增加一个指针的大小）。 调用过程（概念性描述）： 编译期根据表达式的静态类型查找匹配的函数名与签名； 若该函数为虚函数，生成间接调用代码，运行时使用对象的 vptr 查表并跳转到实际实现。 示例（概念）： // p->f() 在编译期变为类似: (*p->vptr)[index](p, ...); 注意事项 即使某个虚函数在静态类型中未被实际调用，它仍必须存在以便编译通过（即静态类型需要声明该成员）； 虚继承、虚基类等会使对象布局更复杂并带来额外开销；仅在必要时使用多重继承与虚继承。 如果你希望，我将继续按顺序处理下一个文件 oop8-9.md。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 15_Miscellaneous "},"docs/计算机组成原理/":{"url":"docs/计算机组成原理/","title":"计算机组成原理","keywords":"","body":" 计算机组成原理 计算机组成原理 本目录包含与计算机组成原理相关的笔记与图示，我将用通俗的语言介绍计算机硬件与系统的基本工作原理，适合入门学习与课堂复习。 对于计组的繁多内容，仅仅靠我的笔记并不能完全理解和融会贯通，建议结合教材和其他资料进行学习。 同时可以尝试自己利用logisim构建一个属于自己的单周期甚至流水线的CPU进行实战 当然也可以利用Verilog尝试搭建一个CPU，在另一个仓库CPU,我已经尝试编写了两个五级流水线加上分支预测以及数据前推的CPU分别是MIPS32和LA32R。设计简陋仅供参考，存在大量问题还请见谅。 主要内容： 计算机组成原理基础知识：全面讲解计算机硬件、指令、存储与数据通路等基础概念，配有示意图。 计算机组成原理基础知识（简答版）：简洁版要点，适合快速复习或备考使用。 如何使用： 建议先读简答版把整体脉络理清，再读基础知识文件以补充细节和图示。 阅读时可结合图示演示或手绘简单示意，加深理解。 学习建议： 多做笔记并尝试用自己的话解释每个模块的作用（例如：CPU、内存、总线、IO）。 把重要概念画成图（如指令执行流程、流水线阶段），图形化有助于记忆。 我的github仓库Principles-of-Computer-Organizatio 欢迎在仓库内提交 Issue 或 PR 来提供建议和见解 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 计算机组成原理 "},"docs/计算机组成原理/计算机组成原理基础知识.html":{"url":"docs/计算机组成原理/计算机组成原理基础知识.html","title":"计算机组成原理基础知识","keywords":"","body":" 1.说明计算机系统的层次结构。 2.说明冯诺依曼体系结构的特点。 3.什么是机器字长、指令字长、存储字长? 4.系统总线包括哪三类？起到什么作用？ 5.总线判优控制是解决什么问题的？总的来说可以分为哪两种方式？ 6.集中式总线控制优先权仲裁方式有哪三种？各有什么特点？ 7.简述总线周期的4个阶段。 8.总线通信控制是解决什么问题的？总的来说有哪几种控制方式？各自的特点是什么？ 例题 9.串行传输和并行传输有何区别？各适用于什么场合？ 10.试比较RAM和ROM。 11.从实现技术的角度，试比较SRAM和DRAM。 12.存储芯片内的地址译码方式有几种？各自特点及应用场合？ 13.什么是动态RAM的刷新？刷新有几种方式？简要说明之。 14.存储容量扩展有哪几种方法？ 例题！！！P94 15.使用汉明码进行校验时，需要增加k位检测位，且k位的检测位和n位的待检测二进制代码位之间要满足什么关系？为什么？ 16.已知收到的海明码为0100111（按配偶原则配置），试问欲传送的信息是什么？ 17.什么是多体并行存储器？有哪两种存储体编址方式，各自有什么特点？ 例题： 18.Cache、主存和辅存构成的三级存储系统分别的目的是什么？设计依据是？ 19.请简述Cache的基本工作原理。 20.试比较主存-Cache管理中三种地址映射的方法，并分别给出在三种地址映射下，主存地址划分。 例题： 21.Cache-主存间的替换策略有哪些，请简述。 22.发生主存写请求时，如何保证Cache和主存的一致性？ 23.影响Cache-主存层平均访问时间的因素有哪些？如果降低平均访存时间，可以怎么办？ 24.I/O地址码的编制方式有哪两种？ 25.I/O与主机交换信息有哪几种控制方式？各有何特点？ 26.I/O接口有什么作用。 27.程序查询方式和程序中断方式都由程序实现外围设备的输入输出，它们有何不同？ 28.以I/O设备的中断处理过程为例，说明一次程序中断的全过程。 29.在DMA方式中有没有中断请求，为什么？DMA接口电路中应设置哪些硬件。 30.DMA方式中的中断请求和程序中断中的中断请求有何区别？ 31.DMA和主存交换数据时有哪三种方法？分别简述。 32.简述DMA的工作过程。 33.DMA接口的类型有哪几种？ 34A.说明补码加/减法运算步骤。（*） 34B.说明浮点加/减法运算的基本步骤。 35A.说明原码乘/除法运算的基本步骤。（*） 35B.说明浮点乘/除法运算的基本步骤。 36.试比较基址寻址和变址寻址，并举例说明其适用的场合。 37.任意写出五种寻址方式，令EA为有效地址，A为形式地址，写出这五种寻址方式计算有效地址的表达式。 38.指令中有哪些字段？各有何作用？如何确定各字段的位数？ 39.RISC和CISC指令系统各自的特点。 改变教材为计算机组成与设计（软硬件接口）第五版（中文版）(1) 40.请简述MIPS指令系统的R型、I型和J型指令格式，并举出指令实例。 41.在MIPS指令子集实现的时候，如何从单周期数据通路构造流水线？ 42.流水线中有哪三种冒险？请简述，并至少举出一种解决冒险的方法。 结构冒险 数据冒险 控制冒险 43. 请简述Flynn分类法将计算机系统结构分成哪四类。 44.请简述程序局部性原理。 45.请简述Amdahl定律。 例题： 46.影响CPU时间的因素包括什么？（提示：从CPU公式入手，考虑3个参数的影响因素） 47.请简要说明提高计算机系统并行性的3种技术途径，并分别从单机和多机系统的角度举例。 48.请说明什么是静态调度？什么是动态调度？动态调度的优点是什么？ 49. 请简述Tomasulo算法的基本思想，并分析其局限性。 例题，详见PPT 50.请说明什么是动态分支预测？有何优点？ 51.请简述分支历史表BHT的基本思想。 52.请简述分支目标缓冲器BTB的基本思想。 53.请简述基于硬件的前瞻算法基本思想。 54.请在PVP、SMP、MPP、DSM和COW中任选一种，简要描述其特点。 55.什么是多处理机Cache一致性问题？ 56.请简述监听式协议的原理。 57.请简述目录式协议的原理。（自学） 58. 请比较说明写作废协议和写更新协议性能上的差别。（自学） 59.请解释，在目录式协议中，什么是本地节点、宿主节点、远程节点和共享集合？（自学） 60. 请简述目录式协议中，目录的三种结构。（自学） [TOC] 1.说明计算机系统的层次结构。 P7 常见的五级计算机系统的层次结构 其中软硬件交接界面为操作系统机器和机器语言机器之间 硬件：传统机器M1，微程序机器M0 软件：操作系统级及以上各级虚拟机 翻译器（编译器）将高级语言程序翻译为机器语言程序，而机器语言由操作系统和微程序解释后由硬件执行 2.说明冯诺依曼体系结构的特点。 P8 五大部件：运算器，存储器，控制器，输入设备和输出设备 指令和数据用二进制表示，并以同等地位存放于存储器，按地址寻访 指令由操作码和地址吗组成，顺序存放于存储器所以通常顺序执行 操作码：操作性质 地址码：位置 运算器为中心，但现代计算机以存储器为中心 冯·诺依曼机的基本工作方式是：控制流驱动方式 3.什么是机器字长、指令字长、存储字长? P17 机器字长为CPU一次能处理数据的位数，与寄存器位数有关 指令字长：P304 指令字长为计算机指令所占用的位数，指令字长取决于操作码的长度、操作码地址的长度和操作码地址的个数。 指令流通常是（主存流向控制器） 存储字长通常指一个存储单元存储二进制代码的位数，MDR（Memory Data Registe) 的位数，指数据寄存器中的位数， 4.系统总线包括哪三类？起到什么作用？ P43 总线是连接多个部件的信息传输线，是各部件共享的传输介质 系统总线为总线的一种，根据传输信息的不同分为三种 数据总线：传输各功能部件之间的数据信息，双向传输，位数与机器字长，存储字长有关，同时位数成为宽度 地址总线：数据地址或设备地址，指明CPU访问的地址，由CPU输出，单向传输，位数与存储单元个数有关 控制总线：发出控制信号，单向或者双向，对于CPU有输入和输出 5.总线判优控制是解决什么问题的？总的来说可以分为哪两种方式？ P57 若多个主设备同时要使用总线时，由总线判优控制按一定优先级顺序确定哪个主设备能使用总线 总线判优控制解决多个部件同时申请总线时的总线使用权分配问题 集中式和分布式 6.集中式总线控制优先权仲裁方式有哪三种？各有什么特点？ P57 链式查询方式 线路结构简单，容易扩充设备 对电路故障敏感，优先级固定，优先级别低的设备难获得请求 计数器定时查询 优先级设置灵活，对电路故障不那么敏感 增加了控制线，n个设备大约需要⌈ log_2⁡n ⌉+2条控制线，控制较复杂 独立请求方式 响应速度快，优先次序控制灵活 控制线多，设备 n 个，则需要 2n+1 条控制线，其中的 1 是指反馈线，控制逻辑复杂 7.简述总线周期的4个阶段。 P59 总线周期：完成一次总线操作的时间 申请分配：主模板申请，经总线仲裁机构决定下一传输周期的总线使用权授予某一申请者。 寻址：取得了使用权的主模块通过总线发出本次要访问的从模块（或从设备）的地址及有关命令，启动参与本次传输的从模块。 传数：主模块和从模块进行数据交换，数据由源模块发出，经数据总线流入目的模块。 结束：撤除主模板信息，让出总线使用权 8.总线通信控制是解决什么问题的？总的来说有哪几种控制方式？各自的特点是什么？ P59 主要解决通信双方如何获知传输开始和结束，协调配合的问题 总线传输周期：连接在总线上的两个部件完成一次完整且可靠的信息传输时间 同步通信： 统一时标（通常由CPU的总线控制部件发出），一般由系统时钟决定 规定明确统一，模块间的配合简单一致 强制性同步，影响效率，设计局限性，不灵活 用于总线长度短，各部件存取时间比较一致 数据传输率与传输周期和数据位数有关 例题 异步通信： 允许各模板速度不一致，采用应答方式（握手方式） 分为不互锁，半互锁，全互锁 半同步通信： 地址，命令，数据信号发出时间参照系统时钟某个前沿，接收方采用系统时钟后沿时刻判断识别 允许不同速度各模板工作，并通过（WAIT)响应信号线或采用插入时钟（等待）周期协调 用于系统工作速度不高但又包含速度差异较大的各类设备组成的简单系统 控制比异步简单，可靠性较高，同步结构较简单 系统时钟频率低，速度较慢 分离式通信： 各模板需要申请 限定时间传送信息，采用同步方式，不等待回答 准备数据不占用总线 控制复杂 9.串行传输和并行传输有何区别？各适用于什么场合？ P?? 串行传输： 一条数据线，一位一位依次传输，数据的各个比特（bit）是按照时间序列逐个发送和接收的 传输效率低 适用于长距离，减少衰减 通常用于计算机与外部设备（如打印机、鼠标、键盘）的通信，以及远距离通信（如网络连接、无线通信）。 并行传输： 数据线多条，成组传输 传输效率高 适用于短距离通信，因为随着线路长度的增加，信号同步和干扰问题会变得更严重。 并行传输适用于需要快速传输大量数据的场合，如内存模块、主板内部的总线、打印机的打印头与控制电路之间的数据传输。 10.试比较RAM和ROM。 P69 RAM（随机存取存储器）: 随机访存，存储时间与物理位置无关，可读可写 主存采用，主要用于存储临时数据和程序，是CPU执行程序时的工作空间。它允许快速访问和频繁的数据更新。 速度快于ROM，但成本较高且有易失性 ROM（只读存储器）： 存储固件或系统软件，一般不允许用户修改 用于存储不需要频繁更改的系统级软件，如BIOS或固件，这些软件在系统启动时加载到RAM中。 速度较慢，但成本相对较低 11.从实现技术的角度，试比较SRAM和DRAM。 P76 静态 RAM (Static RAM, SRAM)： 用触发器工作原理存储信息，断电易失去信息，但不需要刷新 由 MOS 管组成基本单元电路 速度快，但成本较高 动态 RAM (Dynamic RAM, DRAM)： 电容存储电荷的原理寄存信息，需要刷新 基本单元电路有三管式和单管式两种 集成度高，相同价格容量大于SRAM，但是速度较慢，且功耗较高 12.存储芯片内的地址译码方式有几种？各自特点及应用场合？ P75 线选法： 一根字选择线直接选中一个存储单元的各位（如一个字节） 结构简单，用于容量不大的存储芯片 当容量变大时，需要的地址线指数级增多 重合法： 又称为二维地址译码 通常由行地址译码器（X译码器）和列地址译码器（Y译码器）组成 行和列的交汇处共同锁定一个单元，适用于大容量存储芯片 重合法可以提高存储器的集成度和存储密度 结构较复杂 13.什么是动态RAM的刷新？刷新有几种方式？简要说明之。 P85 刷新的过程实质上是先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程 通常有三种方式刷新：集中刷新、分散刷新和异步刷新。 集中刷新： 规定刷新周期，集中刷新全部存储单元 存在“死区”，无法进行读写操作 分散刷新： 指对每行存储单元的刷新分散到每个存取周期内完成 不存在停止读写操作的死时间，但存取周期长，系统速度降低 异步刷新： 结合上述两种方法 缩短了‘死区’时间，又充分利用最大刷新间隔为2ms 如果将动态 RAM 的刷新安排在 CPU 对指令的译码阶段，由于这个阶段 CPU 不访问存储器，所以这种方案既克服了分散刷新需独占 0.5 µs 用于刷新，使存取周期加长且降低系统速度 的缺点，又不会出现集中刷新的访存“死区”问题，从根本上提高了整机的工作效率。 14.存储容量扩展有哪几种方法？ P91 通常有位扩展和字扩展，字位扩展 位扩展： 增加存储字长 字扩展： 增加存储器字的数量 字、位扩展： 指既增加存储字的数量，又增加存储字长 例题！！！P94 15.使用汉明码进行校验时，需要增加k位检测位，且k位的检测位和n位的待检测二进制代码位之间要满足什么关系？为什么？ P100 2^k ≥ n+k+1 16.已知收到的海明码为0100111（按配偶原则配置），试问欲传送的信息是什么？ P1 = 1⊕3⊕5⊕7 = 0 P2 = 2⊕3⊕6⊕7 = 1 P4 = 4⊕5⊕6⊕7 = 1 P4P2P1 = 110 (110)2=6->第六位出错，纠正为 0100101，故要求传送的信息为 0101 17.什么是多体并行存储器？有哪两种存储体编址方式，各自有什么特点？ P104 多体模块组成的存储器 每个模块有相同容量和存取速度 各模块有独立的的地址寄存器 (MAR) 、数据寄存器 (MDR) 、地址译码、驱动电路和读／写电路 并行工作，交叉工作 两种存储体编址方式：高位交叉编址和地位交叉编址 高位交叉： 高位地址表示体位，低位地址为体内地址 顺序存储 低位交叉： 低位地址表示体位，高位地址为体内地址 模M编址 例题： 18.Cache、主存和辅存构成的三级存储系统分别的目的是什么？设计依据是？ P109 Cache-主存层次： 解决 CPU 和主存速度不匹配的问题 程序访问的局部性原理 缓存的速度比主存的速度高 主存-辅存层次： 解决存储系统的容量问题 辅存的速度比主存的速度低，而且不能和 CPU 直接交换信息，但它的容量比主存大得多，可以存放大量暂时未使用得信息。 当 CPU 需要用到这些信息时，再将辅存的内容调入主存，供 CPU 直接访问。 主存和辅存之间的数据调用是由硬件和操作系统共同完成的。 19.请简述Cache的基本工作原理。 P110 任何时刻都有一些主存块处在缓存块中 需要的字已经在缓存中，即可直接访问 Cache（命中） 需的字不在 Cache 内，此时需将该字所在的主存整个字块一次调入 Cache 中（未命中) 每个缓存块需设一个标记 ，表示当前存放的是哪一个主存块，该标记的内容相当于主存块的编号。 关于命中率： 命中率h=Nc/(Nc+Nm)，或者 Nc/N Nc 为访问 Cache 的总命中次数，Nm为访问主存的总次数，N为访问总次数 例题： 关于Cache容量： 20.试比较主存-Cache管理中三种地址映射的方法，并分别给出在三种地址映射下，主存地址划分。 P117 由主存地址映射到 Cache 地址称为地址映射。 直接映射（固定的映射关系）、全相联映射（灵活性大的映射关系）、组相联映射（上述两种映射的折中）。 直接映射： 每个主存块只与一个缓存块相对应 实现简单，利用主存地址某些位直接判断 但不够灵活，如果重复访问对应同一缓存位置的不同主存块，就要不停替换，从而降低了命中率 全相联映射： 允许主存中每一字块映射到 Cache 中的任何一块位置上。 方式灵活，命中率较高，并缩小了块冲突率 逻辑电路多，成本高 组相联映射： 直接映射和全相联映射的一种折中。把 Cache 分成 Q 组，每组 R 块 组相联映射的性能及其复杂性介于直接映射和全相联映射两者之间 例题： 直接映射 各种映射 21.Cache-主存间的替换策略有哪些，请简述。 P122 当新的主存块需要调入 Cache 并且它的可用空间位置又被占满时，需要替换掉 Cache 的数据，这就产生了替换策略（算法）问题 常用的替换算法有先进先出算法、近期最少使用算法和随机法。 先进先出 (First-In-First-Out, FIFO) 算法 选择最早调入的Cache的字块进行替换 容易实现，开销小 但没有根据访存的局部性原理，故不能提高 Cache 的命中率 近期最少使用 (Least Recently Used, LRU) 算法 比较好地利用访存局部性原理，替换出近期用得最少的字块 需要记录Cache中各字块使用情况 比较复杂，一般采用简化的方法，只记录每个块最近一次使用的时间 LRU 算法的平均命中率比 FIFO 的高 随机法 随机确定被替换的块 采用一个随机数产生器 22.发生主存写请求时，如何保证Cache和主存的一致性？ P113 对于写操作，对 Cache 块内写入的信息，必须与被映射的主存块内的信息完全一 致 写直达法 (Write-through) ，又称为存直达法（ Store-through) 写操作时数据既写入 Cache 又写入主存 随时保证主存和 Cache 的数据始终一致，但增加了访存次数 写操作时间就是访问主存的时间，读操作时不涉及对主存的写操作，更新策略比较容易实现 写回法 (Write-back) ，又称为拷回法 (Copy-back) 写操作时只把数据写入 Cache 而不 写入主存，但当 Cache 数据被替换出去时才写回主存 为了识别 Cache 中的数据是否与主存一致， Cache 中的每一块要增设一个标志位 写操作时间就是访问 Cache 的时间，读操作 Cache 失效发生数据替换时，被替换的块需写回主存，增加了 Cache 的复杂性 关于两者的对比 23.影响Cache-主存层平均访问时间的因素有哪些？如果降低平均访存时间，可以怎么办？ P?? 缓存命中率 缓存未命中的访问时间 缓存结构 缓存替换策略 缓存块大小 写策略 降低平均访存时间： 增加缓存容量 提高缓存的相联度 优化缓存替换策略 调整缓存块大小 使用预取技术 多级缓存设计 缓存行（Cacheline）对齐 合理利用写策略 24.I/O地址码的编制方式有哪两种？ P159 通常将 I/O设备码看作地址码 对 I/O地址码的编址可采用两种方式：统一编码和不统一编码 统一编址 将I/O地址看作存储器地址的一部分 对I/O设备的访问，所用指令与访存指令相似 占用了存储空间，减少了主存容量，无需专用的I/O指令 不统一编址 I/O地址和存储器地址分开 访问I/O有专用的指令 不占用存储空间，不影响主存容量，需专用的I/O指令 25.I/O与主机交换信息有哪几种控制方式？各有何特点？ P161 I/O 设备与主机交换信息时，共有5种控制方式：程序查询方式、程序中断方式、直接存储器存取方式 (DMA) 、I/0 通道方式、 I/0 处理机方式。 程序查询方式 CPU不断查询I/O设备是否已做好准备，从而控制I/O设备与主机交换信息 求 I/O 接口内设置一个能反映 I/O 设备是否准备就绪的状态标记 主机和I/O串行工作 CPU反复查询过程中停止工作，效率低 CPU从设备取出数据时停止工作，CPU和I/O串行工作 工作示意图： 程序中断查询： CPU启动I/O设备后不查询设备是否准备就绪，继续执行自身程序 I/O准备就绪后发送中断请求 CPU响应I/O请求后，中断现行程序，转至中断服务程序，占用了CPU内部的一些寄存器 处理完信息交换，回到原程序断点处，继续执行 CPU向I/O 设备发读指令后，仍在处理其他事情（如继续在算题），消除了“踏步”行为 CPU 执行程序与 I/0 设备做准备是同时进行的，充分利用了CPU资源 对于程序中断方式，硬件需要增加相应电路，软件方面需要编制中断服务程序 工作示意图： DMA方式： I/O设备与主存直接交换信息，而不占用CPU 主存与 I/O 设备之间有一条数据通路 若出现 DMA 和CPU 同时访问主存， CPU 总是将总线占有权让给 DMA, 通常把 DMA 的这种占有称为窃取或挪用，一般为一个存取周期，又称为窃取周期或挪用周期 在 DMA 窃取存取周期时， CPU 尚能继续做内部操作（如乘法运算），只是让出总线使用权 采用 DMA 方式时，也需要增加必要的 DMA 接口电路 工作示意图： I/O通道 通道是用来负责管理I/O设备以及实现主存与 I/O 设备之间交换信息的部件，可以视为一 种具有特殊功能的处理器。 通道有专用的通道指令，能独立地执行用通道指令所编写的输入输出程序，但不是一个完全独立的处理器 依据 CPU 的 I/O 指令进行启动、停止或改变工作状 态，是从属于 CPU 的一个专用处理器 依赖通道管理的 I/O 设备在与主机交换信息时，CPU 不直接参与管理，故提高了 CPU 的资源利用率。 I/O处理机 I/O 处理机又称为外围处理机(Per ipheral Processor) ，它基本独立于主机工作，既可完成 I/O 通道要完成的 I/O 控制，又可完成码制变换，格式处理，数据块检错、纠错等操作 具有 I/O处理机的输入输出系统与 CPU工作的并行性更高，这说明 I/0 系统对主机来说具有更大的独立性。 26.I/O接口有什么作用。 P185 接口可以看作两个系统或两个部件之间的交接部分，它既可以是两种硬设备之间的连接电路，也可以是两个软件之间的共同逻辑边界 I/O接口通常是指主机与 I/O 设备之间设置的一个硬件电路及其相应的软件控制。 不同的 I/O 设备都有其相应的设备控制器，而它们往往都是通过 I/O 接口与主机取得联系的。 一台机器通常配有多台 I/O 设备，它们各自有其设备号（地址），通过接口可实现I/O设备的选择。 I/O 设备种类繁多，速度不一，与 CPU 速度相差可能很大，通过接口可实现数据缓冲，达到速度匹配。 有些 I/O 设备可能串行传送数据，而 CPU 一般为并行传送，通过接口可实现数据串－并格式的转换 I/O 设备的输入输出电平可能与 CPU 的输入输出电平不同，通过接口可实现电平转换。 CPU 启动 I/O 设备工作，要向 I/O 设备发各种控制信号，通过接口可传送控制命令。 I/O 设备需将其工作状态（如“忙＂”就绪”“错误”“中断请求”等）及时向 CPU 报告，通过接口可监视设备的工作状态，并可保存状态信息，供 CPU 查询。 注意，接口和端口是两个不同的概念 端口是指接口电路中的一 些寄存器，这些寄存器分别用来存放数据信息、控制信息和状态信息，相应的端口分别称为数据端口、控制端口和状态端口。若干个端口加上相应的控制逻辑才能组成接口。 接口的分类：P188 按数据传送方式分类，有并行接口（一个字节或一个字的所有位同时传送和串行接口（一位一位传送）两类。 按功能选择的灵活性分类，有可编程接口和不可编程接口两种 按通用性分类有通用接口和专用接口 按数据传送的控制方式分类，有程序型接口和 DMA 型接口 27.程序查询方式和程序中断方式都由程序实现外围设备的输入输出，它们有何不同？ P189 程序查询方式的核心问题在于每时每刻需不断查询 I/O设备是否准备就绪。 程序查询方式是用户在程序中安排一段输入输出程序，它由 I/O 指令、测试指令和转移指令等组成。 CPU 一旦启动 I/O 后，就进入这段程序，时刻查询 I/O 准备的情况，若未准备就绪就踏步等待；若准备就绪就实现传送。在输入输出的全部过程中，CPU 停止自身的操作。 计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行， 转向对这些异常情况或特殊请求的处理，处理结束后再返回到现行程序的间断处，继续执行原程序，这就是“中断＂ 程序中断方式虽也要用程序实现外部设备的输入、输出，但它只是以中断服务程序的形式插入到用户现行程序中。即 CPU 启动 I/O 后，继续自身的工作，不必查询 I/O 的状态。而 I/O 被启动后，便进入自身的准备阶段，当其准备就绪时，向 CPU 提出中断请求，此时若满足条件，CPU 暂停现行程序，转入该设备的中断服务程序，在服务程序中实现数据的传送。 28.以I/O设备的中断处理过程为例，说明一次程序中断的全过程。 P198 由CPU发启动 I/O 设备指令，将接口中的 B 置“1”，D 置“0” 接口启动输入设备开始工作 输入设备将数据送入数据缓冲寄存器 输入设备向接口发出“设备工作结束”信号，将 D 置为“1”，B 置为“0”，标志设备准备就绪 当设备准备就绪(D=1)，且本设备未被屏蔽(MASK=O)时，在指令执行阶段的结束时刻，由 CPU 发出中断查询信号 设备中断请求触发器 INTR 被置为“1”'，标志设备向 CPU 提出中断请求。与此同时，INTR 送至排队器，进行中断判优 若 CPU 允许中断(EINT=1)，设备又被排队选中，即进入中断相应阶段，由中断响应信号 INTA 将排队器输出送至编码器形成向量地址 向量地址送至 PC，作为下一条指令的地址 由于向量地址中存放的是一条无条件转移指令，故这条指令执行结束后即无条件转至该设备的服务程序入口地址，开始执行中断服务程序，进入中断服务阶段，通过输入指令将数据缓冲寄存器的输入数据送至 CPU 的通用寄存器，再存入主存相关单元 中断服务程序的最后一条指令是中断返回指令，当其执行结束后，即中断返回至原程序的断点处。至此，一个完整的程序中断处理过程即告结束 综上所述，可将一次中断处理过程简单地归纳为中断请求、中断判优、中断响应、中断服务和 中断返回 5个阶段。 其中中断服务程序分为四大部分：保护现场、中断服务、恢复现场、中断返回 29.在DMA方式中有没有中断请求，为什么？DMA接口电路中应设置哪些硬件。 P200 DMA有中断请求，只是数据不通过CPU。DMA控制器在传送完所有字节时，通过中断请求线发出中断信号。CPU在接收到中断信号后，转入中断处理程序进行后续处理。 必须注意，这里的中断与 5.5 节介绍的 I/O 程序中断方式的技术相同，但中断的目的不同，前面是为了数据的输入或输出，而这里是为了报告一批数据传送结束。它们是 I/O 系统中不同的中断事件。 硬件：P204 补充DMA接口功能： 申请传送 处理总线控制权转交 管理总线 修正数据地址和地址长度 给出操作完成信号 主存地址寄存器 (AR): AR用于存放主存中需要交换数据的地址。 传送数据前，将数据在主存中的首地址送到AR 传送过程中，每交换一次数据，AR内地址加一，知道一批数据传送完 字计数器 (WC)： WC用于记录传送数据的总字数，通常以交换字数的补码值预置 传送过程中，每传送一个字，WC加一，直到WC为0（最高位产生进位），表示传送完毕 最后DMA发送中断请求信号 数据缓冲寄存器 (BR) BR 用于暂存每次传送的数据 DMA 控制逻辑 DMA 控制逻辑负责管理 DMA 的传送过程，由控制电路、时序电路及命令状态控制寄存器等组成。 设备准备好数据字，向DMA接口提出申请（DREQ），DMA 控制逻辑向CPU发出总线使用权的请求信号 (HRQ) DMA 控制逻辑收到CPU响应信号HLDA,DMA 控制逻辑负责管理DMA传送全过程 中断机构 当字计数器溢出（全 “0”) 时，表示一批数据交换完毕，由＂溢出信号“通过中断机构向 CPU 提出中断请求，请求 CPU进行DMA 操作的后处理。 设备地址寄存器 (DAR) DAR 存放 I/O 设备的设备码或表示设备信息存储区的寻址信息 30.DMA方式中的中断请求和程序中断中的中断请求有何区别？ P208 从数据传送看，程序中断方式靠程序传送，DMA 方式靠硬件传送 从 CPU 响应时间看，程序中断方式是在一条指令执行结束时响应，而 DMA 方式可在指令周期内的任一存取周期结束时响应。 程序中断方式有处理异常事件的能力，而 DMA 方式没有这种能力，主要用于大批数据的传送， 程序中断方式需要中断现行程序，故需保护现场；DMA 方式不中断现行程序，无须保护现场 DMA 的优先级比程序中断的优先级高 31.DMA和主存交换数据时有哪三种方法？分别简述。 P201 DMA 方式中，由于 DMA 接口与 CPU 共享主存，这就有可能出现两者争用主存的冲突。 为了有效地分时使用主存，通常 DMA 与主存交换数据时采用如下三种方法：停止CPU访问主存、周期挪用（周期窃取）、交替访问 停止CPU访问主存方式 传送数据时，DMA向CPU发一个停止信号，要求CPU放弃总线控制 控制简单，，适用千数据传输率很高的 I/O设备实现成组数据的传送 缺点是 DMA 接口在访问主存时， CPU 基本上处于不工作状态或保持原状态。 周期挪用（周期窃取）方式 DMA请求时，I/O设备挪用或窃取总线占用权一个或几个主存周期，无请求，CPU继续访存 与CPU 暂停访存的方式相比，这种方式既实现了 I/O 传送，又较好地发挥了主存与 CPU 效率，是一种广泛采用的方法。 应该指出， I/O设备每挪用一个主存周期都要申请总线控制权、建立总线控制权和归还总线控制权。 DMA 与CPU 交替访问方式 这种方法适合千 CPU 的工作周期比主存存取周期长的情况。 那么可将一个 CPU 周期分为 C1和C2两个分周期，其中 C1专供 DMA 访存，C2专供 CPU 访存 不需要总线使用权的申请、建立和归还过程，总线使用权是通过C1和 C2 分别控制的 CPU 既不停止主程序的运行也不进入等待状态，就完成了 DMA 的数据传送。但相应的硬件逻辑变得更为复杂。 32.简述DMA的工作过程。 P205 DMA 的数据传送过程分为预处理、数据传送和后处理 3个阶段 预处理：CPU预置信息，由 CPU 执行几条输入输出指令完成，即程序的初始化阶段。之后CPU继续执行原来程序。 给DMA控制逻辑指明数据传送方向是输入（写主存）还是输出（读主存） 向DAR输入设备号，启动设备 向AR送入交换数据的主存起始地址 对WC赋予数据个数 预处理完后，待 I/O 设备得到主存总线的控制权后，数据的传送便由该 DMA 接口进行管理。 数据传送 DMA 方式是以数据块为单位传送的 数据传送后，进入后处理 后处理 DMA的中断请求得到响应，CPU停止原程序转去中断服务程序 校验数据，决定是否继续传送，测试错误 总流程图： 33.DMA接口的类型有哪几种？ P209 现代集成电路制造技术已将 DMA 接口制成芯片，通常有选择型和多路型两类 选择型 DMA 接口 在物理上可连接多个设备，在逻辑上只允许连接一个设备 某一段时间内，DMA接口只为一个设备服务，关键是预处理时DAR的设备号 适用于数据传输率很高的设备 多路型 DMA 接口 不仅在物理上可以连接多个设备，而且在逻辑上也允许多个设备同时工作 设备采用字节交叉传送数据 每个设备有一套寄存器，存放设备参数 又分为链式多路型 DMA 接口和独立请求多路型 DMA 接口 34A.说明补码加/减法运算步骤。（*） P237 加减法运算是计算机中最基本的运算 因减法运算可看作被减数加上一个减数的负值，即 A -B=A +(-B) 采用补码作加减法运算 补码表示的两个数在进行加法运算时，可以把符号位与数值位同等处理 对于加法： 整数 [A]补 +［B]补＝[ A+B]补 (mod 2^n+1) 小数 [A]补 +［B]补＝[ A+B]补 (mod 2^n) 对于减法： 整数 [A-B]补 =[A]补 +［-B]补 (mod 2^n+1) 小数 [A-B]补 =[A]补 +［-B]补 (mod 2^n) 将符号位产生的进位自然丢掉即可。 溢出判断有两种方法：用一位符号位判断溢出、用两位符号位判断溢出 用一位符号位判断溢出： 对于加法，符号不同的两个数相加不会溢出 对于减法，符号相同的两个数相加不会溢出 只要实际两个操作数（减法时即为被减数和“求补”以后的减数）符号相同，结果又与原操作数的符号不同，即为溢出。 计算机中，通常用符号位产生的进位与最高有效位产生的进位(即现符号位）异或操作后，按其结果进行判断。若异或结果为1 ，即为溢出；异或结果为0 ，则无溢出。 用两位符号位判断溢出： 对于变形补码首次出现：P223 两位符号位连同数值一起运算，并且高位进位自动丢失 当2位符号位不同时，表示溢出，否则；无溢出 溢出时，符号位\"01” 表示正溢出,\"10\"则表示负溢出 高位（第 1位）符号位永远代表真正的符号 在计算机中，寄存器和主存中只需1位符号位，双符号在加法器中必要，相加时，寄存器中一位符号的值要同时送到加法器的两位符号位的输入端。 流程： 将两个操作数的补码送入寄存器A和X， 判断是否是加法，是直接（A）+（X）->A,不是下一步 对（-X)求补码，(A)+(-X)->A 最后判断溢出 34B.说明浮点加/减法运算的基本步骤。 P269 补充浮点数： P229 浮点数表示：N=S*r^j S为尾数（可正可负）， j为阶码（可正可负）， r是基数（或基值） 在计算机中规定浮点数的尾数用纯小数形式 此外，尾数最高位为1为规格化数 浮点数由阶码和尾数组成，阶码是整数 阶符和阶码的位数合起来反映浮点数的表示范围及小数点的实际位置； 尾数是小数，其位数反映了浮点数的精度；尾数的符号 Sf 代表浮点数的正负。 浮点数表示范围： 由于浮点数小数点固定，所以尾数加减同定点数 由于阶码反映小数点实际位置，必须阶码相同才可以运算尾数 对阶，使两数的小数点位置对齐 使两操作数的小数点位置对齐，即使两数的阶码相同 求阶差，小阶向大阶看齐，阶数小的尾数右移n位，阶码加n,尾数右移时可能会发生数码丢失，影响精度。 尾数求和，将对阶后的两尾数按定点加减运算规则求和（差）。 同34A,利用补码运算 规格化，为增加有效数字的位数，提高运算精度，必须将求和（差）后的尾数规格化。 当基数为2，尾数S规格化为 1/2 双符号位补码时，当尾数最高数值位和符号位不同即规格化 左规：当尾数出现00.0……或者11.1……时左规，尾数左移一位，阶码减一 右规：当尾数出现01.XXXX或者10.XXXX时，尾数溢出，定点运算中不允许，但浮点数可以右规，尾数右移一位，阶码加一 舍入：对阶合并右规时，尾数低位丢失可能有误差影响精度。舍入提高尾数精度 \"0 舍 1 入“法：类似于四舍五入，尾数右移时，被移去的最高数值位（即当前被移去位）为 0，则舍去；被移去的最高数值位为1 ，则在尾数的末位加 1。如果溢出，右规 “恒置1”法：尾数右移时，不论丢掉的最高数值位是 “1” 或“0\" ，都使右移后的尾数末位恒置 ”1” 。 溢出判断：尾数右规后根据阶码判断。溢出由阶码的符号决定：阶码 01,xx 为上溢。 阶码 10, xx 为下溢，按机器零处理。 流程图： 35A.说明原码乘/除法运算的基本步骤。（*） P243原码乘法运算 笔算乘法的改进，两数相乘可以视为加法和移位。A*B,则A为被乘数，B为乘数 运算过程： 假设有n位乘数，则进行n次加法运算和n次移位运算 由乘数末位确定被乘数是否与部分积相加，1加，0不加。然后相加结果右移一位形成新部分积。同时乘数右移一位形成新末位，最高位放部分积的最低位 加法时，被乘数与原部分积高位相加，低位移至乘数空出最高位 用一个寄存器存放被乘数，一个寄存器存放乘积的高位， 另一个寄存器存放乘数及乘积的低位，再配上加法器及其他相应电路，就可组成乘法器。 原码一位乘法： 乘积符号位由两原码符号位异或决定 接着两原码利用上述规则运算 例子： 硬件配置：三个n+1位寄存器分别存放被乘数，乘数，部分积；移位和加控制电路受乘数末位控制；计数器C控制逐位相乘次数；S存放乘积符号，CM位乘法标记 控制流程： 预处理(运算前)：清空A作为初始部分积，被乘数和乘数送入X和Q,计数器C存放乘数位数 首先通过被乘数和乘数的符号位异或确定乘积的符号位存于S,将被乘数和乘数变为绝对值 根据Qn的状态决定部分积是否加上被乘数，再右移一位重复n次 原码两位乘法（了解） 用两位乘数(ab)的状态决定新部分积： ab=00,原部分积右移两位 ab=01,原部分积加被乘数后右移两位 ab=10,原部分积加2倍被乘数后右移两位 ab=11,原部分积加3倍被乘数后右移两位 除法运算 分析笔算除法： 须通过比较被除数（或余数）和除数绝对值的大小来确定商值，即lxl - lyl ，若差为正（够减）上商1 ，差为负（不够减）上商0。 每次减法总是保持余数不动低位补 ，再减去右移后的除数这一规则，则要求加法器 的位数必须为除数的两倍。所以右移除数可以用左移余数代替 对于计算机，每一位商直接写到寄存器的最低位，并把原来的部分商左移一位 原码除法： 符号位单独处理：商符由两数符号位异或求得，而商值由两数绝对值相除得 小数定点除法对被除数和除数有一定的约束，即必须满足下列条件： 0 避免除数或者被除数为0，前者得无限大，后者得0 商的位数一般和操作数相同 原码除法中由千对余数的处理不同，又可分为恢复余数法和不恢复余数法（加减交替法）两种 恢复余数法： 当余数为负时，需加上除数，将其恢复成原来的余数。 注意：第一次上的商在商的整数位上，这对小数除法而言，可用它作溢出判断。即当该位为 “1” 时，表示此除法溢出，不能进行，应由程序进行处 理；当该位为 “0” 时，说明除法合法，可以进行 恢复余数延长机器除法时间，并且操作不规范 例子： 加减交替法（不恢复余数法） 余数Ri大于零，商上“1”，2*Ri -|y| 余数Ri小于零，商上“0”，2*Ri+|y| 例子： 硬件配置：三个n+1位的寄存器分别存放被除数，除数，余数；移位和加控制逻辑受 Q的末位见控制 (Qn = 1做减法， Qn = 0做加法）;计数器C控制逐位相除次数；CD为除法标记（区别与惩罚标记CM)；Y为溢出标记；S为商符 控制流程： 预处理即除法前：清空Q,被除数和除数输入A和X；计数器C存放被除数的位数； 开始后，异或求商符放到S;被除数和除数变为绝对值 用第一次上商判断溢出，赋值Y 若无溢出，上商，AQ左移一位，根据上一次商值决定加减除数，n次后再上商（一共上商n+1次） 上述为小数除法，对于整数除法，0 35B.说明浮点乘/除法运算的基本步骤。 P274 两个浮点数相乘，乘积的阶码应为相乘两数的阶码之和，乘积的尾数应为相乘两数的尾数之积。 两个浮点数相除，商的阶码为被除数的阶码减去除数的阶码，尾数为被除数的尾数除以除数 的尾数所得的商 阶码运算： 阶码用补码运算，乘积的阶码为 [jx ]补＋ [jy] 补，商的阶码为[jx ]补 - [jy] 补。 同号相加或者异号相减判断溢出 阶码用移码运算： 相加时，必须减去直接相加而多加的2^n(偏移量)，由于真值移码和补码数值相同，符号相反，所以阶码相加可以变为[jx + jy]移 = [jx]移 + [jy]补； 相减时，加数或者减数的符号位取反变为补码，[jx - jy]移 = [jx]移 + [-jy]补 同时移码时，在原有移码符号位的前面（即高位）再增加 1位符号位，并规定该位恒用 “0” 表示，便能方便地进行溢出判断；溢出的条件是运算结果移码的最高符号位为 1。此时若低位符号位为0 ，表示上溢；低位符号位为 1，表示下溢。低位符号位为真正符号位 尾数运算 乘法： 检查0；若有一个为0,乘积为0 用定点小数的任何一种乘法运算，左规时阶下溢，作机器零处理；阶上溢，作溢出处理； 尾数相乘会得到一个双倍字长的结果，若限定只取 倍字长，则乘积的若干低位将会丢失。通常有两个办法作舍入处理 一是截断处理，无条件丢掉正常尾数最低位后全部数值，简单但是影响精度； 二是对于原码采用0舍1入时，“舍”使数的绝对值变小，“入”则大；对于补码，正数同原码，对负数，当丢失全为0，不舍入；当丢失的各位数中的最高位为 0时，且以下各位不全为1 ，或丢失的各位数中的最高位为1 ，且以下各位均为0时，则舍去被丢失的各位；当丢失的各位数中的最高位为1，且以下各位又不全为0时，则在保留尾数的最末位加1修正 除法： 检测被除数是否为0 ，若为0 ，则商为0 ；再检测除数是否为0 ，若为0 ，则商为无穷大，另作处理。 对已规格化的尾数，为了防止除法结果溢出，可先比较被除数和除数的绝对值，如果被除数的绝对值大于除数的绝对值，则先将被除数右移一位，其阶码加1 ，再作尾数相除 ​ 硬件配置： 浮点运算器主要由两个定点运算部件组成 一个是阶码运算部件，用来完成阶码加减，以及控制对阶时小阶的尾数右移次数和规格化时对阶码的调整； 另一个是尾数运算部件，用来完成尾数的四则运算以及判断尾数是否巳规格化 还需有判断运算结果是否溢出的电路等 36.试比较基址寻址和变址寻址，并举例说明其适用的场合。 P314 基址寻址 设有基址寄存器BR 其操作数的有效地址EA等于指令字中的形式地址与BR中的基地址相加 EA=A+(BR) 隐式基址寻址：在计算机内专门设有一个基址寄存 BR ，使用时用户不必明显指出该基址寄存器，只需由指令的寻址特征位反映出基址寻址即可。 显示基址寻址：显式是在一组通用寄存器里，由用户明确指出哪个寄存器用作基址寄存器，存放基地址。 基址寻址可以扩大操作数的寻址范围，因基址寄存器的位数可以大于形式地址的位数。便可实现对主存空间的更大范围寻访 基址寻址在多道程序中极为有用。用于为程序或数据分配存储空间，用户只需指出哪一个寄存器作为基址寄存器即可，通常由操作系统或管理程序确定基址寄存器的内容，在程序的执行过程中其值是不可变的，以确保系统安全可靠地运行。而指令字中的A 是可变的。 变址寻址： 类似基址寻址，其有效地址 EA 等于指令字中的形式地址 与变址寄存器 IX 的内容相加之和，EA=A+(IX) 只要变址寄存器位数足够，也可扩大操作数的寻址范围 在变址寻址中，变址寄存器的内容是由用户设定的，在程序执行过程中其值可变，而指令字中的 A是不可变的，主要用 于处理数组问题，适合编址循环程序。 变址寻址灵活，还可以与其他寻址方式结合使用。 对于基址寻址和变址寻址的异同 相同 都可用来扩大操作数的寻址范围 区别 基址寻址只要用于为程序或数据分配存储空间，故基址寄存器的内容通常由操作系统或管理程序确定，在程序的执行过程中其值是不可变的，而指令字中的 A 是可变的。在多道程序中极为有用。 在变址寻址中，变址寄存器的内容是由用户设定的，在程序的执行过程中其值可变，而指令字中的 A 是不可变的。主要用于处理数组问题，适合编址循环程序。 37.任意写出五种寻址方式，令EA为有效地址，A为形式地址，写出这五种寻址方式计算有效地址的表达式。 P310 对于指令寻址：它分为顺序寻址和跳跃寻址两种 顺序寻址可通过程序计数器 PC ，自动形成下一条指令的地址；跳跃寻址则通过转移类指令实现。 对于数据寻址：在指令字中设一字段(寻址特征)来指明属千哪一种寻址方式。指令的地址码字段通常都不代表操作数的真实地址，故把它称为形式地址A 。操作数的真实地址称为有效地址EA ，它是由寻址方式和形式地址共同来确定的。 立即寻址： 操作数本身设在指令字内，即形式地址A不是操作数的地址，而是操作数本身，又称之为立即数。中“#”表示立即寻址特标记。 取出指令即可得到操作数，但A的位数限制立即数范围 直接寻址： 指令字中的形式地址A就是操作数的真实地址 EA,即EA=A 寻找操作数比较简单，但A的位数限制范围，而且修改A才能修改EA 隐含寻址： 其操作数的地址EA隐含在操作码或某个寄存器中 少了一个地址有利于缩短指令字长。 间接寻址： 形式地址A指出操作数有效地址的存储单元地址，即EA=(A) 它扩大了操作数的寻址范围，它便于编制程序,但是需要访存多次，延长了指令执行时间 寄存器寻址： 地址码字段直接指出寄存器编号即EA=Ri 寄存器寻址在指令执行阶段无须访存，减少了执行时间。由于地址字段只需指明寄存器编号，故指令字较短，节省了存储空间，因此寄存器寻址在计算机中得到广泛应用。 寄存器间接寻址： 地址码字段Ri的内容不是操作数，而是操作数所在主存单元的地址号，即有效地址 EA= (Ri) 基址寻址： EA=A+(BR)， 详见36. 变址寻址：EA=A+(IX)， 详见36. 相对寻址： EA是将程序计数器 PC 的内容（即当前指令的地址）与指令字中的形式地址相加而成，即 EA=(PC)+A 常被用于转移类指令，转移后的目标地址与当前指令有一段距离，称为相对位移量，它由指令字的形式地址A给出，故 A又称位移量 转移地址不固定, 堆栈寻址： 操作数只能从栈顶地址指示的存储单元 存或取。可见堆栈寻址也可视为一种隐含寻址，其操作数的地址总被隐含在 SP 中。 总结： 立即寻址 直接寻址：EA = A 隐含寻址 间接寻址：EA = (A) 寄存器寻址：EA = R 寄存器间接寻址：EA = (R) 基址寻址：EA = A + (BR) 变址寻址：EA = A + (IX) 相对寻址：EA = (PC) + A 堆栈寻址：EA=(SP) 38.指令中有哪些字段？各有何作用？如何确定各字段的位数？ P300 指令通常由操作码和地址码组成，同时因为数据寻址方式种类较多，中必须设一字段来指明属千哪一种寻址方式，所以指令也可以分为操作码字段、寻址特征字段和地址码字段 操作码： 指明该指令所要完成的操作 通常，其位数反映了机器的操作种类， 也即机器允许的指令条数，所以其位数取决于指令系统的操作种类。 操作码的长度可以是固定的，也可以是变化的 地址码： 地址码用来指出该指令的源操作数的地址（一个或两个）、结果的地址以及下一条指令的地址。这里的“地址”可以是主存的地址，也可以是寄存器的地址，甚至可以是I/0设备的地址。 有寻找特征字段时，地址码字段和寻址特征字段共同指出操作数或指令的有效地址 其位数与寻址范围有关 寻址特征字段： 数据寻址方式种类较多，在指令字中必须来指明属千哪一种寻址方式 其位数取决于寻址方式的种类。 相关例题：P322!!! 39.RISC和CISC指令系统各自的特点。 P329 RISC 即精简指令系统计算机(Reduced Instruction Set Computer) : 简单地精简其指令集，用 20％的简单指令的组合来实现不常用的 80％的那些指令功能 控制器采用组合逻辑控制，不用微程序控制。 指令长度固定，指令格式种类少，寻址方式种类少。 多个通用寄存器。 除了存取数之外其余指令的操作都在寄存器内完成。 大部分指令在一个时钟周期内完成 寄存器窗口重叠技术 逻辑简单，设计出错可能性小，有错时也容易发现，可靠性高。 优化编译来更有效地支持高级语言程序 CISC即复杂指令系统计算机(Complex Instruction Set Computer) ： 微程序控制 指令丰富、功能强大 寻址方式灵活 RISC优点： 充分利用 VLSI 芯片的面积 提高计算机运算速度 便于设计，可降低成本，提高可靠性 有效支持高级语言程序 改变教材为计算机组成与设计（软硬件接口）第五版（中文版）(1) 40.请简述MIPS指令系统的R型、I型和J型指令格式，并举出指令实例。 P55 寄存器指令（R型指令）： 操作数（6bits），两个源操作数寄存器（5bits共10bits)，目的寄存器（5bits)，位移量（5bits)，功能（6bits)。一般R型指令op为000000，由funct决定操作种类 举例：add $t0 ,$s1,$s2 将寄存器s1和寄存器s2的数相加送到目的寄存器t0 立即数指令（I型指令）： 操作数（6bits），源操作数寄存器（5bits)，目的寄存器（5bits),constant or address（16bits) 对于常数constant取值范围为-2^15 ~~ +2^15 - 1 对于有效地址EA为address偏移加上rs中的基址（基址寻址） 举例：lw $t0,32($s3) 或 Sw $t0,32($s3) 这里， 19 (寄存器 $s3) 存放于 rs 字段， 8 (寄存器 $t0) 存放千 rt 字段， 32 存放于 address 字段。 注意，对于这条指令 rt 字段的意思已经改变： 在一条lw取字指令中， rt字段用于指明接收取数结果的目的寄存器 P76 跳转指令 （J型指令） J 型除了6位操作码之外，其余位都是地址字段 举例：j 10000 ；跳转指令到10000。Target address=10000 或者 Target address = PC : (address × 4) 补充：对于分支指令为I型指令 其中寄存器为程序计数器 (Program Counter, PC) 这种分支寻址形式称为 PC相对寻址 (PC-relative addressing) ：一种寻址方式， 它将PC 和指令中的常数相加作为寻址结果 判断条件：（rs）== （rt）则转移，（rs）！= （rt）则转移 当（rs）>（rt）则转移,（rs） 41.在MIPS指令子集实现的时候，如何从单周期数据通路构造流水线？ P182 流水线 (pipelining) 是一种实现多条指令重叠执行的技术，是一种在顺序指令流中利用指令间并行性的技术 将单周期数据通路分成IF,ID,EX,MEM,WB五个阶段，并在每两个阶段之间加上流水寄存器。 对于一个 MIPS指令包含如下5个处理步骤： IF: 从指令存储器中读取指令 ID: 指令译码的同时读取寄存器。 MIPS 的指令格式允许同时进行指令译码和读寄存器 EX: 执行操作或计算地址 MEM: 从数据存储器中读取操作数 WB: 将结果写回寄存器 教材的图： 在两个阶段之间，即上图各级间有分割线的地方需要加入寄存器，又被称为流水线寄存器 保留之前周期中产生的结果信息，以供本阶段使用 需要注意：写回阶段的后面没有流水线寄存器 对于装载指令（lw)的五个阶段 iF(取指令)： 使用PC中的地址从指令储存器读取指令 指令放入IF/ID流水线寄存器 PC+4放入IF/ID流水线寄存器以备后序指令使用（beg) ID(译码读寄存器堆)： 一个16位的立即数（可扩展为带符号的32位数）和两个寄存器号（rs和rt用于读取寄存器）读出来的数据,以及PC+4一起存入ID/EX 流水线寄存器 EX(执行和计算)： 读取由寄存器传过来的值以及经符号扩展后的立即数，并用 ALU 将它们相加，结果存入EX/MEM 流水线寄存器中 MEM（访存）： 使用从 EX/MEM 流水线寄存器中得到的地址读取数据存储器，并将数据存入MEM/WB流水线寄存器中 WB（写回）： 从 MEM/WB 流水线寄存器中读取数据 并将它写回图中部的寄存器堆。 对于存储指令（sw)的五个阶段 IF: 利用 PC 中的地址从存储器中读出指令，然后将指令放入IF/ID流水线寄存器 中 ID: IF/ID 流水线寄存器中的指令包括用于读取寄存器的两个寄存器号读出来的数据和用千符号扩展的 16 位立即数。 读出的两个寄存器值和符号扩展后的32 位立即数 都存放在ID/EX 流水线寄存器中。 EX: 计算有效地址存放在 EX/MEM 流水线寄存器中 MEM： 值得注意的是，需要写入存储器的数据在较早的流水级（ID/EX流水寄存器）中已经读出并存放在 ID/EX 中。 WB: 存储指令在写回步骤中不做任何事情。 42.流水线中有哪三种冒险？请简述，并至少举出一种解决冒险的方法。 流水线 定义：在下一个时钟周期中下一条指令不能执行的情形，称为冒险 结构冒险： 需要的资源被占用 数据冒险： 需要等待前面指令完成其数据读写操作 控制冒险：根据前面正在执行的指令决策控制操作 结构冒险 本质上是一个硬件层面的资源竞争问题，也就是一个硬件电路层面的问题 CPU在同一个时钟周期，同时在运行两条计算机指令的不同阶段。但是这两个不同的阶段，可能会用到同样的硬件电路 典例：对于内存的数据访问，即存储器发生结构冒险（存、取冲突） 具体来说， Load/Store对存储器读/写数据时都要进行内存数据的读取即同一个时钟周期两个读取不同内存地址的信号 解决方案： 流水线的数据通路需要将指令和数据分别存储,让它们各有各的地址译码器 这样把内存拆成两部分的解决方案，在计算机体系结构里叫做哈佛结构 ​ 2. 在CPU 内部的高速缓存部分进行了区分，把高速缓存分成了指令缓存（Instruction Cache）和数据缓存（Data Cache）两部分。指令缓存和数据缓存的拆分，使得我们的CPU在进行数据访问和取指令的时候，不会再发生资源冲突的问题了 ​ 3. 指令集设计 ​ 4. 让流水线发生停顿，即产生空泡（Bubble或Stall） 对于寄存器发生结构冒险（读、写冲突） 解决方案： （读、写分离），让前半个时钟周期进行写操作，后半个时钟周期进行读操作，同时在寄存器上分别设置单独的读写接口 让流水线发生停顿，即产生空泡（Bubble或Stall） 数据冒险 本质上，数据冒险就是同时在执行的多个指令之间，有数据依赖的情况 对于这些数据依赖： 先写后读（Read After Write，RAW），典型数据依赖 寄存器先执行写操作后执行读操作，但是此时还未写回，产生RAW数据冲突 指令i生成的结果可能会被指令j用到 指令j数据依赖于指令k，指令k数据依赖于指令i 先读后写（Write After Read，WAR），反依赖 寄存器先执行读操作后执行写操作，但是此时还未读取，产生WAR数据冲突 当指令j对指令i读取的寄存器或存储地址执行写操作是，就会在指令i和指令j之间发生反依赖(antidependence)。 写后再写（Write After Write，WAW），输出依赖 寄存器先执行写操作后又执行写操作，但是此时还未写回，产生WAW数据冲突 当指令i和指令j对同一个寄存器或存储地址执行写操作时，发生输出依赖(output dependence)。 对于反依赖和输出依赖，可以利用寄存器换名消除依赖。详见Tomasulo算法。 先写后读（Read After Write，RAW），典型数据依赖 存在这样的指令，必须依赖于之前访问数据的指令完成 sub $2, $1, $3 //Register $2 written by sub and $12, $2, $5 //1st operand($2) depends on sub or $13, $6, $2 ///2nd operand($2) depends on sub add $14, $2, $2 //1st($2) & 2nd($2) depend on sub sw $15, 100($2) //Base ($2} depends on sub and指令需要s2寄存器的值，但是sub还没有将新的值写入s2寄存器， 即后一条指令需要使用计算后的结果,又称sub-and为EX冒险中的1a类 判断条件： ID/EX. RegiserRs 表示 一个需要流水线寄存器 ID/EX 获得的源寄存器号 EX/MEM. RegisterRd 字段是 ALU 指令（来自 Rd 字段）或装载指令（来自 Rt字段） 的目标寄存器号 这种情况是将前一条指令的结果旁路到任何一个ALU输入中。 如果前一条指令要写寄存器堆且要写的寄存器号与ALU输入要读的寄存器号 (A 或B) 一致（只要不是寄存器0)， 那么就调整多选器从流水线寄存器EX/MEM 中读取数值。（寄存器0为特殊寄存器，只读不写） 同理，sub-or是MEM冒险中的2b类 这种情况是将前面第二条条指令的结果旁路到任何一个ALU输入中。如果前第二条指令要写寄存器堆且要写的寄存器号与ALU输入要读的寄存器号 (A 或B) 一致（只要不是寄存器0)， 那么就调整多选器从流水线寄存器EX/MEM 中读取数值。（寄存器0为特殊寄存器，只读不写） sub-add 上的两个相关性都不是冒险，因为在add的ID级寄存器堆己能提供相应的数据（前提为读写分离，并且一个周期内先写后读） sub 指令和 SW 指令之间也不存在数据冒险，因为 SW指令在 sub 指令写寄存器$2 后才读取$2。 解决方法 向其间插入空泡(Bubbles)。 前推(Forwarding)：也叫旁路，是从内部寄存器而非程序员可见的寄存器或存储器中提前取出数据。 不用等到结果存储到寄存器后 需要数据通路中转发连接 无法通过转发避免所有阻塞 需要时尚未计算出结果 转发不能解决时间上的后推 当一条指令试图读取一个由前一条装载指令读入的寄存器时，就无法使用旁路解决冒险了 当装载指令后紧跟着一个需要读取它的结果的指令时，必须采用相应的机制阻塞流水线 例如： lw $0, 20(&1) sub $12, $0, $13 解决办法1 插入一个周期的冒泡 解决办法2 代码重排以避免在下条指令中使用装载结果 C code for A = B + E; C = B + F; 补充转发条件： 仅当指令有写回寄存器的操作时才转发：EX/MEM.RegWrite, MEM/WB.RegWrite 仅当指令中的目标寄存器不是$zero才转发：EX/MEM.RegisterRd ≠ 0, MEM/WB.RegisterRd ≠ 0 补充双重冒险情况 add $1, $1, $2 add $1, $1, $3 add $1, $1, $4 EX冒险和MEM冒险同时发生时，使用最新结果，所以修订MEM冒险条件 只在EX 冒险条件不为真的时候，转发 补充阻塞和冒泡 将ID/EX 寄存器中的控制变量的值置为0，即EX, MEM and WB 空操作 又称为空指令：一种不进行任何操作或不改变任何状态的指令。 阻止更新PC 和IF/ID 寄存器中的值 将执行中的指令重新解码 再次取出后续指令 对lw指令阻塞1个周期后允许MEM读取数据，接下来可以转到EX段 最后的带有冒险检测的数据通路 控制冒险 决策依赖于一条指令的结果，而其他指令正在执行中。 比如说分支跳转指令，分支决定控制流程 取下一条指令依赖于分支计算结果 流水线并不总是能够取到正确的指令 这种为了确保预取正确指令而导致的延迟叫作控制冒险 (control hazard) 或分支冒险 ( branch hazard) 解决办法 分支阻塞：在取下一条指令前一直等待分支计算结果 分支预测 对于上述分支阻塞，阻塞惩罚不可取，延长流水线并不能提前确定分支结果 所以预测分支结果，仅在预测错误时，才发生阻塞 具体有静态分支预测和动态分支预测 静态分支预测 基于典型的分支动作，例如：循环和if状态跳转 向后预测已经使用的分支 向前预测没有使用的分支 可以在MEM中确定if分支结果 并且通过目标地址加法器，寄存器比较器将分支地址计算提前到 ID 段 动态分支预测 硬件衡量实际的分支行为 ， 例如：保存每条分支的历史记录 假定未来行为将继续当前趋势 。 当预测错误时，发生阻塞，重新取指，并更新历史记录 同时预测位又分为 一位预测位：有缺陷 预测在分支发生90%的情况下，内部循环分支将被错误预测两次 两位预测位：只有连续两次预测错误时才改变预测位 补充：分支延迟时间槽调度， 43. 请简述Flynn分类法将计算机系统结构分成哪四类。 单指令流、单数据流，Single Instruction Stream, Single Data Stream, SISD。 单处理器 指令级并行，如流水线，动态调度，超标量 单指令流、多数据流，Single Instruction Stream, Multiple Data Stream, SIMD 同一指令操纵多条数据流，不同处理器对多个数据项并行处理 每个数据处理器有数据存储器，但是只有一个指令存储器和控制器 向量体系结构，GPU 多指令流、单数据流，Multiple Instruction Stream, Single Data Stream, MISD 每个处理器自已取指令，处理数据 任务级并行 紧密耦合的MIMD结构—线程级并行 松散耦合MIMD结构—集群 多指令流、多数据流， Multiple Instruction Stream, Multiple Data Stream, MIMD 目前为止，没有此种类型的商用机； 脉动阵列 44.请简述程序局部性原理。 定义 程序执行时所访问的存储器地址分布相对地簇聚。 程序执行时间的90%都是在执行程序中10%的代码。（经验规则） 程序即将用到的信息很可能就是目前正在使用的信息。（时间局部性） 程序即将用到的信息很可能与目前正在使用的信息在空间上相邻或者临近。（空间局部性） 所以，重点关注常见情形进行优化 对经常发生的情况采用优化方法的原则进行选择，以得到更多的总体上的改进。 优化是指分配更多的资源、达到更高的性能或者分配更多的电能等 例如 不溢出是经常性事件。针对不溢出的情况进行性能设计 处理器的取值、译码比乘法器用的更加频繁，优先优化取指令和译码 45.请简述Amdahl定律。 定义： 计算机系统的某一部分加速的时候，该加速部分对系统整体性能的影响取决于该部分的重要性和加速程度。 加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间的百分比 Amdahl定律也是一种性能改进的递减规则 如果仅仅对计算任务中的一部分做性能改进，则改进得越多，所得到的总体性能的提升就越有限 重要推论：如果只针对整个任务的一部分进行改进和优化，那么所获得的加速比不超过 指标：加速比--衡量系统的性能改进了多少，即前后执行时间比值（性能 = 1/执行时间） 解释： 可改进比列：在改进前的系统中，可改进部分的执行时间在总的执行时间中所占的比例 部件加速比：可改进部分改进以后，性能提高的倍数。它是改进前所需的执行时间与改进后执行时间的比。 一般情况下部件加速比是大于1的。 公式拓展 例题： 补充：摩尔定律 被称为计算机第一定律。摩尔定律是指单芯片上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍 46.影响CPU时间的因素包括什么？（提示：从CPU公式入手，考虑3个参数的影响因素） 平均指令周期数 ：CPI（Cycle Per Instruction）表示执行某个程序的指令平均周期数，可以用来衡量计算机运行速度。 时钟周期T：也称为振荡周期，定义为时钟频率的倒数，在一个时钟周期内，CPU仅完成一个最基本的动作。 各个参数含义： CPI（Cycle Per Instruction）：表示执行某个程序的指令平均周期数 IC：程序所执行的指令条数 执行一个程序所需的CPU时间 CPU时间 = 执行程序所需的时钟周期数×时钟周期时间 执行程序所需的时钟周期数 = 每条指令执行的平均时钟周期数 CPI ×所执行的指令条数 IC； 时钟周期时间是系统时钟频率的倒数。 其他形式： CPU时间 = IC ×CPI×时钟周期时间 CPU时间 = IC ×CPI×（1/时钟频率） 如何降低CPU时间？ 时钟周期时间：取决于硬件实现技术和计算机组成。 CPI：取决于计算机组成和指令集结构。 IC：取决于指令集结构和编译技术。 47.请简要说明提高计算机系统并行性的3种技术途径，并分别从单机和多机系统的角度举例。 并行性的含义 计算机系统在同一时刻或者同一时间间隔内进行多种运算或操作。即只要在时间 上相互重叠，就存在并行性。 同时性：两个或两个以上的事件在同一时刻发生 并发性：两个或两个以上的事件在同一时间间内发生 三种途径：时间重叠，资源重复，资源共享 时间重叠： 引入时间因素，让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，以加快硬件周转而赢得速度 对于单处理器，可以使部件功能专用化 把一件工作按功能分割为若干相互联系的部分 把每一部分指定给专门的部件完成 按时间重叠原理把各部分的执行过程在时间上重叠起来，使所有部件依次分工完成一组同样的工作 典例：流水线 对于多处理器，可以试处理机专用化 专用外围处理机：分离I/O功能 专用处理机，如数组运算、高级语言翻译、数据库管理 异构型多处理机系统，多个处理机依次完成规定的功能和任务 资源重复 引入空间因素，以数量取胜。通过重复设置硬件资源，大幅度地提高计算机系统的性能 对于单处理机 -重复设置功能部件 多存储体并行 数据/指令独立存储体 重复设置运算部件 多处理机中 –重复设置处理机 容错系统 同构型多处理机系统，由多个同类型或至少担负同等功能的处理机组成，它们同时处理同 一作业中能并行执行的多个任务。（类似GPU） 资源共享 这是一种软件方法，它使多个任务按一定时间顺序轮流使用同一套硬件设备。 如，多道程序。 对于单处理机 分时系统 对于多处理机 分布式系统 补充：单机系统和多机系统中并行性的发展 这张图综合展示了单机系统和多机系统中并行性发展的多种技术和概念。 单机系统并行性发展： 时间重叠：通过技术如指令流水线、先行控制和高速缓存，使得单个处理器能够在时间上重叠处理多个任务，提高处理器的利用率。 资源重复：通过增加多存贮体和多操作部件，使得单机系统能够同时处理更多的任务，实现硬件资源的并行使用。 资源共享：通过多道程序、分时系统和虚拟存贮器等技术，使得多个程序或任务能够共享处理器资源，提高资源的利用率。 多机系统并行性发展： 多终端远程终端：允许多个用户通过远程终端访问计算资源，实现资源共享。 分布处理系统：通过局域计算机网连接多个处理单元，实现任务的分布式处理，提高处理能力和灵活性。 通信处理机：专门用于处理网络通信的处理器，提高网络化并行处理的效率。 多计算机系统： 同构型多处理机：所有处理单元在结构和功能上都是相同的，易于管理和编程。 异构型多处理机：处理单元在结构和功能上有所不同，可以根据任务需求进行优化，提高系统的整体性能。 相联处理机：处理单元之间有特定的连接方式，可以是紧密耦合或松散耦合，影响系统的通信和同步机制。 系统结构： 紧密耦合系统：处理单元之间高度集成，通信和同步机制紧密，适用于需要高速通信和协调的场合。 松散耦合系统：处理单元之间相对独立，通过消息传递进行通信，适用于分布式系统，提高系统的可扩展性和容错性。 专用外围处理机：用于特定任务的处理器，如数据库处理，提高特定任务的处理效率。 功能专用化： 通过将特定功能分配给特定的处理器，可以提高处理效率和性能，适用于需要特定处理能力的应用场景。 网络化： 通过计算机网络实现资源的共享和任务的分布式处理，提高系统的灵活性和可扩展性。 48.请说明什么是静态调度？什么是动态调度？动态调度的优点是什么？ 静态调度 依靠编译器对代码进行调度，也就是在代码被执行之前进行调度； 通过把相关的指令拉开距离来减少可能产生的停顿 动态调度 在程序的执行过程中，依靠专门硬件对代码进行调度，减少数据相关导致的停顿 将ID又分成两个阶段 流出（Issue，IS）阶段：指令译码，检查结构冲突 读操作数（Read Operands，RO）阶段：检测数据冲突，如果没有，继续执行；如果有，等待数据冲突消失，然后读操作数 指令的动态调度导致了指令的乱序执行，指令的乱序执行导致了有反相关和输出相关的指令进入流水线之后产生读后写冲突和写后写冲突 上述问题可以采用寄存器换名技术，消除名相关 补充： 指令顺序执行：指令放入流水线的顺序和指令完成的顺序一致 指令乱序执行：指令放入流水线的顺序和指令完成的顺序不一致，也就是说有些指令进入流水线后被阻塞的，而在其后进入流水线的指令先完成了。 优点： 在指令的执行过程中进行调度，使得无关的指令得以先执行，减少阻塞 处理一些在编译时情况不明的相关（如存储器访问的相关） 使本来是面向某一流水线优化编译的代码在其他的流水线（动态调度）上也能高效地执行,可移植性 缺点： 动态指令调度将会引起指令乱序执行（但是可以使用换名技术消除名相关（包括反相关和输出相关）） 指令乱序完成使得异常处理困难 硬件复杂性的显著增加 49. 请简述Tomasulo算法的基本思想，并分析其局限性。 核心思想： 记录和检测指令相关，操作数一旦就绪就立即执行，把发生RAW冲突的可能性减少到最小 通过寄存器换名来消除WAR冲突和WAW冲突 寄存器换名是通过保留站和流出逻辑来共同完成的 指令流出并且操作数未就绪，将该指令中相应的寄存器号换名为将产生这个操作数的保留站的标识 指令流出到保留站后，其操作数寄存器号换成了数据本身（如果该数据已经就绪），或换成了保留站的标识*，不再与寄存器有关系。 优点： 冲突检测和指令执行控制是分布的 保留站中的信息决定了什么时候指令可以在该功能部件开始执行 计算结果通过CDB直接从产生它的保留站传送到所有需要它的功能部件，而不用经过寄存器 消除了WAW冲突和WAR冲突导致的停顿 使用保留站进行寄存器换名 局限性 实现复杂，需要较高的硬件成本 公共数据总线（CDB）的性能限制：CDB需要进行多个关联比较，每个CDB必须到达多个功能单元，这导致高电容、高布线密度，并且每个周期内完成的功能单元数量有限 需要对Load/Store指令进行重排序：Load指令需要检查所有活跃的Store指令的A字段，而Store指令需要检查早期Load和Store指令的A字段 无法实现分支预测和处理异常 Tomasulo的基本结构 保留站 每个保留站中保存一条已经流出并等待到本功能部件执行的指令（相关信息） 保留操作码、操作数以及用于检测和解决冲突的信息 在一条指令流出送到保留站的时候： 如果该指令的源操作数已经在寄存器中就绪，则将操作数取到该保留站中 如果操作数还没有计算出来，则在该保留站中记录即将产生这个操作数的保留站的标识 每个保留站都有一个标识字段，唯一地标识了该保留站 公共数据总线CDB （一条重要的数据通路） 功能部件的计算结果都是送到CDB上，再将结果送到目的地 多个执行部件且采用多流出（多数据流），需要多条CDB 存储器读取的数据也送到CDB CDB连接到除了load缓冲器以外的所有部件的人口 浮点寄存器通过一对总线连接到功能部件，并通过CDB连接到store缓冲器的人口 load缓冲器 存放计算有效地址的分量 记录正在进行的load访存，等待存储器响应 保存已经完成了的load的结果（即从存储器取来的数据），等待CDB传输 store缓冲器 存放用于计算有效地址的分量 保存正在进行的store访存的目标地址，该store正在等待存储数据的到达 保存该store的地址和数据，直到存储部件接收 浮点寄存器EP 十六个：F0,F2……F30 通过一对总线连接到功能部件，并通过CDB连接到store缓冲器 指令队列 指令部件送来的指令放入指令队列 按先进先出的顺序流出 运算部件 浮点加法器完成加法和减法操作 浮点乘法器完成乘法和除法操作 Tomasulo算法的执行步骤：流出，执行，写结果 例题，详见PPT P77 50.请说明什么是动态分支预测？有何优点？ 定义 通过硬件技术，在程序执行时根据每一条转移指令过去的转移历史记录来预测下一次转移的方向。通过提前预测分支方向，减少或消除控制相关导致的流水线停顿。 优点 根据程序的执行过程动态地改变转移的预测方向，因此有更好的准确度和适应性 程序每次执行时，可能预测的分支方向与前次相同或不同 从简单到复杂的动态转移预测技术如下： 分支预测缓存器（分支历史表）（BHT） 分支目标缓冲器（BTB） 基于硬件的前瞻执行(ROB) 以上预测机制的性能随着复杂性与硬件的增加而有效地提高 补充：动态分支预测技术和静态分支预测技术的区别 静态分支预测技术所进行的操作事先预定好的 ，与分支的实际执行情况无关； 动态分支预测技术的方法在程序运行时根据分支执行过去的表现预测其将来的行为 分支指令过去的表现就是记录分支的历史信息 51.请简述分支历史表BHT的基本思想。 分支历史表BHT（Branch History Table）或者 分支预测缓冲器（Branch Prediciton Buffer） 最简单的动态分支预测方法 用BHT来记录分支指令最近一次或几次的执行情况（成功或不成功），并据此进行预测分支方向 只有1个预测位的分支预测缓冲 记录分支指令最近一次的历史，BHT中只需要1位二进制位 在记录里： “0”记录分支不成功， “1”记录分支成功 遇见1，预测成功。实际成功则保持1，实际失败置0 遇见0，预测失败。实际失败则保持0，实际成功置1 分支预测缓冲技术包括两个步骤 分支预测：根据当前缓冲记录预测 预测位修改 分支预测错误时，预测位就被修改，并且需要恢复现场，程序从分支指令处重新执行 两位预测位 当前状态下，预测看第一位, \"1\" 预测成功， “0”预测失败 连续2次预测错误会导致翻转，也就是从上半部分进入下半部分，或者从下半部分进入上半部分。 BHT适用： 判定分支是否成功所需的时间大于确定分支目标地址所需的时间 对于前述5段经典流水线：由于判定分支是否成功和计算分支目标地址都是在ID段完成，所以BHT方法不会给该流水线带来好处 52.请简述分支目标缓冲器BTB的基本思想。 目的 尽早知道分支是否成功、尽早知道分支目标地址、尽早获得分支目标指令 这个缓冲区就是分支目标缓冲器（Branch-Target Buffer，简记为BTB，或者Branch-Target Cache） 将分支成功的分支指令的地址和它的分支目标地址都放到一个缓冲区中保存起来，缓冲区以分支指令的地址作为标识 BTB表结构 用专门的硬件实现的一张表格 表格中的每一项至少有两个字段 执行过的成功分支指令的地址（匹配标识） 预测的分支目标地址 相关操作： 预测错误或在BTB中没有匹配的项，要有至少2个时钟周期的开销 更新BTB中的项，要花费一个时钟周期 停止取指令，那么取新的指令又要花费一个时钟周期 BTB表的另一种形式： 在分支目标缓冲器中存放一条或者多条分支目标处的指令 更快地获得分支目标处的指令 一次提供分支目标处的多条指令，这对于多流出处理器是很有必要的 分支折叠（branch folding）的优化 53.请简述基于硬件的前瞻算法基本思想。 基本思想 对分支指令的结果进行猜测，并假设这个猜测总是对的，然后按这个猜测结果继续取出、流出和执行后续的指令。只是执行指令的结果不是写回到寄存器或存储器，而是放到一个称为ROB（ReOrder Buffer）的缓冲器中。等到相应的指令得到“确认”（commit）（即确实是应该执行的）之后，才将结果写入寄存器或存储器 ROB：在猜测错误时能够恢复现场（即没有进行不可恢复的写操作） 基于硬件的前瞻执行结合了三种思想:(动态预测+猜测执行+保留站技术) 动态分支预测。用来选择后续执行的指令 在控制相关的结果尚未出来之前，前瞻地执行后续指令 动态调度对基本块的各种组合进行跨基本块的调度 实质是 数据流执行(data flow execution)：只要操作数有效，指令就执行 对Tomasulo算法加以扩充, 写结果和指令完成都在“写结果”段完成，而在前瞻执行中加以区分，分成两个不同的段: 写结果段 把前瞻执行的结果写到ROB中 通过CDB在指令之间传送结果，供需要用到这些结果的指令使用 指令确认段：在分支指令的结果出来后，对相应指令的前瞻执行给予确认 猜测是对的，把在ROB中的结果写到寄存器或存储器 猜测是错误的，那就不予以确认，并从那条分支指令的另一条路径开始重新执行 ROB中的每一项由以下4个字段组成：: 指令类型:指出该指令是分支指令、store指令或寄存器操作指令 目标地址: 指令执行结果应写入的目标寄存器号（如果是load和ALU指令）或存储器单元的地址（如果是store指令） 数据值字段: 保存指令前瞻执行的结果，直到指令得到确认 就绪字段: 指出指令是否已经完成执行并且数据已就绪 54.请在PVP、SMP、MPP、DSM和COW中任选一种，简要描述其特点。 PVP，Parallel Vector Processor, 并行向量处理机 包含了少量的高性能专门设计定制的向量处理器 ＶＰ，每个至少具有１Ｇflops的处理能力 存储器以兆字节每秒的速度向处理器提供数据 向量处理器VP和共享存储模块通过高带宽的交叉开关网络互连 通常不使用高速缓存，而是使用大量的向量寄存器和指令缓冲器 SMP, Symmetric Multiprocessor, 对称多处理机 使用商品微处理器（具有片上或外置高速缓存） 由高速总线（或交叉开关）连向共享存储器和I/O 系统是对称的, 每个处理器可等同的访问共享存储器、Ｉ／Ｏ设备和操作系统服务 MPP, Massively Parallel Processor, 大规模并行处理机 一般是指超大型计算机系统 处理节点采用商品微处理器；每个节点上有自己的局部存储器；采用高通信带宽和低延迟的互连网络（专门设计和定制的）进行节点互连； 异步的ＭＩＭＤ机器，程序系由多个进程组成，每个都有其私有地址空间，进程间采用传递消息相互作用 主要应用是科学计算、工程模拟和信号处理等以计算为主的领域 DSM，Distributed Shared Memory, 分布式共享存储多处理机 物理上有分布在各节点中的局部存储器，但是对用户而言，系统硬件和软件提供了逻辑上单地址的编程空间 高速缓存目录DIR用以支持分布高速缓存的一致性 ＤＳＭ 相对于 ＭＰＰ的优越性是编程较容易 COW，Cluster of Workstations, 工作站集群 集群往往是低成本的变形的ＭＰＰ ＣＯＷ 的每个节点都是一个完整的工作站 各节点通过一种低成本的商品（标准）网络（如以太网、ＦＤＤＩ和 ＡＴＭ 开关等）互连 各节点内总是有本地磁盘，而 ＭＰＰ节点内却没有 节点内的网络接口是松散耦合到Ｉ／Ｏ 总线上的，而 ＭＰＰ内的网络接口是连到处理节点的存储总线上的，因而可谓是紧耦合式的 一个完整的操作系统驻留在每个节点中，而 ＭＰＰ中通常只是个微核 从存储角度来看MIMD 单地址空间共享存储 存储器可以是物理上集中的或者分布的，但是所有存储单元有统一的地址空间，并被所有的处理器所访问 均匀存储访问:SMP 非均匀存储访问:DSM 多地址空间非共享存储:MPP 55.什么是多处理机Cache一致性问题？ 允许共享数据进入Cache，就可能出现多个处理器的Cache中都有同一存储块的副本，当其中某个处理器对其Cache中的数据进行修改后，就会使得其Cache中的数据与其他Cache中的数据不一致。 存储器的一致性 如果对某个数据项的任何读操作均可得到其最新写入的值，则认为这个存储系统是一致的 存储系统行为的两个不同方面： 读操作得到的是什么值 什么时候才能将已写入的值返回给读操作 处理器P对单元X进行一次写之后又对单元X进行读，读和写之间没有其他处理器对单元X进行写，则P读到的值总是前面写进去的值 处理器P对单元X进行写之后，另一处理器Q对单元X进行读，读和写之间无其他写，则Q读到的值应为P写进去的值 对同一单元的写是串行化的，即任意两个处理器对同一单元的两次写，从各个处理器的角度看来顺序都是相同的。(写串行化 ) 56.请简述监听式协议的原理。 每个Cache除了包含物理存储器中块的数据拷贝之外，也保存着各个块的共享状态信息 Cache通常连在共享存储器的总线上，当某个Cache需要访问存储器时，它会把请求放到总线上广播出去，其他各个Cache控制器通过监听总线（它们一直在监听）来判断它们是否有总线上请求的数据块。如果有，就进行相应的操作。 原子操作：比如对写不命中的检查、申请总线和接收响应作为一个单独的原子操作，中间不被打断 监听协议举例（前提：写作废，写回法， 原子操作） 在每个结点内嵌入一个有限状态控制器 该控制器根据来自处理器或总线的请求以及Cache块的状态，做出相应的响应 每个数据块的状态取以下3种状态中的一种： 无效（简称I）：Cache中该块的内容为无效 共享（简称S）：该块可能处于共享状态，在多个处理器中都有副本。这些副本都相同，且与存储器中相应的块相同 已修改（简称M）：该块已经被修改过，并且还没写入存储器，块中的内容是最新的，系统中唯一的最新副本，并且“已修改” 隐含表明该块是独占的（exclusive） 请求来自处理器 请求来自总线 57.请简述目录式协议的原理。（自学） 基本思想：物理存储器中数据块的共享状态被保存在一个称为目录的地方 广播和监听的机制使得监听一致性协议的可扩放性很差。 寻找替代监听协议的一致性协议。 目录协议： 目录：一种集中的数据结构。对于存储器中的每一个可以调入Cache的数据块，在目录中设置一条目录项，用于记录该块的状态以及哪些Cache中有副本等相关信息 对于任何一个数据块，都可以快速地在唯一的一个位置中找到相关的信息。这使一致性协议避免了广播操作 位向量：记录哪些Cache中有副本 每一位对应于一个处理器 长度与处理器的个数成正比 由位向量指定的处理机的集合称为共享集S 实现方案： 目录法最简单的实现方案：对于存储器中每一块都在目录中设置一项。目录中的信息量与M（存储器中存储块的总数量）×N（处理器的个数）成正比 ​ 58. 请比较说明写作废协议和写更新协议性能上的差别。（自学） P10 写作废协议 在一个处理器写某个数据项之前保证它对该数据项有唯一的访问权 写更新协议 当一个处理器写某数据项时，通过广播使其它 Cache中所有对应的该数据项拷贝进行更新 写更新和写作废协议性能上的差别 对同一数据（字）的多个写而中间无读操作情况, 写更新协议需进行多次写广播操作，而在写作废协议下只需一次作废操作 对同一块中多个（不同）字进行写，写更新协议对每个字的写均要进行一次广播，而在写作废协议下仅在对本块第 一次写时进行作废操作 写作废是针对Cache块进行操作，而写更新则是针对字（或字节）进行。 一个处理器A写到另一个处理器B读之间的延迟通常在写更新模式中较低。而在写作废协议中，需要读一个新的拷贝，即（写更新B已有副本，写作废要等待调入新的副本） 在基于总线的多处理机中，写作废协议成为绝大多数系统设计的选择 59.请解释，在目录式协议中，什么是本地节点、宿主节点、远程节点和共享集合？（自学） 本地节点： 发出访问请求的结点 宿主节点：包含所访问的存储单元及其目录项的结点 远程节点：Cache中拥有该块的副本 共享集合：位向量记录拥有其副本的处理器的集合 60. 请简述目录式协议中，目录的三种结构。（自学） 不同目录协议的主要区别： 所设置的存储器块的状态及其个数不同 目录结构 目录协议分为： 全映像目录 有限映像目录‘ 链式目录 全映像目录 每一个目录项都包含一个N位（N为处理机的个数）的位向量，其每一位对应于一个处理机。 处理比较简单，速度也比较快 但是存储空间开销大 目录项的数目与处理机的个数N成正比，而目录项的大小（位数）也与N成正比，因此目录所占用的空间与N^2成正比 可扩放性很差 当位向量中的值为“1”时，就表示它所对应的处理机有该数据块的副本；否则就表示没有 在这种情况下，共享集合由位向量中值为“1”的位所对应的处理机构成 有限映像目录 提高其可扩放性和减少目录所占用的空间 核心思想：采用位数固定的目录项目 限制同一数据块在所有Cache中的副本总数 例如，限定为常数m。则目录项中用于表示共享集合所需的二进制位数为：m×log2N 当同一数据的副本个数大于m时，必须做特殊处理。当目录项中的m个指针都已经全被占满，而某处理机又需要新调入该块时，就需要在其m个指针中选择一个，将之驱逐，以便腾出位置，存放指向新调入块的处理机的指针 如图，有限映像目录（m＝4，N≥8的情况） 链式目录 用一个目录指针链表来表示共享集合。当一个数据块的副本数增加（或减少）时，其指针链表就跟着变长（或变短） 由于链表的长度不受限制，因而带来了以下优点：既不限制副本的个数，又保持了可扩展性 两种实现方法： 单链法： 当Cache中的块被替换出去时，需要对相应的链表进行操作——把相应的链表元素（假设是链表中的第i个）删除。实现方法有以下两种： 沿着链表往下寻找第i个元素，找到后，修改其前后的链接指针，跳过该元素。 找到第i个元素后，作废它及其后的所有元素所对应的Cache副本。 ![image-20241206195515642](assets\\image-20241206195515642-1733486116964-5.png) 2. **双链法**： 在替换时不需要遍历整个链表。 节省了处理时间，但其指针增加了一倍，而且一致性协议也更复杂了 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 计算机组成原理基础知识 "},"docs/计算机组成原理/计算机组成原理基础知识（简答版）.html":{"url":"docs/计算机组成原理/计算机组成原理基础知识（简答版）.html","title":"计算机组成原理基础知识（简答版）","keywords":"","body":" 计算机组成原理基础知识（简答版） 1. 说明计算机系统的层次结构。 2. 说明冯诺依曼体系结构的特点。 3. 什么是机器字长、指令字长、存储字长? 4.系统总线包括哪三类？起到什么作用？ 5. 总线判优控制是解决什么问题的？总的来说可以分为哪两种方式？ 6. 集中式总线控制优先权仲裁方式有哪三种？各有什么特点？ 7. 简述总线周期的4个阶段。 8. 总线通信控制是解决什么问题的？总的来说有哪几种控制方式？各自的特点是什么？ 9. 串行传输和并行传输有何区别？各适用于什么场合？ 10.试比较RAM和ROM。 11. 从实现技术的角度，试比较SRAM和DRAM。 12. 存储芯片内的地址译码方式有几种？各自特点及应用场合？ 13. 什么是动态RAM的刷新？刷新有几种方式？简要说明之。 14. 存储容量扩展有哪几种方法？ 15. 使用汉明码进行校验时，需要增加k位检测位，且k位的检测位和n位的待检测二进制代码位之间要满足什么关系？为什么？ 16. 已知收到的海明码为0100111（按配偶原则配置），试问欲传送的信息是什么？ 17. 什么是多体并行存储器？有哪两种存储体编址方式，各自有什么特点？ 18. Cache、主存和辅存构成的三级存储系统分别的目的是什么？设计依据是？ 19. 请简述Cache的基本工作原理。 20. 试比较主存-Cache管理中三种地址映射的方法，并分别给出在三种地址映射下，主存地址划分。 21. Cache-主存间的替换策略有哪些，请简述。 22. 发生主存写请求时，如何保证Cache和主存的一致性？ 23. 影响Cache-主存层平均访问时间的因素有哪些？如果降低平均访存时间，可以怎么办？ 24. I/O地址码的编制方式有哪两种？ 25. I/O与主机交换信息有哪几种控制方式？各有何特点？ 26. I/O接口有什么作用。 27. 程序查询方式和程序中断方式都由程序实现外围设备的输入输出，它们有何不同？ 28. 以I/O设备的中断处理过程为例，说明一次程序中断的全过程。 29.在DMA方式中有没有中断请求，为什么？DMA接口电路中应设置哪些硬件。 30. DMA方式中的中断请求和程序中断中的中断请求有何区别？ 31. DMA和主存交换数据时有哪三种方法？分别简述。 32.简述DMA的工作过程。 33. DMA接口的类型有哪几种？ 34. 说明浮点加/减法运算步骤。 35.说明浮点乘/除法运算的基本步骤。 36. 试比较基址寻址和变址寻址，并举例说明其适用的场合。 37. 任意写出五种寻址方式，令EA为有效地址，A为形式地址，写出这五种寻址方式计算有效地址的表达式。 38. 指令中有哪些字段？各有何作用？如何确定各字段的位数？ 39. RISC和CISC指令系统各自的特点。 40. 请简述MIPS指令系统的R型、I型和J型指令格式，并举出指令实例。 41. 在MIPS指令子集实现的时候，如何从单周期数据通路构造流水线？ 42. 流水线中有哪三种冒险？请简述，并至少举出一种解决冒险的方法。 43. 请简述Flynn分类法将计算机系统结构分成哪四类。 44. 请简述程序局部性原理。 45.请简述Amdahl定律。 46. 影响CPU时间的因素包括什么？（提示：从CPU公式入手，考虑3个参数的影响因素） 47. 请简要说明提高计算机系统并行性的3种技术途径，并分别从单机和多机系统的角度举例。 48. 请说明什么是静态调度？什么是动态调度？动态调度的优点是什么？ 49. 请简述Tomasulo算法的基本思想，并分析其局限性。 50. 请说明什么是动态分支预测？有何优点？ 51. 请简述分支历史表BHT的基本思想。 52.请简述分支目标缓冲器BTB的基本思想。 53. 请简述基于硬件的前瞻算法基本思想。 54. 请在PVP、SMP、MPP、DSM和COW中任选一种，简要描述其特点。 55. 什么是多处理机Cache一致性问题？ 56.请简述监听式协议的原理。 57. 请简述目录式协议的原理。（自学） 58. 请比较说明写作废协议和写更新协议性能上的差别。（自学） 59. 请解释，在目录式协议中，什么是本地节点、宿主节点、远程节点和共享集合？（自学） 60. 请简述目录式协议中，目录的三种结构。（自学） 计算机组成原理基础知识（简答版） 1. 说明计算机系统的层次结构。 常见的五级计算机系统层次结构 分别是 高级语言机器，高级语言由编译程序翻译成汇编语言 汇编语言机器，汇编语言由汇编程序翻译成机器语言 操作系统机器，机器语言解释操作系统 软硬件分界 机器语言机器，微程序解释机器指令 微指令系统，硬件执行微指令 2. 说明冯诺依曼体系结构的特点。 五大部件：运算器，存储器，控制器，I/O设备 运算器为中心 指令和数据用二进制表示，同等地位存于存储器 指令由操作码和地址码组成，顺序执行 3. 什么是机器字长、指令字长、存储字长? 机器字长：CPU一次能处理的数据位数，与寄存器位数有关 指令字长：计算机指令所占用的位数，取决于操作码长度，操作码地址长度和个数 存储字长：MDR一个存储单元存储的二进制代码的位数 4.系统总线包括哪三类？起到什么作用？ 分为数据总线，地址总线，控制总线 数据总线：传输数据信息 地址总线：数据地址或设备地址 控制总线：发出控制信号 5. 总线判优控制是解决什么问题的？总的来说可以分为哪两种方式？ 总线判优控制解决多个部件同时申请总线时的总线使用权分配问题 分为集中式和分布式 6. 集中式总线控制优先权仲裁方式有哪三种？各有什么特点？ 集中式总线控制优先权仲裁方式有链式查询，计时器定时查询，独立请求三种 链式查询：结构简单，易于扩充设备；电路故障敏感，优先级固定 计时器定时查询：优先级设置灵活，对电路故障不那么敏感；控制较复杂 独立请求方式：响应时间快，优先次序灵活；控制逻辑复杂 7. 简述总线周期的4个阶段。 总线周期分为申请分配，寻址，传数，结束四个阶段 申请分配：主模板申请总线使用，总线仲裁机构将总线使用权给某一申请者。 寻址：主模块通过总线发出本次要访问的从模块（或从设备）的地址及有关命令，启动从模块。 传数：主模块和从模块进行数据交换 结束：从总线撤除主模板信息，让出总线使用权 8. 总线通信控制是解决什么问题的？总的来说有哪几种控制方式？各自的特点是什么？ 总线通信控制主要解决通信双方如何获知传输开始和结束，协调配合的问题 总的有同步通信，异步通信，半同步通信，分离式通信四种控制方式 同步通信：统一时标，强制性同步 异步通信：允许各模块速度的不一致性，采用应答方式（握手方式） 半同步通信：同步异步结合 分离式通信：各模板需要申请，限定时间同步传送信息，准备数据不占用总线，控制复杂 9. 串行传输和并行传输有何区别？各适用于什么场合？ 串行传输： 数据在单条 1 位宽的传输线上，一位一位地按顺序分时传送。 成本低，速度慢，适合远距离数据传输。 并行传输： 数组在多条并行 1 位宽的传输线上，同时由源传送到目的地。 成本高，速度快，适合近距离数据传输 10.试比较RAM和ROM。 RAM：随机存取存储器，可读可写，常用于主存。 ROM：只读存储器，在程序执行过程中只能将内部信息读出，不能随意写入。 11. 从实现技术的角度，试比较SRAM和DRAM。 SRAM：用触发器工作原理存储信息，断电易失信息，不需要刷新，速度快成本高 DRAM：用电容存储电荷原理寄存信息，需要刷新，集成度高，功耗高，速度较慢 12. 存储芯片内的地址译码方式有几种？各自特点及应用场合？ 有线选法和重合法两种 线选法：一根字选择线选中一个存储单元，结构简单，用于容量不大的存储芯片 重合法：二维地址译码，由行列地址译码器共同选中一个存储单元，结构复杂，用于大容量存储芯片 13. 什么是动态RAM的刷新？刷新有几种方式？简要说明之。 刷新的过程实质上是先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程，或者说是对 DRAM 定期进行的全部重写过程，一次刷新一行 集中刷新：规定刷新周期，集中刷新，存在“死区” 分散刷新：每行刷新分散到每个存取周期，存取周期长，系统速度降低 异步刷新：结合集中刷新和分散刷新，缩短“死区”，充分利用最大刷新间隔为2ms 将刷新安排在CPU对指令的译码阶段 14. 存储容量扩展有哪几种方法？ 有位扩展，字扩展和字位扩展三种 位扩展：增加存储字长，两片1K4位组成一片1K\\8位 字扩展：增加存储器字的数量，两片1K8位组成2K\\8位 字位扩展：既增加存储字的数量，又增加存储字长 15. 使用汉明码进行校验时，需要增加k位检测位，且k位的检测位和n位的待检测二进制代码位之间要满足什么关系？为什么？ 2^k ≥ n+k+1 为了能准确对错误定位以及指出代码没错 16. 已知收到的海明码为0100111（按配偶原则配置），试问欲传送的信息是什么？ P1 = 1⊕3⊕5⊕7 = 0 P2 = 2⊕3⊕6⊕7 = 1 P4 = 4⊕5⊕6⊕7 = 1 P4P2P1 = 110 (110)2=6->第六位出错，纠正为 0100101，故要求传送的信息为 0101 17. 什么是多体并行存储器？有哪两种存储体编址方式，各自有什么特点？ 多体并行系统就是采用多体模块组成的存储器。每个模块有相同的容量和存取速度，各模块各自都有独立的地址寄存器(MAR)、数据寄存器(MDR)、地址译码、驱动电路和读/写电路，他们能并行工作，又能交叉工作。 两种存储体编址方式：高位交叉编址和地位交叉编址 高位交叉：高位表示体位，低位表示体内地址，顺序存储 低位交叉：低位地址表示体位，高位地址为体内地址，模M编址，交叉存储 18. Cache、主存和辅存构成的三级存储系统分别的目的是什么？设计依据是？ Cache-主存层次： 解决 CPU 和主存速度不匹配的问题 依据： 程序访问的局部性原理 缓存的速度比主存的速度高 主存-辅存层次： 解决存储系统的容量问题 依据 辅存的速度比主存的速度低，而且不能和 CPU 直接交换信息，但它的容量比主存大得多，可以存放大量暂时未使用得信息。 19. 请简述Cache的基本工作原理。 主存和缓存按块存储，且块的大小相同，任何时刻都有一些主存块处在缓存块中 CPU欲读取主存某字时，若所需字已在缓存中，直接访问Cache； 若不在Cache内，将该字所在的主存整个字块一次调入Cache中进行访问。 20. 试比较主存-Cache管理中三种地址映射的方法，并分别给出在三种地址映射下，主存地址划分。 直接映射：每个主存块只能和一个缓存块对应，每个缓存块可以和若干个主存块对应。 | 主存字块标记 | Cache字块地址 | 字块内地址 | | ------------ | ------------- | ---------- | | t位 | c位 | b位 | 全相联映射：主存中的任一块可以映射到缓存中的任一块 | 主存字块标记 | 字块内地址 | | ------------ | ---------- | | m=t+c位 | b位 | 组相联映射：某一主存块按模Q映射到缓存的某组中的任一块 | 主存字块标记 | 组地址 | 字块内地址 | | ------------ | ------- | ---------- | | s=t+r位 | q=c-r位 | b位 | 21. Cache-主存间的替换策略有哪些，请简述。 先进先出（FIFO）算法：选择最早调入Cache的字块进行替换。 近期最少使用（LRU）算法：利用访存局部性原理，替换出近期用的最少的字块。 随机法：随机地选择被替换的块。 22. 发生主存写请求时，如何保证Cache和主存的一致性？ 写直达法：写操作时数据既写入Cache又写入主存，随时保证主存和Cache的数据始终一致。 写回法：写操作时只把数据写入Cache而不写入主存，当Cache数据被替换出去时才写回主存。 23. 影响Cache-主存层平均访问时间的因素有哪些？如果降低平均访存时间，可以怎么办？ 因素：访问Cache的时间、失效率、失效开销 强制性失效：增加块大小、预取 容量失效：增加容量 冲突失效：提高相关联 24. I/O地址码的编制方式有哪两种？ 统一编码：将I/O地址看作存储器地址的一部分 不统一编码： I/O 地址和存储器地址是分开的 25. I/O与主机交换信息有哪几种控制方式？各有何特点？ 程序查询方式：CPU和I/O串行工作，踏步等待。 程序中断方式：CPU和I/O并行工作，没有踏步等待现象，进行中断现行程序。 DMA方式：CPU和I/O并行工作，主存和I/O之间有一条直接数据通道，不中断现行程序，周期挪用（周期窃取）方式。 26. I/O接口有什么作用。 选择设备 数据缓冲达到速度匹配 数据串-并格式转换 电平转换 传送控制命令 反应设备的状态 27. 程序查询方式和程序中断方式都由程序实现外围设备的输入输出，它们有何不同？ 程序查询方式通过“程序”传送数据时，程序对I/O的控制包括了I/O准备和I/O传送两段时间。由于I/O的工作速度比CPU低得多，因此程序中要反复查询I/O的状态，造成“踏步等待”，严重浪费了CPU的工作时间。 程序中断方式虽然也是通过“程序”传送数据，但程序仅对I/O传送阶段进行控制，故CPU此时照样可以运行现行程序，与I/O并行工作，大大提高CPU的工作效率。 28. 以I/O设备的中断处理过程为例，说明一次程序中断的全过程。 中断请求、中断判优、中断响应、中断服务、中断返回 由CPU发出启动 I/O 设备指令 接口启动输入设备开始工作 输入设备将数据送入数据缓冲寄存器 输入设备向接口发出“设备工作结束”信号，标志设备准备就绪 当设备准备就绪(D=1)，且本设备未被屏蔽(MASK=O)时，在指令执行阶段的结束时刻，由 CPU 发出中断查询信号 设备中断请求触发器 INTR 被置为“1”'，标志设备向 CPU 提出中断请求。与此同时，INTR 送至排队器，进行中断判优 若 CPU 允许中断(EINT=1)，设备又被排队选中，即进入中断相应阶段，由中断响应信号 INTA 将排队器输出送至编码器形成向量地址 向量地址送至 PC，作为下一条指令的地址 由于向量地址中存放的是一条无条件转移指令，故这条指令执行结束后即无条件转至该设备的服务程序入口地址，开始执行中断服务程序，进入中断服务阶段，进行数据交换 中断服务程序的最后一条指令是中断返回指令，当其执行结束后，即中断返回至原程序的断点处。 至此，一个完整的程序中断处理过程即告结束 29.在DMA方式中有没有中断请求，为什么？DMA接口电路中应设置哪些硬件。 有。当字计数器溢出（全为0）时，由“溢出信号”通过中断机构向CPU提出中断请求，表示数据交换完毕，请求CPU作DMA操作的后处理，。 主存地址寄存器（AR），字计数器（WC），数据缓冲寄存器（BR）， DMA控制逻辑，中断机构，设备地址寄存器（DAR）。 30. DMA方式中的中断请求和程序中断中的中断请求有何区别？ DMA方式中的中断请求是为了报告一批数据传送结束； 程序中断中的中断请求是为了数据的交换。 31. DMA和主存交换数据时有哪三种方法？分别简述。 停止CPU访问主存：当外设要求传送一批数据时，由DMA接口向CPU发一个停止信号，要求CPU放弃地址线、数据线和有关控制线的使用权。 周期挪用（周期窃取）：每当I/O设备发出DMA请求时，I/O设备便挪用或窃取总线占用权一个或几个主存周期，而DMA不请求时，CPU仍继续访问主存。 DMA和CPU交替访问：将一个CPU周期分为C1和C2两个分周期，其中C1专供DMA访问，C2专供CPU访问。 32.简述DMA的工作过程。 预处理：通过几条输入输出指令通知DMA控制逻辑传送方向，设备地址，主存地址，传送字数 数据传送：若允许传送，则主存地址送总线，数据送I/O设备（或主存），修改主存地址，修改字计数器。若数据传送接送，则向CPU申请程序中断。 后处理：中断服务程序做DMA结束后处理。 33. DMA接口的类型有哪几种？ 选择型DMA接口、多路型DMA接口。 34. 说明浮点加/减法运算步骤。 对阶：小阶向大阶看齐 尾数相加减 尾数规格化 尾数舍入 阶码判溢出 35.说明浮点乘/除法运算的基本步骤。 阶码采用定点加减运算 尾数乘数同定点运算 尾数规格化 尾数舍入 阶码判溢出 36. 试比较基址寻址和变址寻址，并举例说明其适用的场合。 基址寻址：操作数的有效地址EA等于指令字中的形式地址与基址寄存器中的内容（称为基地址）相加。基址寄存器的内容由操作系统确定，在程序执行过程中内容不变。在多道程序中极为有用。 变址寻址：有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加。变址寄存器的内容由用户给定，在程序的执行过程中IX内容可变，形式地址A不变。便于处理数组问题。 37. 任意写出五种寻址方式，令EA为有效地址，A为形式地址，写出这五种寻址方式计算有效地址的表达式。 立即寻址：A是操作数本身 直接寻址：EA = A 隐含寻址：隐含在操作码或某个寄存器中 间接寻址：EA = (A) 寄存器寻址：EA = R 寄存器间接寻址：EA = (Ri) 基址寻址：EA = A + (BR) 变址寻址：EA = A + (IX) 相对寻址：EA = (PC) + A 堆栈寻址：EA=(SP) 38. 指令中有哪些字段？各有何作用？如何确定各字段的位数？ 指令通常由操作码和地址码组成，同时因为数据寻址方式种类较多，中必须设一字段来指明属千哪一种寻址方式，所以指令也可以分为操作码字段、寻址特征字段和地址码字段 操作码：指明该指令所要完成的操作 地址码：指出该指令的源操作数的地址（一个或两个）、结果的地址以及下一条指令的地址。 寻址特征字段：指明属于哪一种寻址方式 39. RISC和CISC指令系统各自的特点。 RISC的主要特点： 选用使用频度较高的一些简单指令，复杂指令的功能由简单指令来组合。 指令长度固定、指令格式种类少、寻址方式少 只有LOAD/STORE指令访存 CPU中有多个通用寄存器 采用流水技术一个周期内完成一条指令 采用组合逻辑实现控制器 采用优化的编译程序 CISC的主要特点： 系统指令复杂庞大，各种指令使用频度相差大 指令长度不固定、指令种类多、寻址方式多 访存指令不受限制 CPU中设有专用寄存器 大多数指令需要多个时钟周期执行完毕 采用微程序控制器 难以用优化编译生成高效的目的代码 40. 请简述MIPS指令系统的R型、I型和J型指令格式，并举出指令实例。 寄存器指令（R型指令）： 操作数（6bits），两个源操作数寄存器（5bits共10bits)，目的寄存器（5bits)，位移量(shamt)（5bits)，功能（6bits)。一般R型指令op为000000，由funct决定操作种类 add,sub 立即数指令（I型指令）： 操作数（6bits），源操作数寄存器（5bits)，目的寄存器（5bits),constant or address（16bits) lw,sw,bne 跳转指令 （J型指令） J 型除了6位操作码之外，其余位都是地址字段 j 41. 在MIPS指令子集实现的时候，如何从单周期数据通路构造流水线？ 将单周期数据通路分为IF,ID,EX,MEM,WB五段，并在每两段之间加入流水寄存器 42. 流水线中有哪三种冒险？请简述，并至少举出一种解决冒险的方法。 结构冒险：需要的资源被占用（硬件资源冲突）。将指令和数据分别存储；设计指令/数据高速缓存。 数据冒险：需要等待前面指令完成其读写操作。转发（旁路）；代码重排；阻塞和冒泡。 控制冒险：根据前面正在执行的指令决策控制操作。静态分支预测；动态分支预测；分支延迟槽。 43. 请简述Flynn分类法将计算机系统结构分成哪四类。 根据指令流和数据流分类 单指令流、单数据流 SISD 单指令流、多数据流 SIMD 多指令流、单数据流 MISD 多指令流、多数据流 MIMD 44. 请简述程序局部性原理。 程序执行时所访问的存储器地址相对地簇拥。 程序的时间局部性：程序即将用到的信息很可能就是目前正在使用的信息。 程序的空间局部性：程序即将用到的信息很可能与目前正在使用的信息在空间上相邻或者临近。 45.请简述Amdahl定律。 加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间的百分比。 46. 影响CPU时间的因素包括什么？（提示：从CPU公式入手，考虑3个参数的影响因素） CPU时间=IC*CPI*时钟周期 时钟周期时间：取决于硬件实现技术和计算机组成。 CPI（平均每条指令耗费的时钟周期数）：取决于计算机组成和指令集结构。 IC（程序总指令数）：取决于指令集结构和编译技术。 47. 请简要说明提高计算机系统并行性的3种技术途径，并分别从单机和多机系统的角度举例。 时间重叠，资源重复，资源共享 单机：部件功能专用化、重复设置功能部件、使用分时系统 多机：处理机专用化、重复设置处理机、使用分布式系统 48. 请说明什么是静态调度？什么是动态调度？动态调度的优点是什么？ 静态调度：依靠编译器对代码进行调度，也就是在代码被执行之前进行调度； 动态调度：在程序的执行过程中，依靠专门硬件对代码进行调度。 动态调度优点： 减少阻塞。 能够处理一些在编译时情况不明的相关。 能够使本来使面向某一流水线优化编译的代码在其他的流水线（动态调度）上也能高效地执行。 49. 请简述Tomasulo算法的基本思想，并分析其局限性。 记录和检测指令相关，操作数一旦就绪就立刻执行，把发生RAW冲突的可能性减少到最小； 通过寄存器换名来消除WAR冲突和WAW冲突。 局限性： 不能处理异常和控制冲突。 指令队列里有分支指令，分支指令之后的指令不能流出，直到确定分支是否成功。 硬件逻辑复杂 50. 请说明什么是动态分支预测？有何优点？ 通过硬件技术，在程序执行时根据每一条转移指令过去的转移历史记录提前预测分支方向。 优点： 减少或消除控制相关导致的流水线停顿 根据程序的执行过程动态地改变转移的预测方向，因此有更好的准确度和适应性； 程序每次执行时，可能预测的分支方向与前次相同或不同。 51. 请简述分支历史表BHT的基本思想。 用BHT来记录分支指令最近一次或几次的执行情况（成功或不成功），并据此进行预测。 52.请简述分支目标缓冲器BTB的基本思想。 将分支成功的分支指令地址和它的分支目标地址都放到一个缓冲区中保存起来，缓冲区以分支指令的地址作为标识。 53. 请简述基于硬件的前瞻算法基本思想。 按照分支预测结果继续取出、流出和执行后续的指令。指令的结果放到一个称为ROB（ReOrder Buffer）的缓冲器中。等到响应的指令得到“确认：（commit）（即确实是应该执行的）之后，才将结果写入寄存器或存储器。 54. 请在PVP、SMP、MPP、DSM和COW中任选一种，简要描述其特点。 PVP，Parallel Vector Processor, 并行向量处理机 有向量处理器 ＶＰ 存储器以兆字节每秒的速度向处理器提供数据 交叉开关网络互连 通常不使用高速缓存 SMP, Symmetric Multiprocessor, 对称多处理机 使用商品微处理器（具有片上或外置高速缓存） 高速总线（或交叉开关） 系统是对称的 MPP, Massively Parallel Processor, 大规模并行处理机 超大型计算机系统 处理节点采用商品微处理器；每个节点上有自己的局部存储器；采用高通信带宽和低延迟的互连网络（专门设计和定制的）进行节点互连； 异步的ＭＩＭＤ机器，程序系由多个进程组成，每个都有其私有地址空间，进程间采用传递消息相互作用 DSM，Distributed Shared Memory, 分布式共享存储多处理机 物理上有分布在各节点中的局部存储器，但是对用户而言，系统硬件和软件提供了逻辑上单地址的编程空间 高速缓存目录DIR用以支持分布高速缓存的一致性 ＤＳＭ 相对于 ＭＰＰ的优越性是编程较容易 COW，Cluster of Workstations, 工作站集群 集群往往是低成本的变形的ＭＰＰ ＣＯＷ 的每个节点都是一个完整的工作站 各节点通过一种低成本的商品（标准）网络（如以太网、ＦＤＤＩ和 ＡＴＭ 开关等）互连 各节点内总是有本地磁盘，而 ＭＰＰ节点内却没有 节点内的网络接口是松散耦合到Ｉ／Ｏ 总线上的，而 ＭＰＰ内的网络接口是连到处理节点的存储总线上的，因而可谓是紧耦合式的 一个完整的操作系统驻留在每个节点中，而 ＭＰＰ中通常只是个微核 从存储角度来看MIMD 单地址空间共享存储 存储器可以是物理上集中的或者分布的，但是所有存储单元有统一的地址空间，并被所有的处理器所访问 均匀存储访问:SMP 非均匀存储访问:DSM 多地址空间非共享存储:MPP 55. 什么是多处理机Cache一致性问题？ 允许共享数据进入Cache，极可能出现多个处理器的Cache中都有同一存储块的副本，其中某个处理器对其Cache中的数据进行修改后，就会使得其修改后Cache中的数据与其他Cache中的数据不一致。 56.请简述监听式协议的原理。 每个Cache包含物理存储器中块的数据拷贝和各个块的共享状态信息。 Cache通常连在共享存储器的总线上，当某个Cache需要访问存储器时，它会把请求放到总线上广播出去，其他各个Cache控制器通过监听总线来判断它们是否有总线上请求的数据块。如果有，就进行相应的操作。 57. 请简述目录式协议的原理。（自学） 对于存储器中每一个可以调入Cache的数据块，在目录中设置一条目录项，用于记录该块的状态以及哪些Cache中有副本等相关信息。 对于任何一个数据块，都可以快速地在目录里唯一的一个位置中找到相关的信息。这使一致性协议避免了广播操作。 58. 请比较说明写作废协议和写更新协议性能上的差别。（自学） 在对同一个数据进行多次写操作而中间无读操作的情况下，写更新协议需进行多次写广播操作，而写作废协议只需一次作废操作。 在对同一Cache块的多个字进行写操作的情况下，写更新协议对于每一个写操作都要进行一次广播，而写作废协议仅在对该块的第一次写时进行作废操作即可。 写作废是针对Cache块进行操作，而写更新则是针对字（或字节）进行。 写更新协议的延迟时间较小。 59. 请解释，在目录式协议中，什么是本地节点、宿主节点、远程节点和共享集合？（自学） 本地结点：发出访问请求的结点 宿主结点：包含所访问的存储单元及其目录项的结点 远程结点：Cache中拥有该块的副本 共享集合：位向量记录拥有其副本的处理器的集合 60. 请简述目录式协议中，目录的三种结构。（自学） 全映像目录：每一个目录项都包含一个N位（N为处理机的个数）的位向量，其每一位对应一个处理机 有限映像目录：采用位数固定的目录项目 链式目录：用一个目录指针链来表示共享集合。当一个数据块的副本数增加（或减少）时，其指针链表就跟着变长（或变短）。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 计算机组成原理基础知识（简答版） "},"docs/Operating_System/":{"url":"docs/Operating_System/","title":"Operating System","keywords":"","body":" 操作系统（Operating System） 操作系统（Operating System） 本目录收集了操作系统相关的入门与进阶笔记，内容以通俗语言介绍操作系统的核心概念、常见机制与实用例子，适合课程复习、自学或面试准备。 但是我个人觉得本目录的内容并不是特别好，大多数都为PPT的复制粘贴，但是当然也有我自己的理解和想法，所以还是建议阅读后给我提出建议和意见 其中相关的实验在github仓库Operating_System 子文件（主要内容）： 01_概论.md：介绍操作系统的作用、组成与基本术语。 02_进程管理.md：讲进程和线程的概念、创建与调度基础，以及进程间通信的常见方式。 03_中断和处理器调度.md：解释中断机制和调度策略，说明操作系统如何响应外部事件并分配 CPU。 04_互斥同步与通讯.md：介绍并发控制的方法（如锁、信号量）和进程/线程间通讯的常用技术。 05_死锁与饥饿.md：说明死锁的形成条件、检测与避免策略，以及资源分配的公平性问题。 06_主存管理.md：讲内存分配、管理策略与碎片问题。 07_虚拟存储器管理.md：解释分页、换页和缓存策略，帮助理解内存虚拟化的工作原理。 08_文件与文件系统.md：介绍文件抽象、目录结构与常见文件系统实现要点。 09_设备与IO管理.md：说明设备驱动、IO 调度和常见外设管理方法。 review.md：复习要点汇总。 assets/：本目录使用的图片与示意图（请用相对路径引用）。 我的github仓库Operating_System 欢迎在仓库内提交 Issue 或 PR 来提供建建议和见解 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - Operating System "},"docs/Operating_System/01_概论.html":{"url":"docs/Operating_System/01_概论.html","title":"01_概论","keywords":"","body":" 1.1 操作系统概念 操作系统的历史 操作系统的特性 操作系统运行环境 定时装置 堆和栈 寄存器 特权指令与非特权指令 处理机状态及状态转换 地址映射机构 存储保护设施 中断装置 通道与DMA I/O保护 1.1 操作系统概念 操作系统地位 硬件抽象层（HAL）之上 所有其它软件层之下 运行视图 系统库(lib)可调用操作系统，执行硬件指令 应用程序可以调用lib和操作系统，执行硬件指令 操作系统的作用 管理系统中软硬件资源 例如：CPU，内存，设备，文件 为用户(应用程序)提供良好的服务(界面) 命令接口（联机和脱机），程序接口(系统调用），GUI 操作系统定义 [!important] 操作系统是位于硬件层(HAL)之上，所有其它软件层之下的一个系统软件，通过它管理系统中各种软硬件资源（计算机资源），使它们被充分利用，方便用户使用计算机系统（向上层提供和简便易用的接口）。 系统软件 管理资源 向上提供接口 操作系统的历史 操作系统的产生 手工操作阶段 电子管：二进制程序，打孔：纸带和卡片 批处理阶段 联机批处理（单道批处理）：读卡机，磁带机（监管程序：OS雏形）： 脱机批处理：卫星机： 执行系统阶段：I/O处理机（通道和中断技术） 操作系统的完善 多道批处理系统：多道批处理:主机中同时放多个作业,最大限度提高资源利用率，标志操作系统走向成熟(在作业执行时用户不能直接干预，交互性差) 分时系统：时间片轮换（用于多用户，交互性好） 实时系统：时间约束（硬实时：严格时间约束）（软实时：时间约束宽松）：及时响应特性 通用操作系统：通用操作系统可以同时处理实时任务、接受终端请求、运行成批作业。 操作系统的发展 网络操作系统 分布式操作系统 多处理机操作系统 单用户操作系统 面向对象操作系统 嵌入式操作系统 智能卡操作系统 多核技术下新一代操作系统 操作系统的特性 并发性 多个程序在宏观上同时向前推进，微观上依旧是交替进行 例如OS与OS并发，用户程序与OS,用户程序与用户程序 不同于并行，即多个程序同时进行 共享性 多个程序共用系统中的各种软硬件资源 在操作系统的协调和控制下 又分为互斥共享（宏观同时，微观交替），同时共享（同一时刻访问） 程序异步性 在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性； 所以只有系统拥有并发性，才有可能导致异步性。 交替的切换点是中断： 用户程序向操作系统切换； 操作系统程序向操作系统程序切换（中断嵌套）。 中断随机发生，致使程序切换不确定、不可预知。 虚拟性 所谓虚拟就是利用某种技术把一个物理实体变为若干个逻辑实体 空时复用（虚拟存储），时分复用（虚拟处理器） [!note] 其中并发和共享互为存在条件，是操作系统最基本的两个特征； 并且虚拟和异步依赖于并发 操作系统运行环境 定时装置 绝对时钟 记载实际实践，不发生中断 系统操作员可以修改，一般用户使用 绝对时钟的值保存于硬件寄存器中 程序可以读取绝对时钟的值 间隔时钟 定时发生中断，一般间隔单位为毫秒 间隔时钟是实现多道程序的基础—保证操作系统获得控制权。 其它中断也进入操作系统，但是否发生，何时发生没有保障。 通过间隔时钟可以构造逻辑时钟。 堆和栈 尽管用户进程的“堆”和“栈”在物理上通常是相邻的。每个运行程序都有一个堆和两个栈（一个用户栈，一个系统栈） 堆属于用户空间，用于保存程序中的动态变量 例如树的结点，堆空间由操作系统分给运行程序，由于不同程序运行时对动态变量的使用不同，因而堆空间大小需求不定。 用户栈属于用户空间，用于保存用户函数调用时的返回点、参数、局部变量、返回值。除此之外，用户栈还要传送调用操作系统时传给操作系统的参数。 用户程序调用操作系统时，有两个载体可以用来传递参数： 寄存器：比较小的数据如：一个字符、一个整数、一个浮点数 用户栈：比较长的参数如：文件名 对每个系统调用，操作系统都规定了参数和返回值的存放位置，用户程序必须遵循相应的规定 系统栈也称为核心栈，逻辑上属于操作系统空间 程序切换的同时伴随着堆和用户栈以及系统栈的切换，但硬件的栈指针是多个进程共享的。 作用： 中断响应时保存中断现场 保存函数调用返回点、参数、局部变量、返回值 内存中操作系统空间的一个固定区域 寄存器 硬件系统提供一套寄存器，由运行程序使用。 程序切换时，一般需要把寄存器的当前值保存起来，再次运行前再恢复。 程序状态字 指令计数器 SP regs fregs 地址映射寄存器 特权指令与非特权指令 特权指令(privileged instruction) 只有在管态才能执行的指令(影响系统状态) 特权指令只有操作系统（内核空间）才能执行，用户程序（用户空间）不可执行 非特权指令(non-privileged instruction) 在管态和目态都可以执行的指令(不影响系统状态) 处理机状态及状态转换 处理机状态 系统态（system mode）(管态，核态) 用户态（user mode) (目态，常态) 状态转换 管态 ->目态(中断返回，置程序状态字） 目态 -> 管态(中断，trap又称为陷入指令) 地址映射机构 逻辑地址映射到物理地址 逻辑地址(虚地址)：程序中产生的地址 物理地址(实地址)：存储器地址 存储保护设施 防止应用程序 侵犯操作系统空间 侵犯其它用戶空间 对共享区域的非法访问 地址检查 越界检查; 越权检查（对共享区域） 中断装置 发现并响应中断的硬件机构 当前（PSW，PC）->系统栈 中断向量（PSW，PC）->寄存器；中断向量由硬件实现 通道与DMA 通道：接受CPU委托完成输入输出操作任务，即负责IO操作的处理机 DMA：接受CPU委托直接依靠硬件完成数据在主存和块设备之间的传输 相同点：实现IO设备和内存之间建立数据直传通路 不同点 DMA只能实现固定的数据传送控制，而通道有自己的指令和程序 DMA只能控制一台或者少数几台同类设备，而一个通道可以控制多台同类或者不同的设备 I/O保护 定义所有I/O指令为特权指令 方便使用：用户使用I/O指令做I/O传输非常麻烦 防止发生冲突 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 01_概论 "},"docs/Operating_System/02_进程管理.html":{"url":"docs/Operating_System/02_进程管理.html","title":"02_进程管理","keywords":"","body":" 进程、线程与作业 多道程序设计 进程的引入 进程状态及状态转换 PCB(进程控制块) 进程的组成与上下文 进程的组成（进程映像） 进程的上下文 进程的队列 进程的类型与特征 进程类型 进程特征 进程间相互联系与相互作用 相互联系 相互作用 进程的创建与撤销 进程创建 进程撤销 进程汇聚和等待，唤醒 考虑生灭的进程状态转换图 进程与程序 的联系与差别 思考题 线程与轻进程 线程的概念 线程控制块（TCB） 线程的操作 线程的实现 用户级线程 核心级别线程 混合线程 作业 批处理作业 交互式作业 处理机调度 高级调度 中级调度 低级调度 小结： 进程、线程与作业 多道程序设计 [!tip] 单道程序设计：一次只允许一个程序进入系统的程序设计方法 缺点：资源利用率低. 多道程序设计：多个程序同时进入系统并投入执行的一种程序设计方法 例题 §进程P对磁盘数据进行处理，其处理流程为： §① 读入一块磁盘数据； §② 处理该块数据； §③ 把处理后的该块数据写到磁带上。 §假设：进程P要处理3个磁盘块的数据，读一个磁盘块数据需要40ms，处理一块数据需要20ms，写一块磁带数据需要80ms，并假设系统只有进程P运行。在不考虑系统开销的情况下， §问 题： § ⑴ 进程P把3块数据处理流程都完成，画出CPU运行、磁盘输入、磁带输出的时序图； § ⑵ 依据⑴画出的时序图，计算进程P等待设备I/O的时间。 [!warning] 对于内存中的程序数量： 道数过少，系统资源利用率低 道数过多，系统开销(system overhead)增大，程序响应速度下降 多道程序设计的问题 如何分配处理资源 对于存储资源的管理 设备资源管理：即分配策略 进程的引入 [!note] 暂停：保存现场(PSW+PC，寄存器） 推进：恢复现场(寄存器，PSW+PC) 暂停原因：(1) 自身原因：等待资源，启动IO (2) 剥夺CPU—给其它程序运行机会 进程的定义 进程是程序的一次执行 进程是可以参与并发执行的程序 进程是程序和数据一道通过处理器执行时所发生的活动 进程是具有一定独立功能的程序关于一个数据集合的一次运行活动. 进程是进程实体的运行过程，是系统进行资源分配和调度（对于没有内核级线程的前提下）的一个独立单位。 [!important] 动态：是程序的一次执行过程。同一程序多次执行会对应多个进程。这是进程和程序的本质差异 并发：可与其它进程同时执行，宏观同时，微观上“交替执行”，不要求多个CPU 进程状态及状态转换 进程状态（基本状态） [!note] 创建态：系统创建进程，操作系统给进程分配系统资源、PCB等等 就绪态：已经具备运行条件，等待空闲的CPU，进行调用 运行态：当CPU处于空闲阶段就会在就绪态的进程里面选择一个进行执行，也就是把CPU占据进入了运行态，一核的CPU就只可以一次运行一个进程，多少核的CPU可以有多少个进程处于运行态 阻塞态：因为某个事件而暂时不可用运行 终止态：运行进程从CPU撤销，操作系统就会回收资源、撤销PCB 进程状态转换由操作系统完成，对用户是透明的 进程在其生存期内经过多次状态转换 [!tip] 进程状态转换原因: CPU调度 进程在运行过程中需要等待某一事件 进程等待的事件发生. PCB(进程控制块) [!note] 标志进程存在的数据结构，其中保存系统管理进程所需的全部信息 例如：进程标识(pid)，进程状态，现场信息，调度参数，所属用户(uid) 作用 当调度某进程执行时，需要从该进程的PCB中查询其状态及优先级等参数 当调度到某进程后，根据PCB中的现场信息恢复现场，并根据PCB中的程序和数据的内存地址找到程序和数据 进程执行过程中，当需要与其它进程通信时，也要访问PCB 当进程发生进程切换时，需要将现场信息从系统栈弹出，保存于PCB中 系统建立进程时建立PCB，撤销进程时撤销PCB. 进程的组成与上下文 进程的组成（进程映像） 进程控制块（PCB） 程序 代码(程序段)：实现相应的功能 数据(数据段)：静态数据+动态堆和动态栈 堆栈(stack+heap) 栈：保存返回值、参数、断点、局部变量 堆：动态变量 进程的表记 进程的程序(PCB，代码和数据)称为进程影像(Process Image) 进程的上下文 [!note] PCB+程序 系统环境：地址空间，系统栈，打开文件表，… 上下文的切换 由一个进程的上下文转到另外一个进程的上下文 系统开销（system overhead) 运行操作系统程序完成系统管理工作所花费的时间和空间 进程切换时需要保存的现场信息 地址寄存器:保存当前CPU所访问的内存单元的地址 通用寄存器:用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果 浮点寄存器:用于存储浮点数字，它决定着计算机的计算精度。 SP(系统栈指针) PSW(程序状态字) PC(指令计数器) 打开文件表(页表) 进程的队列 [!note] PCB构成的队列：（不一定FIFO，单向或双向） 就绪队列：系统一个或若干个（根据调度算法确定） 等待队列：每个等待事件一个（可能对应不同设备各有一个，甚至对于一个设备不同请求一个） 运行队列 进程的类型与特征 进程类型 系统进程（内核态运行） 运行操作系统程序，管态，完成系统管理(服务)功能 一个系统进程所完成的内容相对独立和具体，在进程生存周期保持不变，因而它们通常对应一个无限循环程序，在系统启动后便一直存在，直到系统关闭 系统进程承担系统的管理和维护性任务，优先级高于一般用户进程 用户进程（用户态运行） 在操作系统之上运行的所有程序 运行用户(应用)程序，为用户服务 进程特征 [!note] 并发性：可以与其它进程一道向前推进； 动态性：动态产生、消亡，生存期内动态变化； 独立性：一个进程是可以调度的基本单位； 交互性：同时运行的进程可能发生相互作用； 异步性：进程以各自独立，不可预知的速度向前推进； 结构性：每个进程有一个PCB。 进程间相互联系与相互作用 相互联系 相关进程 同一家族的进程 可以共享文件，需要相互通讯，协调推进速度… 父进程可以监视子进程，子进程完成父进程交给的任务 无关进程 没有逻辑关系、同时执行的进程。 有资源竞争关系，互斥、死锁、饿死。 相互作用 直接相互作用 发生在相关进程之间，进程之间不需要通过媒介而发生相互作用 间接相互作用 发生在任何进程之间 进程的创建与撤销 进程创建 [!note] 向系统申请一个空闲PCB，并指定唯一的进程标识 为新进程分配资源 初始化新进程的PCB加载程序 将PCB入就绪队列. 例如：用户登录，作业调度，提供服务，应用请求. 进程撤销 [!note] 从系统PCB表中找到被撤销进程的PCB 检查被撤销进程的状态是否为执行状态。若是，则立即停止该进程的执行 设置重新调度标志，以便在该进程撤销后将处理器分配给其它进程 检查被撤销进程是否有子孙进程，若有子孙进程还应撤销该进程的子孙进程 回收该进程占有的全部资源并回收其PCB. 例如：正常结束，异常结束，外界干预 进程汇聚和等待，唤醒 进程汇聚 例如： Java语言中，子线程汇聚到父线程 用于数学计算，例如矩阵。， 进程等待 停止当前进程的执行 保存该进程的现场信息。 将进程状态改为等待. 引起进程等待事件，例如：请求系统服务，启动某种操作，新数据未获取，无新工作 进程唤醒 将被唤醒进程从相应的等待队列中移除 将进程状态改为就绪，并将该进程插入就绪队列. [!important] 父进程创建子进程与主程序调用子程序区别? 进程创建子进程后，父进程与子进程可并发执行 主程序调用子程序后，主程序暂停在调用点，子程序开始执行，直到子程序执行完毕返回，主程序才开始执行 考虑生灭的进程状态转换图 [!important] 进程与程序 的联系与差别 进程与程序的联系 进程包括一个程序 进程存在的目的就是执行这个程序 进程与程序的差别 程序静态，进程动态 程序可长期保存，进程有生存期 一个程序可对应多个进程，一个进程只能执行一个程序 思考题 [!note] 若系统中没有运行进程，是否一定没有就绪进程？是的。当系统中没有运行进程时，操作系统会立即触发调度程序。若就绪队列中存在进程，调度程序必然选择一个进程投入运行。因此，没有运行进程的唯一可能是就绪队列为空，即没有就绪进程。 若系统中既没有运行进程，也没有就绪进程，系统中是否就没有进程？否。系统中可能存在处于阻塞状态的进程（如等待I/O或事件），这些进程不占用CPU也不在就绪队列中，但仍然是系统中的有效进程。 在采用优先级调度时，运行进程是否一定是系统中优先级最高的进程？否。若系统采用非抢占式调度，即使有更高优先级的进程进入就绪队列，当前运行进程仍会继续执行，直到主动释放CPU。只有在抢占式调度下，运行进程才保证是优先级最高的。 某进程被唤醒后立即投入运行，是否说明系统采用剥夺式调度？否。例如，若原运行进程已主动阻塞（如等待I/O），此时唤醒的进程可能是唯一就绪进程，无需剥夺即可运行。这种情况与调度策略是否为剥夺式无关，因此不能以此判断。 线程与轻进程 线程的概念 进程中一个相对独立的执行流。（轻量级进程） 进程是CPU资源分配的最小单位 线程是CPU调度和执行的最小单位（仅仅对于内核级线程，而用户级线程对于内核透明） 多线程优点 切换速度快（地址空间不变）(light weighted) 系统开销小（用户级线程） 通讯容易（共享数据空间） [!important] 进程与线程的区别和联系 区别： 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位； 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行； 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。进程所维护的是程序所包含的资源（静态资源）， 如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler等；线程所维护的运行相关的资源（动态资源），如：运行栈，调度相关的控制信息，待处理的信号集等； 系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 联系： 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程； 资源分配给进程，同一进程的所有线程共享该进程的所有资源； 处理机分给线程，即真正在处理机上运行的是线程； 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。 线程控制块（TCB） [!note] 标志线程存在的数据结构，其中包含对线程管理需要的全部信息 内容：线程的标志和状态，调度参数，现场（寄存器，PC，SP），链接指针 存放位置：用户级线程位于目态空间，内核级线程位于系统空间 线程的操作 在进程创建时，同时为该进程创建第一个线程，用以运行程序，在以后适当的时候，通过“线程创建”系统调用创建线程 线程共享进程的代码段和数据段。但是线程有各自的用户栈，可以独立调用，占用CPU运行 当线程被剥夺处理器时，只需将其线程现场保存在该线程对应的栈区 当进程内的所有线程结束时，意味着进程结束，从而释放进程所占用的所有资源. 线程的实现 用户级线程 实现方法： 基于library函数（线程库），系统不可见 线程创建、撤销、状态转换在目态完成 TCB在用户空间，每个进程一个系统栈. 优缺点： 优点： 不依赖于操作系统，调度灵活 同一进程中多线程切换速度快(不需进入操作系统) 缺点： 同一进程中多个线程不能真正并行，即使在多处理器环境中 一个线程进入系统受阻，进程中其它线程不能执行 [!tip] 线程状态和进程状态 若同一进程中的多个线程至少有一个处于运行态，则该进程的状态为运行态 若同一进程中的多个线程均不处于运行态，但至少有一个线程处于就绪态，则该进程的状态为就绪态 若同一进程中的多个线程均处于等待态，则该进程的状态为等待态 核心级别线程 实现方法： 基于系统调用由操作系统创建 创建、撤销、状态转换由操作系统完成 线程是处理器调度的基本单位 TCB在操作系统空间，每个线程一个系统栈 对于核心级别线程，进程状态不具有实际意义 优缺点： 优点： 同一进程内多线程可以并行执行（多CPU） 进程中的一个线程被阻塞了，内核可以调度同一进程的其它线程占有处理器运行 缺点：线程的控制和状态转换需要进入操作系统，系统开销大 [!note] 用户级别线程和核心级别线程区别 核心级别线程操作系统可见；用户级别线程操作系统不可见 用户级别线程的创建、撤销和调度不需要操作系统的支持，且是在（程序）语言这一级处理的。核心级别线程的创建、撤销和调度都需要操作系统内核的支持 用户级别线程执行系统调用命令将导致其所属进程被中断，核心级别线程执行系统调用命令将导致线程被中断 在仅有用户线程的系统内，CPU调度以进程为单位。在有核心级别线程的系统内，CPU调度以线程为单位 用户级别线程的实体是运行在用户态下的程序，而核心级别线程的实体则是可以运行在任何状态下的程序 混合线程 Solaris系统 Light weighted process(LWP) 由Lib程序支持 每个task至少一个LWP 用戶级别线程与LWP可以多对多 LWP对操作系统可见 只有与LWP相联系的用户线程向前推进 [!tip] 多线程与多任务的区别： 多任务是针对操作系统而言的，代表操作系统可以同时执行的程序个数 多线程是针对一个进程而言的，代表一个进程内部可以同时执行的线程个数，每个线程完成不同的任务. 作业 [!note] 作业概念: 用户要求计算机系统为其完成的计算任务集合 作业步 作业处理过程中一个相对独立的步骤 一般一个作业步可由一个进程完成 某些作业步之间可以并行 作业分类:批处理作业，交互式作业. 作业控制块 标志作业存在的数据结构，其中包含对作业进行管理所需要的全部信息 如作业名称、作业状态、调度参数、资源请求、相关进程、作业长度、在输入井与输出井中的存放位置、记账信息等 [!tip] 作业和进程的区别 作业是用户向计算机提交的任务实体，而进程则是完成用户任务的执行实体，是向操作系统申请分配资源的基本单位 一个作业可由多个进程组成，一个作业至少由一个进程组成 作业的概念主要用在批处理系统中，而进程的概念则用在所有的多道程序系统中. 批处理作业 作业控制语言(JCL)：描述批处理作业控制意图的语言 作业说明书(JCL语句的序列）：一般以特殊符号起始 作业控制进程：解释并处理作业说明书的程序，执行作业控制程序的进程. 批处理作业的工作过程： 作业由假脱机输入程序控制进入输入井 经由操作系统的作业调度程序选中进入内存 同时由作业调度程序为其建立作业控制进程执行作业控制程序 作业控制进程解读作业说明书中的语句，并根据作业步的要求为其建立相应的进程 交互式作业 账户管理 /etc/passwd文件(创建用户时，系统将设置口令文件) passwd中包括注册用户的所有信息(用户名,口令,用户根目录,同组用户,余额…)，为系统文件 处理机调度 调度分为三个层次，分别为高级调度，中级调度，初级调度。 高级调度 确定某种规则来决定将作业调入内存的顺序。即作业调度 按一定的原则从外存上处于后备队列的作业中挑选一个(或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB)，以使它（们）获得竞争处理机的权利。 辅存（外存）与内存之间的调度 中级调度 暂时调到外存等待的进程状态为挂起状态。即决定将哪个处于挂起状态的进程重新调入内存。 PCB并不会一起调到外存，而是会常驻内存。 低级调度 从就绪队列中选取一个进程，将处理机分配给它。 小结： [!note] 作业与进程 作业进入内存后变为进程 一个作业通常与多个进程相对应 进程与线程 一个进程一般包含多个线程，至少包含一个线程 不支持多线程的系统，可视为单线程进程 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 02_进程管理 "},"docs/Operating_System/03_中断和处理器调度.html":{"url":"docs/Operating_System/03_中断和处理器调度.html","title":"03_中断和处理器调度","keywords":"","body":" 中断 中断与中断系统 中断的概念 中断装置 中断响应和处理的过程 中断嵌套与系统栈 中断优先级与中断屏蔽 中断处理逻辑 中断分析 关于等待和剥夺 中断处理程序 I/O中断处理 时钟中断程序 控制台中断程序 硬件故障处理 程序性中断的处理 用户程序自行处理中断 自愿性中断的处理 处理器调度 处理器调度算法 因素 CPU burst vs. I/O burst 剥夺式调度与非剥夺式调度 先到先服务算法 短作业优先 最短剩余时间优先算法(SRTN) 最高响应比优先(HRN) 最高优先数算法(HPF) 循环轮转算法（RR） 多级队列算法(MLQ) 反馈排队算法 处理机度时机 中断与处理器切换的关系 处理机调度过程 调度级别与多级调度 交换与中级调度 调度层次 术语 UNIX的中级调度 作业与高级调度 作业调度 作业的状态 作业控制块与作业表 批处理作业调度程序 批处理作业调度程序(1) 批处理作业调度程序(2) 实时调度 实时任务的分类 周期性实时事务 非周期实时任务 最早截止期调度 速率单调调度 最小裕度优先调度 多处理器调度 自调度 组调度 中断 中断与中断系统 中断的概念 [!note] 在程序运行过程中出现某紧急事件，必须中止当前正在运行的程序，转去处理这个事件，然后再恢复原来运行的程序，这一过程称为中断. 中断系统：中断装置（硬件），中断处理程序（软件） 中断装置 发现并响应中断的硬件机构 识别中断源，当有多个中断源时，按紧迫程度排队； 保存现场； 引出中断处理程序。 中断响应和处理的过程 中断源：引起中断的事件。 中断控制器：CPU中的一个控制部件，包括中断控制逻辑线路和中断寄存器 中断寄存器：保存与中断事件相关信息的寄存器。 中断字：中断寄存器的内容。 [!tip] 中断类型 强迫性中断 自愿性中断 中断向量 中断处理程序的运行环境与入口地址（PSW，PC） 每类中断事件有一个中断向量, 中断向量的存放位置是由硬件规定的, 中断向量的内容是OS在系统初始化时设置好的。 中断向量mode应为系统态 中断嵌套与系统栈 中断嵌套 [!note] 系统在处理一个中断事件的过程中又响应了新的中断，称系统发生了中断嵌套 一般原则：只允许响应更紧迫的中断事件，中断嵌套的层数大多不会超过一个值（中断优先级别个数） 实现方法：中断响应后立即屏蔽不高于当前中断优先级的中断源。 系统栈 [!note] 系统栈：系统区，位置由硬件确定，保存中断现场信息 对于嵌套中断，现场恢复的次序和保存次序相反，所以保存现场信息的数据结构是栈，由操作系统访问 系统栈保存的现场信息有中断装置保存的被中断程序的PSW和PC，还保存由中断处理程序保存的如通用寄存器的值等其它现场信息。 系统栈还传递操作系统子程序之间相互调用的参数，返回值和返回地址。 中断相当于是特殊的子程序调用，只不过它的发生时刻具有不确定性。 由于进一步保存现场信息是通过运行中断处理程序完成，程序运行时可以进行中断嵌套，为保证正确操作系统不允许在保存现场信息时响应中断 恢复现场信息也是由中断处理程序来完成，此时的工作也不允许响应中断 关中断：尽管产生了中断源且发出了中断请求，但CPU内部的PSW中的中断允许位被清除，此时不允许CPU响应任何中断，此现象为关中断。 中断优先级与中断屏蔽 中断优先级 中断优先级：根据引起中断的事件的重要性和紧迫程度，硬件将中断源分成若干个级别 硬件规定的中断响应次序，依据紧迫程度；处理时间。 只允许高优先级别中断可以嵌入低优先级中断 中断屏蔽 暂时禁止一个或多个中断源向处理机发出中断请求，屏蔽所有中断源就是关中断 硬件系统提供中断屏蔽指令，通过它可以暂时禁止中断源向处理机发送中断请求，同时还有解除屏蔽指令 高优先级中断事件处理不受低优先级中断打扰； 程序调整中断响应次序。 中断处理逻辑 中断分析 关于等待和剥夺 何时等待？处于核心态，无嵌套中断或有嵌套 等待剥夺几次？可能多次 保存在PCB的是什么级别现场？核心级别 等待或者剥夺时系统栈如何？栈底是目态现场，然后是嵌套函数的返回点，参数，局部变量，返回值；如有嵌套，接下来是核心现场，然后是嵌套函数的返回点、参数、局部变量、返回值；（可能有多重） 中断处理程序 I/O中断处理 正常结束：准备好数据后启动通道继续传输；唤醒相关等待进程。 传输错误：复执（eg. 3次)；报告系统操作员。 时钟中断程序 Housekeeping 进程管理：重新计算进程调度参数(eg. 动态优先数) 作业管理：记录作业在输入井中等待的时间，以及当前的优先级别，以便作业调度 资源管理：动态统计运行进程占有和使用处理器等资源的时间 事件处理：在实时系统中定时向被控对象发送控制信号 系统维护：定时运行死锁检测程序和记账程序 实现软时钟：运用硬件间隔时钟和一个存储单元 硬时钟5ms发生一次中断，实现软时钟50ms，存储单元初值10，发生一次中断寄存器减1，直到寄存器为0 控制台中断程序 多个控制按钮对应多个中断向量 按下控制按钮产生中断信号，指向中断处理程序 硬件故障处理 电源故障处理 掉电：硬件设备应保持继续工作一段时间 内存，寄存器Þ外存，停止设备，停止处理机 恢复：故障排除后恢复系统现场 启动处理机，启动设备，外存Þ内存，寄存器 内存故障处理 内存单元出现错误，中断处理对其进行检测并确认错误后划为不可用区域 程序性中断的处理 只能由操作系统处理的中断 影响系统或其它进程：越界，非法指令，（处理：终止进程、调试） 需要系统管理或协助：页故障，缺段，（处理：动态调入） 可以由用户自己处理的中断 不影响系统和其它进程：除0，溢出，（处理：用户处理，或OS处理） 用户程序自行处理中断 编译时：为每个用户程序生成一个中断续元表（用户态） 运行时：执行调试语句，填写中断续元表 中断时：根据中断原因查中断续元表 为0，用户未规定中断续元，由OS标准处理 非0，用户已规定中断续元，由用户处理 [!TIP] 步骤： （1）目态程序在运行时发生溢出中断 （2）中断装置将PSW和PC值压入系统栈 （3）取中断向量并送入PSW和PC寄存器 （4）执行对应的操作系统中断处理程序 （5）访问用户程序中的中断续元表（假定非0） （6）系统栈中现场转移到用户栈 （7）中断续元运行环境和入口送PSW和PC （8）控制权转到中断续元，执行中断续元 （9）由用户栈弹出现场送PSW和PC （10）返回断点继续执行 自愿性中断的处理 访管指令（SuperVisor Call)形式： 准备参数 SVC n 取返回值 系统调用（system call)形式：返回值=系统调用名称（实参1,…,实参n) 编译程序会将系统调用形式翻译为访管指令形式 处理器调度 [!note] 3.2.1 处理器调度算法：按什么原则分配 3.2.2 处理器调度时机：何时重新分配 3.2.3 处理器调度过程：如何完成分配 处理器调度算法 因素 考虑因素：CPU利用率 ; (max)，吞吐量 ; (max)，周转时间 ; (min)，响应时间 ; (min)，系统开销 ; (min) 调度参数 CPU burst vs. I/O burst 阵发期 CPU burst cycle: 进程(线程)一次连续使用CPU做计算 I/O burst cycle: 进程(线程)一次使用设备做I/O操作 进程运行行为 CPU调度：考虑处于CPU burst进程集合 下一个CPU burst的长度估算: 令τn是估计的第n个CPU阵发期的长度， tn的值是进程最近一次CPU阵发期长度，则有如下估算公式: τn+1=αt*n + (1-α)τn 参数α(0≤α≤1)控制tn和τn在公式中起的作用：当α=0时，τn+1=τn；当α=1时，τn+1=t*n。通常α取0.5 剥夺式调度与非剥夺式调度 剥夺式(preemptive) 就绪进程可以从运行进程手中抢占CPU 获得处理机的进程有3种:进程运行,直到结束; 等待 ;被抢先 非剥夺式(non-preemptive) 就绪进程不可从运行进程手中抢占CPU 获得处理机的进程有2种：进程运行,直到结束；等待 先到先服务算法 FCFS（First Come First Serve)：按进程申请CPU（就绪）的次序 优点：“公平“ 缺点：短作业等待时间长 短作业优先 SJF(Shortest Job First)：按CPU burst长度先执行时间短的作业，默认为不可抢占 §Process Arrival time Burst time § P1 0 12 § P2 0 5 § P3 0 7 § P4 0 3 Gantt Chart： 特点： 假定所有任务同时到达，平均等待时间最短，也可以退出平均周转时间最小 忽略了作业等待时间，长作业可能被饿死 例题： §现有三个同时到达的作业J1，J2和J3，它们的执行时间分别为T1、T2和T3，且T1，系统按照单道方式运行且采用短作业优先算法，则平均周转时间为 (3T1+2T2+T3)/3 最短剩余时间优先算法(SRTN) 可剥夺SJF，选择剩余时间最短的进程或线程 §Process Arrival time Burst time § P1 0 12 § P2 1 9 § P3 3 6 § P4 5 3 Gantt图: 例题： 最高响应比优先(HRN) §Highest Response Ratio Next RR=(BT+WT)/BT=1+WT/BT BT=burst time WT=wait time 计算每个作业的响应比，选择响应比最高的作业优先投入运行，类似于动态的优先级调度 优点 同时到达任务, 短者优先 长作业随等待时间增加响应比增加 例题：§一个作业8:00到达系统，估计运行时间为1小时。若从10:00开始执行，则其响应比为_。 RR=(BT+WT)/BT=1+WT/BT=1+2/1=3 最高优先数算法(HPF) 用于实时系统 静态优先数(static) 在进程创建时分配，生存期内不变 简单，开销小 公平性差，可能会造成低优先数进程长期等待 适合批处理进程 动态优先数(dynamic) 进程创建时继承优先数，生存期内可以修改 获得资源优先数提高 就绪时随等待处理机时间增长而提高 资源利用率高，公平性好 开销大，实现复杂 最高优先数算法有非剥夺式和剥夺式数 非剥夺式：获得处理机的进程运行，直至终止或者等待 剥夺式数：获得处理机的进程运行，直至终止或者等待，出现高优先级的进程（新创建或被唤醒的进程） 例子： §可抢占CPU §Process Arrival time Priority Burst time §P1 0 0 8 §P2 2 1 5 §P3 4 3 7 §P4 0 2 3 §P5 5 7 2 Gantt Chart: 例题： 循环轮转算法（RR） 系统为每个进程规定一个时间片，所有进程按照其时间片长短轮流的运行 适用于分时系统，利于多用户交互 基本的轮转 时间片(quantum,time slice)长度固定，不变 所有进程等速向前推进 改进轮转：时间片长度不定，可变 对于时间片长度： 几十毫秒~几百毫秒(eg. 50ms) 过长：响应速度慢 过短：系统开销(overhead)大 例子 §RR可抢占CPU调度：time slice=4ms §Process Arriveral time Burst time §P1 0 17 §P2 0 10 §P3 0 3 § Gantt Chart: 例题 多级队列算法(MLQ) 多级队列 多个就绪队列，进程所属的队列固定 每个队列可以采用不同的调度算法 例如在通用系统中： 队列1：实时进程就绪队列(HPF) 队列2：分时进程就绪队列 (RR) 队列3：批处理进程就绪队列 (HPF) 当CPU空闲时 优先选择队列1中进程。如果队列1为空，则选择队列2中进程，否则选择队列3中进程 反馈排队算法 在多级队列的基础上，多个就绪队列，进程所属队列可变，并且越往上的队列优先级越高，但时间片越小 处理机度时机 运行进程结束 运行进程等待 处理器被剥夺 中断与处理器切换的关系 中断是处理器切换的必要条件，但不是充分条件 必然引起进程切换的中断：进程自愿结束，exit()，进程等待，进程强行终止 可能引起进程切换的中断：时钟，系统调用 处理机调度过程 进程切换： 中断处理后，需要进程切换则转入处理器分派程序dispatcher，选择上升进程运行 [!tip] dispatcher 保存下降进程的现场：寄存器->PCB 选择上升进程： 按调度算法在就绪队列选择进程 为防止就绪队列为空，系统通常安排一个调度级别最低的进程，当系统中无其它进程时，运行“闲逛”进程 恢复上升进程的现场：PCB-> 寄存器（先恢复通用寄存器和地址寄存器，PSW和PC然后用一条指令恢复 调度级别与多级调度 交换与中级调度 调度层次 高级调度 中级调度 低级调度：处理器调度 术语 [!note] 交换(swapping)：进程在内存和外存储器之间的调度 中级调度(mid-level scheduling)：是系统控制并发程度的一个级别 并发度(degree of multi-programming)：同时向前推进的进程个数 交换的目标：减少并发度，缓解内存空间 UNIX的中级调度 两个情况： 移入SRUN状态进程 如内存不够 移出SWAIT和SSTOP状态进程； 如还不够，移出SSLEEP和SRUN状态进程 条件 待移入进程在外存时间>=3秒 待移出进程在内存时间>=2秒 作业与高级调度 作业调度 作业调度：将一个作业由（磁盘的）输入井调入内存，并为其建立相应的进程PCB，使其具有运行的资格 批处理作业的处理结果：程序的执行结果；计帐信息 作业的状态 提交: 输入机向输入井传送 后备: 在输入井,尚未进入内存 执行: 分解为进程,在内存处理 完成: 处理完毕,结果在输出井 退出: 由输出井向打印机传送 状态转换： 作业控制块与作业表 JCB JCB（Job Control Block）：作业标识，所属用户，作业状态，调度参数，输入井地址，输出井地址，资源需求，进入时间，处理时间，完成时间 SPOOling输入建立，作业调度使用，SPOOling输出撤销 批处理作业调度程序 批处理作业调度程序(1) 在后备作业集合中选择作业，并为其建立作业控制进程来处理该作业。 其中为作业建立控制进程： 批处理作业调度程序(2) 实时调度 [!note] 实时任务：具有明确时间约束的计算任务，即明确开始结束 实时调度：合理安排就绪实时任务的执行次序，满足每个实时任务时间约束条件的调度 实时任务的分类 硬实时和软实时（对应于实时操作系统） 硬：必须满足任务截止期要求 软：期望满足截止期 周期性和随机性 周期：固定时间发生 随机：发生时刻不确定 周期性实时事务 可调度的必要条件：处理时间小于等于发生周期 多个进程时，所有进程处理时间和发生周期的比值和小于等于1 非周期实时任务 [!tip] 若实时任务到达服从参数为λ的泊松分布时，当1/λ值很小，小于等于一个阈值，则可以将其视为周期性实时任务调度，任务的平均到达时间间隔为1/λ——平均周期 最早截止期调度 EDF: 优先选择完成截止期最早的实时任务 对于新到达的任务，如果其完成截止期先于正在运行任务的完成截止期，则重新分派处理器，即剥夺 可调度条件：，C处理时间，T发生周期 速率单调调度 RMS： 面向周期性实时事务，非剥夺式 优先调度发生周期最短（频度最高）的实时任务 可调度条件： 例题： 最小裕度优先调度 类似最早截止期优先，优先级基于一个进程的裕度 L=D-(T+C) L为裕度，T为当前时间，D为任务的截止期，C为剩余处理时间 最小裕度优先可调度的充分条件与最早截止期优先相同 多处理器调度 自调度 均衡调度 一个就绪队列，多处理机访问互斥 系统负载利用率高，但是程序亲和性小 组调度 将一组相关(合作)的线程同时分派到多个处理机上运行 避免合作线程之间的相互等待 降低开销,提高运行效率 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 03_中断和处理器调度 "},"docs/Operating_System/04_互斥同步与通讯.html":{"url":"docs/Operating_System/04_互斥同步与通讯.html","title":"04_互斥同步与通讯","keywords":"","body":" 互斥同步与通讯 并发进程 前驱图 顺序程序 并发程序 程序并发执行的条件 与时间有关的错误 进程互斥 共享变量与临界区 临界区域与进程互斥 进程互斥的实现 进程互斥的软件实现 Dekker算法 Peterson算法 Lamport面包点算法 Eisenberg/Mcguire算法 进程互斥的硬件实现 硬件提供存储障碍语句 硬件提供原子变量 进程同步 进程同步机制 信号量与PV操作 用信号量实现进程互斥 用信号量实现进程同步 用信号量实现资源管理 小结 生产者与消费者问题 并发性提升策略 读者与写者问题 障栅问题 三台打印机管理 吸烟者问题 生产线问题 寺庙问题 进程同步与互斥 条件临界区 管程 管程的语义 条件变量操作 管程与PV操作的等价性 用管程构造PV操作 用PV操作构造管程 管程的嵌套调用问题 进程高级通讯 进程通讯概念 进程通讯模式 共享内存模式（shared memory) 消息传递模式 直接方式 实现方式 间接方式 [TOC] 互斥同步与通讯 并发进程 前驱图 有向无环图，图中每个结点表示一个语句、一个计算步骤、或一个进程 结点间的有向边表示偏序或前趋(precedence relation)关系 在前趋图中，没有前趋的结点称为初始结点，没有后继的结点称为终止结点 每个结点可以有一个权重(weight)，它可以表示该结点所包含的程序量或计算时间 类似于图论里的AOE网 顺序程序 程序顺序执行 内部顺序性：对于一个进程来说，它的所有指令是按序执行的 外部顺序性：对于多个进程来说，所有进程的活动是依次执行的 输入(I)、计算(C)、打印(P)三个活动构成的进程 顺序程序特性：连续，封闭，可再现 并发程序 程序并发执行 内部并发性：一个程序的并发性 外部并发性：多个程序之间的并发性，之间的交叉点由中断引起 特性：间断，非封闭，不可再现 并发程序的表示: cobegin S1; S2; …; Sn coend; parbegin S1; S2; …; Sn parend; 程序并发执行的条件 在失去封闭性的条件下，保持可再现性。 R(pi)={a1,a2,…,am}表示程序pi在执行期间所需读取的所有变量的集合，称为“读集” W(pi)={b1,b2,…,bn}表示程序pi在执行期间所需改变的所有变量的集合，称为“写集” 若两个程序p1，p2满足如下条件，则能够保持可再现性，因而可以并发执行。称为Bernstein条件。 [!note] R(p1)∩W(p2)∪R(p2)∩W(p1)∪W(p1)∩W(p2)=Φ 与时间有关的错误 同步写 [!warning] 程序并发交叉过程中改变了变量的运行环境，会导致错误。 关于就绪队列的整队问题 结论:该错误因共享就绪队列引起,对就绪队列操作不当,也是与时间相关的错误导致结果不唯一. 两进程申请两个独占性资源 [!note] 错误原因之1： 进程执行交叉(interleave); 错误原因之2： 涉及公共变量(x)。 Remarks: 某些交叉结果不正确; 必须去掉导致不正确结果的交叉。 进程互斥 共享变量与临界区 [!note] 共享变量(shared variable)：多个进程都需要访问的变量 临界区域(critical region)：访问共享变量的程序段；访问同一组共享变量的临界区不能并发 表示 共享变量: shared 临界区域: region do 临界区域与进程互斥 定义：多个进程不能同时进入关于同一组共享变量的临界区域，否则可能发生与时间有关的错误，这种现象称为进程互斥。 [!important] （1）任何时刻最多只能有一个进程处于同一组共享变量的相同的临界区域 （2）任何时刻最多只能有一个进程处于同一组共享变量的不同的临界区域 ​ Remarks: 互斥是相对于公共变量而言的 进程互斥的实现 进入区，临界区，退出区，剩余区 Framework Requirements: 空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区; 忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待; 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿) 让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。 临界资源：一次只允许一个进程使用的资源 当关于某一组共享变量的临界区均为空时，一个要求进入该组公共变量的某一临界区的进程应当能够立刻进入； 当关于某一组共享变量的某一临界区被占用时，一个要求进入该组共享变量某一临界区的进程应当等待； 当一个进程离开关于某一组共享变量的某一临界区时，应当允许某一个等待该组共享变量某一临界区的进程进入； 进程互斥的软件实现 完全用程序实现，不需特殊硬件指令支持 可用于单CPU和多CPU环境中 有忙式等待问题 不进入等待状态 它反复地检测一个条件，如果条件成立就反复地循环 如果CPU被剥夺了，就回到就绪状态 以后如果再分配CPU，还检测这个条件 [!tip] 忙式等待与阻塞式等待(让权等待) 相同之处：在于进程都不具备继续向前推进的条件 不同之处 处于忙式等待的进程不主动放弃CPU，尽管CPU可能被剥夺，因而是低效的 而处于阻塞状态的进程主动放弃CPU，因而是高效的 软件实现方法 在进入区设置和检查一些标志来标明是否有进程在临界区中 如果已有进程在临界区，则在进入区通过循环检查进行等待 进程离开临界区后则在退出区修改标志 Dekker算法 Peterson算法 2个进程互斥的最简洁的算法 如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。 Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则。 Lamport面包点算法 想进入临界区的进程抓号，抓到号之后按由小到大的次序依次进入。 若抓到相同的号，按进程编号依次进入。这样可以把要进入临界区的进程排一个全序,Definition: (a,b) 互斥性：多个进程竞争进入临界区时, 抓到号且二元组(number[i],i)最小的进程获准进入临界区, 其它进程将在第一个while循环或第二个while循环处等待, 进展性：当仅有一个进程想进入临界区时, 该进程可以立即进入; 当有多个进程想进入临界区时，抓到号且二元组(number[i],i)最小的进程获准进入, 有限等待性：对任意一个想要进入临界区的进程Pi, 设其抓到号码为number[i], 按二元组(number[i],i)次序排在Pi之前的竞争进程数量是有限的, 在最坏情况下Pi将等待n-1个排在其前面的进程进入并离开临界区后获准进入临界区 Eisenberg/Mcguire算法 [!tip] int turn; //0..n-1; 初始任意 flag[i]==idle: 进程Pi不想进入临界区; flag[i]==want_in: 进程Pi想进入临界区; flag[i]==in_cs: 进程Pi想进入或已进入临界区 n个进程首尾相连 如果Pi想要进入临界区，将状态置为want_in，还需要看从turn开始到i-1是否有想要进入临界区的进程。 如果从turn开始到i-1，这些进程都不想进入临界区(idle)，则Pi有机会进入临界区，将状态置为in_cs 一个进程将自己状态置为in_cs后，要检测其它进程状态是否为in_cs，如果都不是in_cs，则可以进入临界区。 如果除了自己外，还有其它进程状态为In_cs，则从头来。 [!note] 互斥性：仅当flag[i]==in_cs, 且对所有j!=i, flag[j]!=in_cs时, 进程Pi才进入临界区域 进展性：临界区空闲时, 排在序列turn, turn+1, …, n-1,0,1, 2,…,turn-1最前面的申请进入临界区的进程获准进入临界区 有限等待性：进程离开临界区时,按循环次序turn+1, …, n-1,0,1, 2,…,turn-1确定唯一一个竞争进程为其后继, 所以一个进程最多等待n-1个进程进入并离开临界区后一定能进入临界区 进程互斥的硬件实现 [!warning] 软件互斥算法一般适用于单处理机系统，多机环境下可并行执行的指令的效果可能是重排序执行的结果，会不满足互斥性 硬件提供存储障碍语句 存储障碍（memory barrier）该指令出现在相继指令之间，保证前面指令先于后面指令执行 例如Peterson算法： flag[0]=1; memory_barrier(); turn=1; 保证flag[0]=1和turn=1的次序不被重排序，从而保证算法在多处理环境下的正确性 硬件提供原子变量 原子变量（atomic variable)：对一个基本变量的访问与修改不被分割的变量 在现代计算机系统中都支持原子变量，若上例中count被说明为原子变量，则对count++ 的上述三条汇编指令就不会被打断。 原子变量并没有完全解决竞争条件的问题 硬件提供“测试并设置”指令：将内存中一个单元的值取出，再送一个值。为原子操作。 int test_and_set(int *lock){ int temp; temp=lock; *lock=1; return(temp); } //增加全局变量waiting[]以满足有限等待性 waiting[i]=1; key=1; while(waiting[i]&&key) key=test_and_set(&lock); waiting[i]=0; 临界区 J=(i+1)%n; while(((j!=i)&&(!waiting[j])) j=(j+1)%n; //解锁 if(j==i) lock=0; //唤醒 else waiting[j]=0; 其余部分 硬件提供“交换”指令：将内存中两个单元的内容相互交换，为原子操作。 void swap(int &a,&b){ int temp; temp:=*a; *a:=*b; *b:=temp; }; 满足互斥性，进展性，不满足有限等待性 waiting[i]=1; key=1; while(waiting[i]&&key) swap(&lock,&key); waiting[i]=0; 临界区 J=(i+1)%n; while(((j!=i)&&(!waiting[j])) j=(j+1)%n; if(j==i) lock=0; else waiting[j]=0; 其余部分 [!note] test_and_set指令和swap指令是原子的，不可中断的 test_and_set实际上是：将内存中一个单元的内容取出，再送一个新值 swap实际上是：交换内存两个单元的内容 硬件提供“关中断”和“开中断”指令： 开关中断只在单CPU系统中有效; 限制了处理器交替执行程序的能力，影响并发性。 只能操作系统使用 进程同步 [!important] 同步：一组进程，为了协调其推进速度，在某些点处需要相互等待或者相互唤醒，进程之间这种相互制约的关系称为进程同步。 进程同步是合作进程之间有意识的行为，只能发生在相关进程之间 进程同步机制 用于实现进程同步的工具称为同步机制 描述能力够用、可实现、高效,使用方便 信号量与PV操作 信号量是一个结构体 typedef struct { int value; PCBpointer queue;//FIFO队列 }semaphore P操作 Procedure P(var s:semaphore) s.value:=s.value-1; If s.value asleep(s.queue): (1) 执行此操作进程的PCB入s.queue尾（状态改为等待） (2) 转处理机调度程序，重新分派CPU V操作 Procedure V(var s:semaphore) s.value:=s.value+1; If s.value wakeup(s.queue)：s.queue链头PCB出等待队列，进入就绪队列（状态改为就绪） [!tip] 信号量变量的规定 必须置一次初值，只能置一次初值，初值>=0 只能执行P操作和V操作，所有其它操作非法 当s.value>=0时，s.queue为空 当s.value 当s.value初=1时，可以实现进程互斥 当s.value初=0时，可以实现进程同步（不一定为0） 当s.value的初值为非1的正整数时，可以用来管理同种组合资源，申请时执行一次P操作，归还时执行一次V操作 用信号量实现进程互斥 例子：借书系统 用信号量实现进程同步 V操作作为唤醒操作，P操作被唤醒 用信号量实现资源管理 组合资源：若干相对独立的资源构成的资源集合，其中每个相对独立的资源称为子资源。 同种组合资源：相同类型的子资源构成组合资源 P操作相当于申请资源，V操作相当于释放资源 小结 [!note] P操作相当于申请资源，V操作相当于释放资源。 P操作和V操作在系统中总是成对出现的，它们即可以出现在同一进程中，也可以出现在不同的进程中 同步进程之间具有某种合作关系，如在执行时间上必须按一定的顺序协调进行，或者共享某种资源 互斥进程彼此在逻辑上完全无关，它们的运行不具有次序的特征 生产者与消费者问题 [!note] 缓冲区B:Array[0..k-1] Of item 生产者生产物品放入B中，消费者从B中取物品消费 箱子可以看做是一个缓冲区，且这个缓冲区是有限的，编号从0到k-1，容量是k。所以生产消费问题也叫有界缓冲区问题。 [!tip] 为了方便编程，将缓冲区设置为环形。In：放入指针，out：取出指针 问题分析 其中生产者和消费者在加工和消耗没有直接关系 在这里P操作可以看作申请资源或者被唤醒，V则是释放资源或者唤醒进程 具体 其中P(mutex)和V(mutex)实现进程的互斥 并发性提升策略 生产者和消费者：不操作B的相同分量(还没生产，消费者取)。 两个共享相同缓冲区B,但是有不同信号量实现互斥 读者与写者问题 一组公共变量(数据)，有2组进程访问，它们都要访问这组公共数据，一组对公共数据进行读，一组对公共数据进行写。 有m个读者，n个写者。这些读者读取这些数据，但是不修改数据。写者访问数据时可以修改数据。 同步读：R-R可以同时 异步写：R-W不可同时，W-W不可同时 障栅问题 若干进程并发，都向一个障栅推进，并在障栅处等待所有进程都到达再继续推进 其实就像一个协调器，让所有进程重新在同一起跑线 三台打印机管理 同种资源管理问题 编写一个申请函数require和一个释放函数return。 require当有打印机空闲时，返回分得的打印机的编号；当无打印机空闲时则等待，被唤醒后返回分得的打印机的编号。 Return用于释放指定编号的空闲打印机，当有申请者等待时就将其一唤醒 吸烟者问题 假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放到桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者一个信号告诉已完成，此时供应者就会将另外两种材料放到桌上，如此重复（让三个抽烟者轮流地抽烟） 传统解法 Simultaneous P-operation SP(S1,t1,d1;…;Sn,tn,dn); if S1>=t1 and … and Sn>=tn then for I:=1 to n do Si:=Si-di endfor else 将运行进程的PCB连到第一个 Si 将该进程的指令计数器内容设置为SP操作的起始位置，使得当该进程重新执行时可以对所有等待条件重新进行评估 SV(S1,d1;…;Sn,dn) { for(i=1; i 将Si队列上的进程PCB取出，连到就绪队列中； 所以最终解法： 生产线问题 生产者和消费者问题的变种 自行车生产线上有一只箱子，其中有k个位置，每个位置可以存放一个车架或一个车轮，有3个工人，两个工人生产车架和车轮，另一工人则取车架和车轮 信号量： semaphore empty; (空位，k) semaphore frame; (车架，0) Semaphore wheel; (车轮，0) 有死锁情况：K个车轮，k个或k-1个车架，所以增加信号量避免死锁 semaphore S1; (初值 k-2，车架不超过k-2个) semaphore S2; (初值 k-1，车轮不超过k-1个) 寺庙问题 某寺庙有老和尚、小和尚若干。庙内有一水缸，由小和尚提水入缸，供老和尚饮用。水缸可容纳30桶水，每次入水、取水仅为一桶，不可同时进行。水取自同一井中，井口狭窄，每次只能容纳一个水桶取水。设有5只水桶，老和尚与小和尚共用。试用信号灯与PV操作给出老和尚和小和尚的活动 信号量定义： semaphore empty; (30) //水缸容量 semaphore full; (0) //当前水量 semaphore bucket; (5) //水桶数 semaphore mutex_bigjar; semaphore mutex_well; 注意先申请empty，在申请bucket，这样避免死锁，即所有桶都在老和尚手里等待取水 若在上述解法中存在多个小和尚、老和尚时，P操作的不当顺序会引起死锁。假设先P(bucket)**然后再**P(empty)就会出现死锁 死锁一般都是在极限状态的时候判断 思想：范围或者等级更大的信号量可以包含小的信号量 进程同步与互斥 [!important] 使用信号量和PV操作的规则 互斥问题（互斥访问临界资源的），同步问题（具有前后执行顺序要求的） 对于互斥问题要设置互斥信号量，不管有互斥关系的进程有几个或几类，互斥信号量的个数只与临界资源的种类有关。通常，有几类临界资源就设置几个互斥信号量，且初值为1，代表临界资源可用 对于同步问题要设置同步信号量，通常同步信号量的个数与参与同步的进程种类有关，即同步关系涉及几类进程，就有几个同步信号量。同步信号量表示该进程是否可以开始或该进程是否已经结束 在每个进程中用于实现互斥的PV操作必须成对出现；用于实现同步的PV操作也必须成对出现，即有P操作就必须有对应的V操作 但是，它们分别出现在不同的进程中；在某个进程中如果同时存在互斥与同步的P操作，则其顺序不能颠倒。必须先执行对同步信号量的P操作，再执行对互斥信号量的P操作。但是，V操作的顺序没有严格要求 条件临界区 形式： regionr when b do s 执行s的条件： 没有其它进程处于与r相关的条件临界区中 进入s时b为true 条件临界区的实现效率是比较低的 主要是条件表达式b的计算 必须同时满足互斥和b为真两个条件 当处于条件临界区内的进程执行完s后，全局变量将发生变化， 管程 [!note] 基本思想：将共享变量及其所有操作集中在一个模块中。 把分散在各进程中的临界区集中起来进行管理; 防止进程有意或无意的违法同步操作; 便于用高级语言来书写程序, 也便于程序正确性验证; 共享性、安全性、互斥性。 管程的形式 Type monitor_name=MONITOR(形参表) 共享变量说明;外部不可见 define 本管程内定义，本管程外使用的子程序名表； use 本管程外定义，本管程内使用的子程序名表； Procedure 过程名（形参表） 局部变量说明 Begin 语句序列 End; Function 函数名（形参表）:返回值类型； 局部变量说明 Begin 语句序列 End; …………… Begin 共享变量初始化语句序列 End; 管程的共享变量在管程外部不可见，外部只能通过调用管程中的子程序访问共享变量(类似于类的私有成员变量) 每次仅允许一个进程在管程内执行某个内部过程 进程互斥地通过调用内部过程进入管程 管程是一种特殊的数据类型，它将共享变量以及对共享变量的操作封装到一起，是一种集中式的同步机制 管程的语义 等待时释放管程的互斥权，唤醒时(P唤醒Q) P紧急等待，Q继续，直到Q退出或等待(Hoare) Q等待，P继续，直到P退出或等待(Java) 唤醒是管程中可执行的最后一个操作(Hansen) 三个队列 入口等待队列：每个管程变量一个，用于排队进入 紧急等待队列：每个管程变量一个，用于唤醒等待 条件等待队列：var c: condition; 可根据需要定义多个，用于设置等待条件 进入管程：申请管程互斥权 离开管程：如紧急等待队列非空，唤醒第一个等待者，否则开放管程 条件变量操作 Var c:condition;//指针，指向PCB队列头部 wait(c)：线程等待 signal(c)：唤醒 管程的应用：详见PPT 单一资源管理 生产者与消费者 读者写者 哲学家就餐 磁头引臂调度问题 嗜眠理发师问题 管程与PV操作的等价性 用管程构造PV操作 TYPE semaphore=MONITOR(init_value) VAR c:condition;//条件变量 count: integer;//整形变量 DEFINE P,V;//定义2个外部函数 //用管程构造P操作 PROCEDURE P; BEGIN count:=count-1; IF count 信号灯 用PV操作构造管程 管程的嵌套调用问题 管程嵌套： 一个进程在执行过程中调用某一管程中定义的外部函数，该函数在执行过程中可能又调用另一个管程中的外部函数 禁止嵌套：简单易行，但是过于严格的限制 允许嵌套，等待时释放当前管程互斥权 这是容易保证程序正确性的处理策略，而且开销比较小， 但并发性差; 允许嵌套，等待时释放所有管程互斥权。 并发性好，但是一旦等待结束，需要重新获得路经管程的互斥权，实 现困难，很难保证语义上的正确性; 允许嵌套，调用时释放路径管程互斥权。并发性好，但保证语义上的正确性更加困难 进程高级通讯 进程通讯概念 进程通讯：进程之间的相互作用 低级通讯（简单信号）：进程互斥，进程同步 高级通讯（大宗信息） memory sharing vs. message passing direct vs. indirect symmetric vs. non-symmetric buffering vs. non-buffering 进程通讯模式 共享内存模式（shared memory) 由OS提供：公共内存，互斥同步机制 消息传递模式 OS提供两个基本的系统调用命令：发送命令，接收命令 直接方式 对称形式：一对一，发送者在发送时指定接收者的名字，接收者在接收时要指定发送者的名字 send(R,message) receive(S,message) 非对称形式：多对一，发送者在发送时指定唯一的接收者，接收者在接收时不指定具体的发送者 send(R,message) receive(pid,message) 实现方式 有缓冲途径（(消息传递模式,直接方式,非对称形式) 消息在发送者和接收者的传输经过一次缓冲，提高了系统的并发性。 进程消息队列管理： Var Sm:semaphore; (0) 收取消息前：P（Sm）; 消息入队后：V（Sm); 消息队列互斥 Var m_mutex:semaphore;(1) P(m_mutex); 入列(出列)动作; V(m_mutex); Buffer pool management(缓冲池管理) Var Sb, b_mutex:semaphore; (k,1) //申请： P(Sb); P(b_mutex); 头缓冲出链; V(b_mutex); //释放： P(b_mutex); 缓冲入链头; V(b_mutex); V(Sb); 发送原语 //发送消息 Send(R,M) 根据R找接收者，否则带错返回； P(Sb); P(b_mutex); 取一空buf; V(b_mutex); size,text,sender => buf： P(m_mutex); 将载有消息的缓冲区挂到接收进程消息链的尾部； V(m_mutex); V(Sm); //接收消息 Receive(pid,N) P(Sm); P(m_mutex); 将消息链中的第一个载有消息的缓冲区由消息链取出; V(m_mutex); size,text=> N; sender => pid; P(b_mutex); 将空闲的消息缓冲区挂到消息链的尾部； V(b_mutex); V(Sb); Remarks Send/receive 为高级通讯原语，可用低级原语实现 Send/receive不是真正意义的原语，可以被中断 对于发送进程来说，信息需要由发送进程空间复制到消息缓冲区中。对于接收进程来说，信息需要由消息缓冲区复制到接收进程空间 发送进程空间和接收进程空间均属于用户区，而消息缓冲区属于操作系统区 无缓冲途径(消息传递模式,直接方式,非对称形式) 发送-接收都发生，信息由发送进程空间复制到接收进程空间，传送由操作系统完成 对于发送进程和接收进程都需要等待对方的行动 传输信息时可以利用寄存器 PCB中两个信号灯, S_m, S_w, 初值0 S_m: 接收进程等待 S_w: 发送进程等待 发送过程 根据R找到消息接收者 发送消息增1, 如接收进程等待将其唤醒, 即执行V(S_m) 等待消息传送完毕, 即执行P(S_w) 接收过程 等待消息到达, 即执行P(S_m) 消息由发送进程空间复制到接收进程空间 唤醒发送消息进程, 即执行V(S_w) 间接方式 [!note] 指相互通信的进程之间在通信时不是直呼对方名字，而是指明一个中间媒体，即信箱，进程之间通过信箱来实现通信 Send_MB(MB,M):将消息M发送到信箱MB中 Receive_MB(MB,N):由信箱MB中接收消息至N 对于间接方式可以多对多或者多对一 multi-sender -- multi-receiver multi-sender -- one receiver Type mailbox=record in,out:0..k;//读写指针，初值为0 s1,s2:semaphore; (k,0)//协调发送和接收进程 mutex:semaphore; (1)//用于对信箱操作互斥 //信箱体，可以保存k封信件 letter:array[0..k-1]of message end; Var mb:mailbox; //定义信箱类型的变量 有关信箱的4个系统调用命令 creat_MB delete_MB send_MB receive_MB //发送信息 Procedure send_mb(var mb:mailbox; m:massage); begin with mb do begin P(s1); //申请空位 P(mutex); letter[in]:=m; in:=(in+1)mod k; V(mutex); V(s2) //消息增加一个 end; end; //接收信息 Procedure receive_mb(var mb:mailbox; var n:massage); begin with mb do begin P(s2); //申请消息 P(mutex); n:=letter[out]; out:=(out+1)mod k; V(mutex); V(s1) //空位增加一个 end; end; ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 04_互斥同步与通讯 "},"docs/Operating_System/05_死锁与饥饿.html":{"url":"docs/Operating_System/05_死锁与饥饿.html","title":"05_死锁与饥饿","keywords":"","body":" 死锁与饥饿 死锁 死锁的定义 死锁类型 竞争资源引起的死锁 进程通讯引起的死锁 其他原因引起的死锁 死锁的条件 死锁的处理 资源分配图 死锁预防 预先分配法 有序分配法 死锁避免 银行家算法 资源分配算法 安全性检测算法 死锁发现 死锁检测算法 死锁的恢复 鸵鸟算法 饥饿与活锁 活锁 过河问题 简单组合资源死锁的静态分析 同种组合资源死锁的必要条件 死锁与饥饿 [!note] 死锁：竞争资源引起，无限等待，可检测，两个及以上的进程 饥饿：资源分配策略不公平引起，不一定处于等待状态，可能忙等，不确定性 死锁和饥饿都是由于进程竞争资源而引起的 [!important] 死锁，饥饿，死循环的区别 死锁:两个或两个以上的进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。 饥饿:进程由于长期得不到想要的资源，某进程无法向前推进的现象。 死循环:某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug 导致的，有时是程序员故意设计的。 死锁 死锁的定义 一组进程中的每一个进程，均无限期地等待此组进程中某个其他进程占有的，因而永远无法得到的资源，这种现象称为进程死锁 当死锁发生后，参与死锁的进程将一直等待下去，除非有来自参与死锁进程之外的某种干预，即死锁会导致进程无限等待 死锁时刻： 无限等待发生时 等待发生前（已注定死锁） [!tip] 参与死琐的进程至少有二个； 每个参与死锁的进程均等待资源； 参与死锁的进程中至少有两个进程占有资源； 死锁进程是系统中当前进程集合的一个子集。 死锁类型 [!note] 死锁产生原因： 时间上，进程调度时机不合适 空间上，独占资源分配不当，互斥资源部分分配又不可剥夺，根本原因就是资源不足 竞争资源引起的死锁 不同种资源 同种资源 进程通讯引起的死锁 P1：receive(P2,M1); P2: receive(P3,M2); P3: receive(P1,M3); 其他原因引起的死锁 After you / after you 死锁的条件 [!important] Coffman条件（必要条件） 资源独占（mutual exclusion）/ 互斥访问 不可抢占（non preemption） / 非剥夺式 保持申请（hold-while-applying） 循环等待（circular wait） 当每类资源只有一个实例时，Coffman条件为充要条件。 破坏上述任意一个条件可以消除死锁 死锁的处理 资源分配图 圆圆的进程方方资源 定义: G=(V,E), V=PÈR, P={p1,p2,…,pn}, R={r1,r2,…,rm}, E={(pi,rj)}&&{(rj,pi)}, pi属于P, rj属于R. 申请边(pi,rj): pi申请rj； 分配边(rj,pi): rj分配pi; 申请：由pi向rj画一条申请边，如可满足，改为分配边。 释放：去掉分配边。 [!important] 资源分配图的约简 寻找一个非孤立且没有请求边的节点pi, 若无算法结束 去除pi的所有分配边使其成为一个孤立节点; 寻找所有请求边都可满足的进程pj, 将pj的所有请求边全部改为分配边; 转步骤1 若算法结束时,所有节点均为孤点,则称资源分配图是完全可约简的 所以得到死锁定理：S为死锁状态的充分必要条件是S的资源分配图不可完全约简 死锁预防 对进程有关资源的申请活动加限制，即可保证没有死锁发生，即破坏死锁发生的必要条件 预先分配法 进程运行前申请所需全部资源 系统对于分配如果能够满足进程所需全部资源，则分配 进程在投入运行前已经占有所需要的全部资源，在运行期间不会发出资源申请命令 破坏“hold-and-wait”条件，即保持且申请条件 有序分配法 对于资源集R={r1,r2,…,rn}，事先将所有资源类排序 每个资源类赋予唯一的整数 规定进程必须按照资源编号从小到大的次序申请资源 进程pi可以申请资源rj中的实例和 对于任意rl，pi当前已占有rl, F(rl)等价 [!note] 一个进程可以申请某一资源类ri中的资源实例的充要条件是它已经释放了资源类rj中的所有资源实例，这里F(ri) 如果遵从这个条件，就不会发生死锁 如果进程需要同一资源类中的若干个资源实例，则它必须在一个命令中同时发出请求 有序分配策略通过破坏循环等待条件来预防死锁的发生。 死锁避免 [!note] 保证系统不进入死锁状态的动态策略 对于进程发出的每一个系统能够满足的资源申请命令实施动态检查，并根据检查结果决定是否实施资源分配 [!tip] 系统处于安全状态：即如果存在一个由系统中的所有进程构成的安全进程序列，那么系统处于安全状态。但是安全序列不唯一 进程序列安全，即p1,p2,…,pn可依次进行完 银行家算法 进程：事先申明所需资源最大量（并不分配）Claim=Max 系统：对每个可满足的资源申请命令进行安全性检查。安全则分配 //数据结构： Available: array[1..m]of integer; //系统可用资源 Claim: array[1..n,1..m]of integer; //进程最大需求 Allocation: array[1..n,1..m]of integer; //当前分配 Need: array[1..n,1..m]of integer; //尚需资源 Request: array[1..n,1..m]of integer; //当前请求 //临时变量：用于安全性检测 Work: array[1..m]of integer;//记录可用资源 Finish: array[1..n]of boolean;//记录进程是否可以执行完 资源分配算法 当进程请求资源时，首先判断当前请求资源是否小于等于其所需资源 紧接着如果满足则继续判断请求资源是否小于等于当前空闲资源 满足则预分配再进行安全性检测，不安全则回溯状态 安全性检测算法 给临时变量赋值 找到满足条件的即所需资源小于等于可用资源的进程 满足则完成该进程，增加可用资源继续找到可完成进程 最后如果所有进程都可以完成则安全 [!note] 银行家算法的保守性: 实际上，如果在不安全状态真正实施资源分配，系统不一定处于死锁状态。因为分配资源后安照，死锁状态是不安全状态的真子集 即死锁状态包含于不安全状态，但是安全状态一定不会发生死锁 死锁发现 死锁发现：如果一个系统中既未采用死锁预防策略，也未采用死锁避免策略，则系统有可能发生死锁 死锁检测算法 类似于银行家算法的安全检测算法，但是也可以通过资源分配图化简检测是否存在死锁状态 //数据结构： Available: array[1..m]of integer; Allocation: array[1..n,1..m]of integer; Request: array[1..n,1..m]of integer; //临时变量： Work: array[1..m]of integer; Finish: array[1..n]of Boolean; 只检测占有资源的进程，初始化时：Finish[i]=true, for Allocation[I]=0 [!note] 令P是所有进程的集合，P’包含于P，是所有占有资源的进程集合，则: P死锁等价于P’死锁 死锁的恢复 重新启动 终止进程：(1) 一次性全部终止；(2) 逐步终止(优先级，代价函数) 剥夺资源(resource preemption，(1) 逐步剥夺 (2) 一次剥夺 进程回退：参与死锁的进程回退到没有发生死锁的某个点，并由此点开始继续执行 鸵鸟算法 一个忽略潜在问题的一种算法策略，这种策略对计算机程序可能出现的问题采取无视态度（类似于鸵鸟在遇到危险时将头埋在地里，装作看不见）。鸵鸟算法的使用前提是，问题出现的概率很低。 饥饿与活锁 [!note] 饥饿：当等待时间给进程推进和响应带来明显影响时,称发生了进程饥饿 饿死：饥饿到一定程度的进程所赋予的使命即使完成也不再具有实际意义时称该进程被饿死 没有时间上界的等待：排队等待、忙式等待 忙式等待条件下发生的饥饿,称为活锁(live lock) 活锁 排队等待：当进程申请资源不能满足时，便进入等待状态，待资源得到时被唤醒，这种等待是排队等待 忙式等待条件下发生的饥饿,称为活锁(live lock)。活锁与死锁不同，活锁可能会解除 过河问题 有南北走向的河流如下图所示，河中有用石块搭成的便桥 每个石块上最多容纳一个过河者，两个相邻石块的间距恰好为一步 死锁分析： 当2个方向各有3人踏上石块时，必发生死锁 当2个方向各有1人分别踏上1、2或者5、6时，也会发生死锁 死锁预防 最简单的方式规定东、西两岸人员不能同时过河，但这可能导致饥饿或饿死，同时也影响并行度 根据资源数量，限制同时过河的人数在5个以内，这时至少有一个方向的过河人数不超过2个，当他们分别踏上3、4或者7、8石块时，对另一方向的过河人无影响 其次，对两岸竞争的1、2和5、6两对石块，采用有序分配法，即按1、2和5、6次序申请 简单组合资源死锁的静态分析 可复用资源：一次只能分配给一个进程使用的资源 组合资源：相对独立的若干资源构成的资源集合，每个相对独立的资源称为子资源 同种组合资源：由相同类型的子资源构成的组合资源. 每类子资源只有一个资源实例称为简单组合资源 [!important] 条件：已知各个进程有关资源的活动序列 判断：有无死锁可能性 步骤1：以每个进程占有资源，申请资源作为一个状态， 记作：(pi：aj：ak1,…,akn)=(进程：请求：占有); 步骤2：以每个状态为一个节点； 步骤3：如p1所申请资源为p2所占有，则由p1向p2画一有向弧(相同进程间不画)； 步骤4：找出所有环路； 步骤5：判断环路上状态是否能同时到达，如是有死锁可能性，否则无死锁可能性。 (1)环路中有相同进程，不能到达； (2)环路中有相同被占有资源，不能到达. 同种组合资源死锁的必要条件 [!NOTE] 当S 当S>=M+N时，至少有一个交叉有死锁。 M：资源数量 N：使用该类资源进程的数量 S：所有进程所需要该类资源的总量 反过来求当N个进程，每个进程所需同类资源为x1,x2, ... , xn，则当资源总数M大于等于∑(Xi-1)+1 这里考虑导致死锁的最坏情况，即每个进程都差一个资源就可以运行，所以在此基础上增多一个资源就可以打破死锁 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 05_死锁与饥饿 "},"docs/Operating_System/06_主存管理.html":{"url":"docs/Operating_System/06_主存管理.html","title":"06_主存管理","keywords":"","body":" 存储管理 存储管理功能 术语和概念 存储体系 内存资源管理 内存分区 内存分配 静态等长分区的分配 动态异长分区的分配 最先适应算法（First Fit） 下次适应算法（Next Fit） 最佳适应算法（Best Fit） 碎片处理 存储管理方式 界地址管理方式 技术原理 交换技术 覆盖技术 分页式存储管理 快表 多级页表 反置页表 页式存储管理 段式存储管理 段的共享 段的保护 段页式存储管理 Linux伙伴堆存储分配算法 总结 存储管理 存储管理功能 术语和概念 存储分配和去配 分配和去配的对象：内存、外存 分配和去配的时刻：进程创建、撤销、交换、长度变化(栈溢出, execl) 分配表和空闲表 存储共享 目的是节省内存、相互通讯 内容为代码和数据 存储保护：防止地址越界、防止操作越权 存储扩充 内存、外存结合，虚拟存储体系 速度接近内存，容量相当外存 地址映射 逻辑地址映射为物理地址 硬件支撑：基址寄存器(base)、限长寄存器(limit)、快表 [!tip] 固定地址映射：编译时确定映射关系 静态地址映射：程序装入时由OS完成映射（物理地址=逻辑地址+装入地址） 动态地址映射：在程序执行过程中完成映射，需要MMU内存管理单元 存储体系 三级存储体系 Cache(快，小，贵)+内存（适中）+辅存（慢，大，廉） 利用存储器访问的局部性原理 内存资源管理 内存分区 分区时刻：静态（系统初始化时），动态（申请时，系统运行中） 分区大小：等长或异长 通常做法： 静态+等长（页式、段页式） 动态+异长（段式、界地址） 内存分配 静态等长分区的分配 位示图 用一个bit代表一页状态，0表空闲，1表占用。（ 多单元） 分配：自头寻找第一个为0的位，改为1，返回页号； 去配：找到页后，将页号对应的位(bit)置为0。 空闲页面表：若干个连续的空闲页面作为一组登记在空闲页面表中。 空闲页面链：将所有的空闲页面连成一个空闲页面链 动态异长分区的分配 [!note] 空闲区域表: 记录当前未被进程占用的空闲区域。 初始时一个连续空闲区。长度=0为表尾。 尽量使空闲区域连续 最先适应算法（First Fit） 空闲区：首地址按递增排序 申请：取满足申请长度要求并且起始地址最小的空闲区域 下次适应算法（Next Fit） 空闲区：首址递增排列； 申请：自上次分配空闲区域 的下一个位置开始，选取第一个满足区域； 最佳适应算法（Best Fit） 空闲区：首址递增排列； 申请：取最小可满足区域； 例题 某基于动态分区存储管理的计算机，其主存容量为55MB（初始为空闲），采用最佳适配（Best Fit）算法，分配和释放的顺序为：分配15MB、分配30MB、释放15MB、分配8MB、分配6MB，此时主存中最大空闲分区的大小是__. 四种算法的比较 碎片处理 动态异长分区存储分配可能形成很小的空闲区域，称为碎片(fragment) 解决方法-紧凑(compaction)：移动所有的占有区域，以使所有的空闲区域连成一片 紧凑的时期：系统找不到足够大的空闲区时；定期 存储管理方式 界地址管理方式 基本原理： 内存空间划分：动态异长； 进程空间划分：一个进程一个区域，逻辑地址0 ~ l-1 所需表目：内存分配表，空闲区域表 所需寄存器：基址（首址）寄存器，限长寄存器 地址映射 由程序确定逻辑地址a 不满足：0则越界； a与b相加得到物理地址 [!note] 双对界：允许一个进程在内存中占有2个连续的区域。 代码(I空间)：一对界(b1,l1) 数据(D空间)：一对界(b2,l2) 技术原理 交换技术 内存不够时把进程写到磁盘（主存）（换出/Swap Out） 当进程要运行时重新写回内存（换入/Swap In） 需要考虑IO操作的CPU开销以及交换的单位大小 外存交换空间的管理方法，程序换入时的地址重定位问题 覆盖技术 在较小的内存空间中运行较大的程序 内存分区： 常驻区：被全局代码和数据占用，可划分多个 覆盖区：能被多个段共同（覆盖），可划分多个 分页式存储管理 内存空间划分：静态等长，2^i,称为一个页框(frame) 所需表目：页表（每个进程一个）；总页表：系统一个记录内存的分配和使用状态 所需寄存器：页表寄存器一个，页表长度寄存器一个，快表（TLB）：一组 快表 一组联想寄存器，用于保存正在运行进程的页表中的部分表项 页表长度一般大于快表的长度 通常只将正在访问的页面所对应的项目记录于快表中； 访问一个页面时，由逻辑页号先在快表中进行查找，如果找到则根据页框号和页内地址形成物理地址；如果没找到，则由逻辑页号在页表中查找，并将查找的页框号和页号送入快表，如快表满则淘汰。类似于Cache 快表命中率：访问页号在快表的次数与总访问次数之比 平均访存时间EAT=快表命中率*(快表访问时间+内存访问时间)+(1-快表命中率)*(快表访问时间+2*内存访问时间) ns 当有缺页时：EAT=快表命中率*(快表访问时间+内存访问时间)+(1-快表命中率)*(快表访问时间+2*内存访问时间)+缺页故障率* 缺页中断处理时间] ns 页号=逻辑地址/页面长度(取除法的整数部分)；十六进制时可以转换为二进制计算 页内偏移量 = 逻辑地址%页面长度（取除法的余数部分) 页面在内存中的起始位置:操作系统需要用某种数据结构记录进程各个页面的起始位置。 多级页表 二级或多级页表： 将4M的超大页表存储到离散的1K个页框中 仅将页表的部分内容调入内存. 对页表进行分页，称页表页，长度与页框相同(4K)，可移到外存 页表页之间可以不连续 外页表入口指向了页表页的起始地址(物理页框号) 多级页表：将大页表进行分页。内存仅存放当前使用的页表 系统为每个进程建立一张页目录表，它的每个表项对应一个页表页， 页表页的每个表项给出了页面和页框的对应关系 此时，页目录表为一级页表（外页表），页表页是二级页表。 [!important] 二级页表地址映射特点 访问数据需要三次访问内存（页目录表，页表页，存储单元）（N级页表访问一个逻辑地址需要N+1次访问内存。） 页目录调入内存 页表页按需调入内存 页面、页表页、页目录表的大小都刚好4k（占1个页框）即若采用多级页表机制，则各级页表的大小不能超过一个页面 EAT=快表命中率*(快表访问时间+内存访问时间)+(1-快表命中率)*(快表访问时间+(n+1)*内存访问时间) ns 反置页表 反置页表面向内存空间 对每个内存页框设置一个表项，表项的序号为物理页框号f，表项的内容为进程标识pid与逻辑页号p的有序对 反置页表大小固定 整个系统一个反置页表，为所有进程所共用，类似于FAT表 页式存储管理 采用杂凑技术的反置页表地址映射 在反置页表前增加一级杂凑表(冲突计数和空闲标志) 进行地址映射时，由hash(pid,p)计算得到反置页表入口地址 从入口地址开始向下探查找到对应的表项，位移f为对应的页框号 段式存储管理 内存空间划分：动态异长，每区一段。 进程空间划分：若干段，每段一个程序单位；逻辑地址结构由段号（段名）和段内地址（段内偏移量）所组成 所需表目 段表：每个进程一个，记录段号和段首地址的对应关系 空闲表：系统一个，用于记录并管理系统中的空闲区域 所需寄存器 段表首址寄存器：用于保存正在运行进程的段表首址，系统一个 段表长度寄存器：用于保存正在运行进程的段表长度，系统一个 快表(TLB)：系统一组，用于保存正在运行进程的段表中的部分项目 地址映射： 逻辑地址(s,d)->物理地址(b’+d) 段的共享 共享段表 进程段表(n)->共享段表(1)->共享段(1) 链接共享段时：段名查共享段表 找到，已有进程在用，共享计数加1，段表指向共享段表 未找到，读入内存填共享段表， 共享记数=1，段表指向共享段表 当一个进程结束对某一共享段的访问时，其共享计数减1 当共享计数减到0时，表示没有进程再使用该段，可以释放所占用的存储空间 类似于共享指针 段的保护 对于段表和快表加上访问权限（RWE) 进程对于共享段的访问往往需要加上某种限制 段页式存储管理 段式便于共享和保护 页式可以消除碎片问题 段页式：每个进程包含若干段，每个段包含若干页 内存空间划分和页式相同：物理地址=(页框号,页内地址)=(f,d) 进程空间划分：逻辑地址=(段号, 逻辑页号, 页内地址)=(s,p,d) 对应关系：每个进程包含若干段，每个段包含若干页 所需页表 段表：进程一个 页表：段一个 总页表：系统一个，用于记录并管理内存页面 所需寄存器 段表基址寄存器：保存正运行程序段表首址 段表基址寄存器：保存正运行程序段表首址 快表：一组联想寄存器 (快段表+快页表) (TLB)，保存正在运行进程的段表和页表中的部分表目 逻辑地址(s,p,d)->物理地址(f,d) Linux伙伴堆存储分配算法 总结 存储管理功能：存储分配和去配、存储共享、存储保护、存储扩充、地址映射 内存资源管理 静态等长分区的分配：字位映象图、空闲页面表、空闲页面链 动态异长分区的分配：最先适应 (First Fit)、下次适应法(Next Fit)、最佳适应 (Best Fit)、最坏适应 (Worst Fit) 存储管理方式 界地址管理方式（一维地址） 页式管理方式（一维地址） 段式管理方式（二维地址） 段页式管理方式（二维地址） ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 06_主存管理 "},"docs/Operating_System/07_虚拟存储器管理.html":{"url":"docs/Operating_System/07_虚拟存储器管理.html","title":"07_虚拟存储器管理","keywords":"","body":" 虚拟存储管理 外存空间管理 进程与外存对应关系 虚拟存储系统 虚拟页式存储系统 基本原理 内存页框分配策略(静态策略) 外存块的分配策略 页面调入时机 置换算法（淘汰算法 最佳淘汰算法 先进先出(FIFO) 最近最少使用算法(LRU) 最近不用的先淘汰(not used recently,NUR) 最不经常使用的先淘汰(LFU) 最频繁使用算法(MFU) 二次机会 时钟算法 颠簸 工作集模型 页故障率反馈模型 虚拟段式存储系统 段的动态连接 虚拟段页式存储系统 中断处理 虚拟存储管理 外存空间管理 外存空间 Swap空间 输入井 输出井 外存空间划分 静态等长，2^i, 为一块(block)，块是外存分配的基本单位，也是IO传输的基本单位 如果需求不足一个完整块，会形成块内“零头” 外存空间分配：三个方法 空闲块链(慢)：所有空闲块连成一个链 空闲块表：相连的空闲块记录在同一项中 字位映像图：用1位表示一个块的状态 界地址 每进程占一组外存连续块 每进程占二组外存连续块(双对界) 进程与外存对应关系 页式：内存一页，外存一块。内存页与外存块长度相同 段式：每段占外存若干连续块，进程的多个段之间在外存可以不连续 段页式：内存一页，外存一块。内存页与外存块长度相同。段内多页所对应的外存块可以不连续，一个进程的多段可以分散在外存的不同区域中 虚拟存储系统 [!important] 无虚拟的问题 不能运行比内存大的程序 浪费空间，因为进程活动有局部性 进程在一个有限的时间段内访问的代码和数据往往集中在有限的地址范围内 把程序一部分装入内存在较大概率上也足够让其运行一小段时间 虚拟存储：只将当前必要的很小一部分代码和数据装入内存，其余装入外存，运行时访问在外存部分动态调入，内存不够淘汰 虚拟内存的最大容量是由计算机的地址结构（ CPU寻址范围）确定的 虚拟内存的实际容量= min(内存和外存容量之和，CPU寻址范围) 虚拟存储目标：大程序小内存，多程序小内存，多程序并发地址不冲突，高效内存 虚拟存储管理：虚拟页式，虚拟段式，虚拟段页式 虚拟页式存储系统 基本原理 进程运行前：部分页面装入内存，其他（全部）装入外存 运行时： 类似于Cache 命中则访问 不命中则发生缺页中断，中断处理 找到页面外存地址 找到内存空闲页面（内存已满则按淘汰算法处理并淘汰原有页面） 读入并修改页表和快表（中断返回，进程切换） 缺页中断：在地址映射过程中，当需要访问的页不在内存时 缺页中断处理程序：将所缺的页从外存调度内存的某个页框中，更新页表和快表 为了保持各个数据块的数据一致性，需要对页表和快表增加修改标志表明该页面是否被修改 内存页框分配策略(静态策略) 平均分配：将内存中的所有物理页框等分给进入系统中的进程。如内存128页，进程25个，每个进程5个页框 按进程长度比例分配：按程序长度的比例确定分配内存的物理页框数。 pi共si个页面；S=SUM(si)；内存共m个页框 分配给进程pi的物理页框数ai=(si/S)*m 优先级分配：根据优先级别按比例分配内存物理页面 ri表示进程pi的优先级。 S=SUM(ri)；内存共m个页框 分配给进程pi的物理页框数ai=(ri/S)*m 进程长度结合优先级 进程pi逻辑页面数与优先级之和为si+ri S=SUM(ri+si)；内存共m个页框 分配给进程pi的物理页框数ai=((si+ri)/S)*m 静态策略无法反映程序的结构，以及程序不同时刻的行为特性 外存块的分配策略 静态分配：外存保持进程的全部页面 动态分配：外存仅保持进程不在内存的页面，当某一外存页面被调入内存，将释放所占用的外存页面 页面调入时机 请调：发生缺页中断时调入，但是调入时进程堵塞 预调：将要访问时调入(根据程序顺序行为，不一定准)。预调可以节省因页故障而等待的时间。预调必须辅以请调（当预先调入依旧缺页中断 置换算法（淘汰算法 [!note] 用于确定页面的调出原则 被移出页面称为淘汰页面 用于选择被淘汰页面的算法称为置换算法 页淘汰，段淘汰，快表淘汰 置换方法：局部，全局 最佳淘汰算法 淘汰以后不再需要的或者在最长时间以后才会用到的页面。 页故障率最低，为最理性的淘汰算法。然而，不能实现，因为无法准确预期页面“将来”的被访问情况。 可以作为衡量其它算法性能的一个标准。 先进先出(FIFO) 淘汰最先调入内存的页面，先进入的可能已经使用完毕。 实现：采用队列的形式。 最坏的情况：有些代码和数据可能整个程序运行中用到 [!warning] 对于先进先出的算法，会有一个现象：Belady异常 增加进程所分得的内存页框数不一定能够保证缺页故障次数下降 这个现象和程序的结构有关 最近最少使用算法(LRU) 淘汰最近一次访问时间距离当前时间间隔最长的页面。 实现：stack，当一页面被访问时, 从栈中取出压到栈顶, 栈底是: LRU page. 但是LRU算法的实现开销很大，必须有硬件的支持 最近不用的先淘汰(not used recently,NUR) 淘汰最近一段时间未用过的页面。 为每一个页面增加两个硬件位，引用位和修改位 每隔固定时间将所有引用位清零。 当要淘汰某一页面时，按照下面的次序进行选择： 引用位=0，修改位=0；直接淘汰 引用位=0，修改位=1；淘汰之前写回外存 引用位=1，修改位=0；直接淘汰 引用位=1，修改位=1；淘汰之前写回外存 最不经常使用的先淘汰(LFU) 淘汰使用次数最少的页面 依据: 活跃访问页面应有较大的访问次数 实现：记数器，调入清0，访问增1，淘汰选取最小者 Suffer: (1) 前期使用多，但以后不用，难换出 ​ (2) 刚调入的页面，引用少，被换出可能大 最频繁使用算法(MFU) 与最不经常使用算法LFU相反，淘汰使用次数最多的页面。 使用多的页面可能已经用完了，因而淘汰时取计数器值最大的页面 Suffer: 程序有些成分是在整个程序运行中都使用的 二次机会 淘汰装入最久且最近未被访问的页面 实现时：采用拉链数据结构。 时钟算法 将页面组织成环形，有一个指针指向当前位置 每次需要淘汰页面时，从指针所指的页面开始检查 如果当前页面的访问位为0，该页没有访问过，则将该页替换 如果当前页面的访问位为1，则将其清0，并顺时针移动指针到下一个位置 重复上述步骤直至找到一个访问位为0的页面 改进：考虑修改标志m，此时的淘汰优先级类似于NUR算法 由指针当前位置开始扫描，选择最佳淘汰页面，不改变引用位，将第一个遇到的r=0且m=0的页面作为淘汰页面 如步骤1失败，再次从原位置开始，找r=0且m=1的页面，将第一个满足上述要求的页面作为淘汰页面，同时将扫描过页面的r位清0 若步骤2失败，指针再次回到原位置，重新执行步骤1。若还失败再次执行步骤2，此时定能找到 [!note] 时钟算法：尽量淘汰没被访问过的 改进的时钟算法：尽量淘汰没被访问过的且没被修改过的 五种算法对比 颠簸 页面在内存与外存之间频繁换入换出 分配给进程的物理页框过少：增加物理页框（根本原因：内存少） 淘汰算法不合理：改进 程序结构不好：改善 工作集模型 工作集(working set): 进程在一段时间内所访问页面的集合 Δ：称为窗口尺寸(window size)。 为使程序有效运行，工作集应能放入内存。 Madnick, Donovan建议： Δ＝1万次访内。 实现：页表中增加访问位 Δ开始时，全部清0, 访问：置1 Δ结束时(新D开始时)访问标志为1的，为该D期间工作集， [!note] 工作集估计： 页故障率反馈模型 PFFB(Page Fault Feed Back)：动态调整页面的分配 页故障率高(达到某上界阈值)：内存页框少，增加 页故障率低(达到某下界阈值)：内存页框多，减少 虚拟段式存储系统 进程运行前，全部装入外存，部分装入内存，访问段不在内存时，发生缺段中断 若内存空间不够 紧凑：将内存中的所有空闲区合并 淘汰：将内存中的某段移至外存. 段的动态连接 当遇到访问外段的指令时，需要进行连接 [!note] 静态连接：运行前连接，由link完成；一个程序共有多少个段是确定的，因而link可以为每一个段分配一个段号； 动态连接：运行时连接，由OS完成.(在程序运行过程中需要某一个段时才将该段连接上)；一个程序共有多少个段是不确定的，因而段名到段号的转换需要由操作系统来完成的。 所需表目 段名-段号对照表：每进程一个，记录当前已连接段的表目 符号表：每段一个 段形式：符号表和目标代码或者数据 静态连接时不需符号表，由link将段名段号和目标对应起来 编译或者汇编时： 遇到访问外段指令，采用间接寻址，指向一个间接字： 执行时：遇到间接指令，且L=1, 发生连接中断，处理程序： 由D取出符号地址； 由段名查段名-段号对照表，是否分配段号。 　动态连接后，重新执行指令，发现连接字Ｌ＝０，为一般的间接地址。 [!caution] 动态连接要求修改连接字，但是段的共享要求纯代码 所以将共享代码分为“纯段共享”，“杂段私用” 虚拟段页式存储系统 考虑段的动态连接，共享，段长度的动态变化 所需表目 段表：每一个进程一个，动态变化，每连接一个新段时，增加一个新的表项 | 段号 | 页表长度 | 页表首址 | 访问权限 | 扩展标志 | 共享段入口 页表：每段一个，进程开始时只为主程序段建立页表，其他段的页表段连接时建立 逻辑页号 | 页框号 | 外存块号 | 内外标志 | 修改标志 | 总页表：即位示图，内外存各一个 共享页表：系统一个，记录共享段 段名 | 页表长度 | 页表首址 | 扩充标志 | 共享计数 | 段名-段号对照表：进程一个 所需寄存器 段表长度寄存器：保存正运行进程段表长度 段表首址寄存器：保存正运行进程段表首址 快表：段名 | 逻辑页号 | 页框号 | 访问权限 | 修改标志 地址映射：逻辑地址(s,p,d)=》物理地址(f,d) 中断处理 连接中断 所有进程均未连接(共享段表、段名-段号对照表均无) 其它进程连接过，本进程未连接过(共享段表有，段名-段号对照表无) 本进程连接过(段名-段号对照表有，共享段表有或无) 缺页中断 分配页框，调入所需页面，更新页表和总页表 越界中断 段号越界：访问不存在的段，地址错误，程序被中止 页号越界：访问段内不存在的页，根据段扩充标志判断该段是否可以扩充 越权中断：违反段的访问权限，程序将被中止 [!note] 分页对用户是透明的，分段对用户是可见的 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 07_虚拟存储器管理 "},"docs/Operating_System/08_文件与文件系统.html":{"url":"docs/Operating_System/08_文件与文件系统.html","title":"08_文件与文件系统","keywords":"","body":" 文件与文件系统 文件 访问方式 文件的组织 文件目录 文件路径名 文件目录的查找 改进 文件的共享 文件的保护 存取控制矩阵 访问权限说明 分级目录 文件保密 文件系统的安全 文件系统的实现 外存空间管理 UNIX外存空间管理 UNIX成组连接 空闲块管理 空闲inode管理 内存所需表目 文件系统的界面 读文件 写文件 日志结构文件系统 文件系统的层次结构 文件与文件系统 文件 文件：具有符号名而且在逻辑上具有完整意义的信息项的序列 文件系统：文件与管理文件的程序集合 普通文件：程序、数据、图象等，保存在磁盘块中 目录文件：(文件名，文件号)序列，保存在磁盘块中，记录文件名，文件存放地址，文件属性等 特殊文件：设备 访问方式 顺序访问：起始位置，中间某位置 随机访问：记录编号，关键字（Key) 文件的组织 逻辑组织：（对于用户而言） 记录式文件：记录的序列 流式文件：字节的序列 物理组织：文件和磁盘块的变换关系（文件逻辑块号与物理块号的映射） 顺序结构：一个文件占有若干连续的磁盘块 链式结构：块间以指针相连（又分为隐式连接和显示连接（FAT)) 索引结构：块号记在索引块中 Hash结构：通过哈希函数对关键字计算文件的地址 Unix结构（索引+链接）：多级索引 倒排结合：以键值和记录地址构成的索引结构称为倒排结构 文件目录 文件控制块（FCB）：文件存在的标志，其中保存系统管理文件需要的全部信息 建立文件时创建，删除文件时撤销 目录项：目录文件的一项，内容为FCB [!note] 文件目录：检索文件的目录 目录文件：内容为目录项的文件 单级目录：目录过多，不利于多用户管理 两级目录：多用户文件系统，每个用户有各自的主目录 多级目录 文件路径名 根目录：在实现时，根目录保存在外存空间中的固定位置 当前目录：用户正在使用的工作目录 绝对路径：从根目录开始的路径名 相对路径：从当前目录开始的路径名 文件目录的查找 查找路径：根目录（绝对路径），当前目录（相对路径） 查找算法：顺序，hash，对分（文件名有序） 目录查询技术 在单级目录中，利用用户提供的文件名，用顺序查找法直接从文件目录表中找到指名文件的目录项 从目录项中找到文件号(i_number) 通过i_number找到文件inode 通过文件inode找到文件的磁盘块 读入磁盘块，如是目录文件，则根据下一级目录继续查找，否则，找到文件 改进 FCB：分为主部和次部，也就是文件的索引节点结构 次部：文件名和文件号，保存在目录文件 主部：其他属性，链接记数，保存在inode区域，对应的节点称为i节点 [!note] UNIX文件卷(volume)组织形式： 文件的共享 节省存储空间 进程相互通讯 文件共享模式 不同时使用：根据共享说明核对使用者的访问权限 同时使用：根据共享说明和(relaxed)R/W规则以保证文件的共享不会发生冲突 文件共享的实现 公共目录：登记共享文件 共享说明：指明哪些用户不可以使用，哪些用户可以使用 连接：使一个文件具有多个名字，用户可以使用不同的名字访问同一文件 文件的保护 保护，保密，安全 存取控制矩阵 将用户关于所有文件的存取方式记录在一个矩阵中 访问权限说明 将用户分为若干类，同类用户对于同一文件具有相同的访问权限 例如linux文件权限里对于一个文件将用户分为文件属主，同组用户，其他用户 文件属主判别：访问进程u_uid==i_uid 同组用户判别：访问进程u_gid==i_gid i_mode在创建文件时给出，creat(filename, mode) 其后文件主可以修改：chmod(filename, new_mode) 分级目录 在多级目录系统中，可规定不同用户对同一子目录的访问权限。若一个用户不能访问某一目录，则他也不能访问该目录下的文件 文件保密 口令：创建文件时用户规定一个口令，记在FCB中 密码：对文件内容加密，速度慢，效果好 文件系统的安全 备份：定期将磁盘上文件复制到磁带上，发生故障时由磁带恢复(limited recovery) 完全转储：定期全部复制 增量转储：每次只复制上次转储以来修改部分 差分转储：开始进行完全转储，以后每次备份当天与第一次备份不同的数据 文件系统的实现 外存空间管理 字位映像图 空闲块链 空闲块表：Linux, 分给一个文件的磁盘块在物理上连续 UNIX:成组连接（分给一个文件的磁盘块在物理上不一定连续) UNIX外存空间管理 成组链式法 超级块：记录本卷上inode块和一般块的分配情况 文件卷安装(mount)后超级块读入内存。 UNIX成组连接 空闲块链和空闲块表：涉及超级块中s_free[100]、s_nfree和s_flock这3个数据结构 s_free包括一个由连接块构成的成组连接块的链头（ s_free[0]即是一个空闲块又是一个链接块 ） s_flock表示互斥操作空闲块数据结构的锁标识 空闲块管理 100个空闲块为一组，组之间相互链接，最前面的组记在超级块中，安装后缓冲到内存。 申请时： s_nfree>1, 分配s_free[--s_nfree]所指的块; s_nfree=1, 将s_free[0]所指的连接块读入内存缓冲区, 分配s_free[0]所指的块. 释放时： s_nfree, s_free[s_nfree++]=释放块号; s_nfree=100, 将s_nfree和s_free拷贝到释放块中,写回外存, s_free[0]=释放块号, s_nfree=1 空闲inode管理 s_inode最多可以记载100个空闲inode(编号) 申请时： s_ninode>0, 取s_inode[--s_ninode]; s_ninode=0, 由磁盘inode区顺取100个空闲i节点(i_nlink=0)，将其编号填入s_inode表中，修改s_ninode，再分配 释放时： s_ninode (释放的); s_ninode=100, 丢弃 内存所需表目 用户打开文件表（每个进程一个） u_ofile[] (每个进程一个)：一个指针数组，其内容为指向file表的入口指针，数组下标表为文件描述符fd（进程自己的fd） nfile(整个系统一个) 系统打开文件表 Inode (整个系统一个) 文件系统的界面 读文件 read(fd,nrd,buf) fd:文件描述符，nrd读入记录（字节）数，buf读入内存的起始位置 fd由fd查用户打开文件表，找到对应的入口 合法检查 查系统打开文件表，找到文件地址 读：据offset和nrd计算下一个待访问块的逻辑块号和块内起止位置，根据文件物理结构得到逻辑块号对应的物理块号； 返回实际读取字节数 写文件 write(fd,nwt,buf) 同理，不同在于写 日志结构文件系统 [!note] LSFS将整个磁盘看做一个日志，周期性地追加新日志。 写操作并非直接反映到磁盘上，而是被暂时存到内存缓冲区中，其中包括新写的数据，也包括更新数据。 当积累到一定规模时，作为一个segment追加到日志的末尾 每隔一定时间，文件系统会将更新后的元数据及文件内容写入磁盘 Inode map 系统维持一个Inode map，以实现i-number到磁盘inode的映射 清洁线程（cleaner) 循环扫描磁盘并对segment进行压缩 文件系统的层次结构 用一个例子来辅助记忆文件系统的层次结构: 假设某用户请求删除文件“D:/工作目录/学生信息.xlsx”的最后100条记录。 用户需要通过操作系统提供的接口发出上述请求一用户接口。 由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项――文件目录系统 不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限―一存取控制模块（存取控制验证层) 验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址――逻辑文件系统与文件信息缓冲区 知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址――物理文件系统 要删除这条记录，必定要对磁盘设备发出请求――设备管理程序模块 删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收――辅助分配模块。 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 08_文件与文件系统 "},"docs/Operating_System/09_设备与IO管理.html":{"url":"docs/Operating_System/09_设备与IO管理.html","title":"09_设备与IO管理","keywords":"","body":" 设备与IO管理 设备管理的功能 设备管理过程 设备的分类 设备的物理特性 磁带的物理特性 IO传输方式 程序控制查询 中断驱动 内存映射 DMA方式 通道方式 通道 通道在IO设备的作用 通道类型 IO设备控制器（接口） IO端口 IO软件的层次 IO软件设计的基本思想 用户IO软件 与设备无关的系统软件 设备驱动程序 中断处理程序 具体过程 设备的分配与去配 相关数据结构 独占设备的分配与去配 共享设备的分配与去配 有通道情形 无通道情形 设备驱动 设备驱动特点 设备驱动过程 设备调度 磁盘IO参数 磁头引臂调度 先到先服务（FCFS） 最短寻找时间优先（SSTF) 扫描算法（电梯算法） 循环扫描算法 N-step SCAN（N步扫描） FSCAN（Freezing SCAN，冻结扫描) 缓冲与缓存 缓冲 缓冲的分类 公共缓冲的管理 单缓冲 双缓冲 循环缓冲 缓冲池 高速缓存 设备与IO管理 设备管理的功能 设备管理的目标 合理的分配和调度设备资源 负责设备驱动和中断处理 现代设备管理采用缓冲和并行技术 处理器远快于设备 设备与CPU，以及设备与设备并行 虚拟设备（假脱机技术，SPOOLing技术） 利用共享设备来构造数量较多、速度较快的虚拟设备，或者将独占性设备利用代理进程变为共享性设备 设备管理过程 设备分配与去配 设备分配：将设备分配到哪一个要求该类设备的进程 设备去配：收回由某占有资源的进程处的设备资源 设备处理：设备驱动，实现I/O 进程与设备控制器之间的通信 缓冲管理：提高 CPU 和 设备的并行度，尽量减少中断 设备的分类 交互对象分类：人机交互（显示器，键盘鼠标），与CPU等交互（磁盘磁带），计算机间通信（网卡） 交互方向：输入（键盘），输出（显示器），双向（软硬盘，网卡） 外设特性：使用特征（存储，输入输出），数据传输率，信息组织特征（字符，块，网络） 用途：存储，IO，网络 [!tip] 数据传输基本单位：块型设备（磁盘磁带光盘），字符型设备（输入输出通信），时钟和显示器 从资源管理角度 共享型设备（块型） 多个进程的IO操作以块交叉 无需申请和释放设备 包括除磁带机之外的所有块型设备 属于有结构设备，传输速度高，可寻址 独占型设备（块型） 多个进程的IO操作以块为单位不能交叉 只能顺序访问（磁带机） 独占型设备（字符型） 多个进程的IO操作以字符为单位不能交叉 使用时，向系统申请。时常采用中断I/O方式 属于无结构设备，传输速率低，不可寻址 设备的物理特性 字符型设备的物理特性 每传送一个字符发生一次I/O中断。如打印机、键盘、鼠标等 低速、不可寻址，在输入/输出时常采用中断驱动方式 独占型设备，为此需要提供打开和关闭操作，实现互斥 存储型设备的物理特性 以块为单位进行数据传送，如磁盘。每传输完一块，发生一次中断 高速、可寻址，磁盘设备的I/O常采用DAM方式 块设备接口将磁盘的所有扇区从0到n-1依次编码，这样将三维结构变成一种线性序列 磁带的物理特性 磁带的物理特性：启停设备 一维地址，顺序结构（一个文件占若干连续块） IO传输方式 程序控制查询 探询(polling）又称程序控制输入输出，是最早的输入输出控制 硬件提供输入输出指令 内存操作指令：IO设备与内存统一编址 处理器代表进程向相应的设备模块发出输入输出请求， 然后处理器反复查询设备的状态，直至输入输出完成 中断驱动 当需要输入输出时，从当前程序处转入中断服务程序进行IO操作，然后返回断点 内存映射 采用取数和送数指令（MOV） 操作简单具有即时完成的特点，即指令执行完输入输出操作也就执行完了，没有中断需要处理 DMA方式 不经过CPU而直接从主存存取数据 通过总线在外设和主存之间开辟直接的数据交换通路 DMA特点 数据块传输 数据是从设备送到内存，或者相反 DMA控制器 在DMA控制器的控制下，每传送一块，向CPU发送一次中断 [!tip] 开始DMA传输时，主机向内存写入DMA命令块，向DMA控制器写入该命令块的地址，启动I/O设备 CPU继续执行其它工作(不占用总线），DMA控制器直接操作内存总线，将地址放到总线上开始传输。整个传输完成后，DMA控制器中断CPU [!important] DMA和中断驱动 中断驱动在每个数据（字节）传输后中断CPU，DMA一个数据块后中断 中断驱动数据传送是在中断处理时由CPU控制完成 DMA方式的数据传送是在DMA控制器的控制下完成。 通道方式 一个专门负责输入/输出的硬件——通道来控制数据传送方向、存放数据的内存始址及传送的数据块长度 负责IO操作的处理机，独立于CPU，有自己的指令系统 DMA(一个数据块)发展为通道（一组数据块） 实现CPU、通道和I/O设备三者的并行操作 通道 负责IO操作的处理机 指令系统：基本操作（控制，读写，转移，结束）；指令格式（操作码，传输量，特征位，地址） 运控部件：CAW,CCW,CSW,CDW 存储区域：与CPU共用内存，通道内有缓冲区 通道在IO设备的作用 通道指令单一，没有独占的内存 通道程序是放在主机的内存中 一条通道指令可以传送一组数据，全部传输完毕后才向处理器发一次中断 [!note] 具有通道结构的计算机系统 主机、通道、控制器和设备之间采用四级连接，实施三级控制 一个CPU连接若干通道；一个通道连接若干控制器；一个控制器连接若干设备 CPU通过执行I/O指令对通道实施控制，通道执行通道指令对控制器实施控制，控制器发出动作序列对设备实施控制，设备执行相应输入输出操作 [!important] 通道与DMA DMA需要CPU来控制传输数据库的大小、传输的内存位置，通道自己控制 设置通道后，CPU只需向通道发出一条I/O指令。 DMA控制器对应一台设备与内存传送数据， 一个通道可以控制多台设备与内存的数据交换 通道类型 字节多路通道：字节交换，许多非分配型子通道分别连接一台IO设备，子通道按时间片轮转共享主通道，用于低速IO 数组选择通道：块交换，一个分配型子通道，一段时间内执行一个通道程序，用于高速IO 数据多路通道：分时的方式执行几个通道程序 IO设备控制器（接口） 接受识别CPU指令 数据交换 标识和报告设备的状态，以供CPU处理 地址识别，数据缓冲，差错控制 IO端口 I/O端口指设备控制器中可被CPU之间访问的寄存器 数据寄存器：数据缓冲 状态寄存器：执行结果以及设备状态信息 控制寄存器：由CPU写入，启动命令或者更改设备模式 [!note] 采用通道实现IO操作的具体数据输入过程 进程需要输入数据，CPU向通道发出IO指令，给出要执行的通道程序的首地址和要访问的I/O设备 通道接收启动指令，读出内存的通道程序并执行，控制设备传送数据 数据传送结束，通道向CPU发出中断请求 CPU收到中断信号转至中断处理程序，唤醒等待输入完成的进程，返回断点 在以后某个时刻，进程调度程序选中提出请求输入的进程，该进程从指定的内存单元中取出数据做进一步处理. IO软件的层次 IO软件设计的基本思想 设备管理软件组成层次结构，向下接入硬件，向上与用户交互 与进程管理、存储器管理、文件管理存在一定联系 I/O软件有清晰结构，良好的可移植性和适应性 分为四个层次，其中设备驱动和中断处理最为接近硬件 用户IO软件 实现与用户交互的接口，用户利用与IO操作有关的API对设备操作 操作系统的系统调用也是以函数界面形式供用户程序调用，如 Linux:open()、read()、write()、close()等 为相应的系统调用提供参数，进而获取操作系统服务 与设备无关的系统软件 本层往下一般在操作系统内核中实现。为上层提供系统调用接口，对下则通过设备驱动接口调用设备驱动程序 系统调用处理程序 实现设备无关性，引入了逻辑设备和物理设备概念。在系统实际执行时，必须将逻辑设备名映射成物理设备名使用 主要功能 向设备驱动程序提供统一接口：将逻辑设备名映射为物理设备名 向用户层提供统一接口 设备保护，禁止用户直接访问设备 缓冲，其中缓冲区在系统区 提供与设备无关的块尺寸 错误报告 设备分配与去分配 设备驱动程序 设备驱动程序是I/O进程与设备控制器之间的通信程序 实现物理I/O操作的启动和执行，即用来具体实现系统对设备发出的操作指令，驱动I/O设备工作 响应通道中断请求，根据中断类型调用相应中断处理 与硬件直接有关，如构建通道程序，启动设备，响应通道中断 [!tip] 接收到的上层软件发来的抽象要求（函数）转换为具体要求（指令） 检查用户请求合法性，了解设备状态，传参，设置设备工作方式 发出IO命令，启动分配的设备，完成IO操作并响应中断转到相应类型的中断处理 对于设置有通道的计算机系统，驱动程序还应能够根据用户的 I/O 请求，自动地构成通道程序 中断处理程序 用于保存被中断进程现场，转入相应的中断处理程序进行处理 处理完后恢复现场，并返回到被中断的进程 具体过程 [!important] 当用户程序想要读取文件中的数据时，执行步骤： 用户I/O软件对用户的I/O请求进行解释，调用系统调用接口，假设调用read接口 与设备无关的系统软件首先在高速缓存中查找该数据块 若未找到，则调用设备驱动程序向硬件发出相应请求，用户进程阻塞直到数据块被读出 当磁盘操作完成，硬件产生一个中断，并转入中断处理程序 中断处理程序检查中断原因（传输是否出错，传输是否继续等），唤醒被阻塞进程以结束此次 I/O 请求，使用户进程继续执行 设备的分配与去配 独占型设备的分配与去配 块型独占 字符型独占 共享型设备的分配与去配 块型共享 相关数据结构 设备控制块（UCB)：设备的标识，状态，相连通道，占有设备进程 控制器控制块（CUCB）：控制器标志，状态，相连通道，占有控制器进程 通道控制块（CCB）：通道标识，状态，类型，占有通道进程 系统设备表（SDT) 记录设备类别，以及各个类别的总数，确定设备的等待队列，以及队列的UCB（设备控制块）表的指针 独占设备的分配与去配 用户需要申请后再使用，最后释放 申请：根据设备类查SDT表，P(Sm)，查UCB表找以空闲设备分配 使用：分配通道和控制器，形成通道程序，启动设备进行操作，通道中断，去配 访问SDT表，查UCB表去配，V(Sm) 共享设备的分配与去配 有通道情形 用户使用共享型设备的活动只有使用，没有申请和分配 特征 来自文件系统，虚拟存储管理系统，输入井/输出井 每次读写一块 通常经过缓存并且有排队优化 使用：分配通道；形成通道程序，启动通道，IO操作，中断处理；释放通道 无通道情形 主要是使用不同于通道 分配缓冲，填写头部 写：信息复制到缓冲区后链入IO链尾部，若设备空闲则启动设备，IO结束后释放缓冲区 读：缓冲区链入IO链尾部，若设备空闲则启动设备，等待数据，中断唤醒后复制信息到进程空间，释放缓冲区 设备驱动 设备驱动特点 与硬件密切相关 每类设备需要配置驱动 有设备厂商根据OS编写 OS仅对驱动接口有要求 设备驱动过程 通道程序：CCW指令序列，具体编制或者动态生成，多通道并行执行通道程序 设备启动： CPU将通道程序的起址放到内存指定单元，然后执行通道启动指令 通道启动，指定单元取出通道程序起址，放入通道地址字，依次执行通道指令 中断处理：通道向CPU发出中断请求 设备调度 主要是优化服务顺序，比如寻道，旋转延迟，传输 需要考虑公平（防止饿死）和高效（减少磁盘引臂移动） 磁盘IO参数 [!note] 读写磁盘块时间三个因素： 寻道时间（seek time）：将磁盘引臂移动到指定柱面所需要的时间； 旋转延迟（rotational delay）：指定扇区旋转到磁头下的时间； 传输时间（transfer time）：读/写一个扇区的时间。 寻道时间Ts = m * n + s，n为跨越磁道数，m为跨越一个磁道时间，s启动时间 旋转延迟Tr = 1 / (2*r)，r为磁盘转速 传输时间Tt = b / (r*N)，b为读写字节数，r磁盘转速，N一条磁道字节数 所以访问时间Ta为 一个扇区的访问时间：M为一个磁道上的扇区数 磁头引臂调度 先到先服务（FCFS） 按照输入输出请求的次序为各个进程服务 例如：130，42，180，15，108，68，97 则移动量：(130-53)+(130-42)+(180-42)+(180-15)+(108-15)+(108-68)+(97-68)=630 最短寻找时间优先（SSTF) 优先为距离磁头当前所在位置最近柱面的请求服务。 例如：130，42，180，15，108，68，97 移动量：(53-42)+(180-42)+(180-15)=314 扫描算法（电梯算法） 无访问请求时，磁头引臂停止不动； 当有访问请求时，引臂按照电梯移动规律运动，并为路经柱面的访问请求服务。 例如：130，42，180，15，108，68，97 移动量: (53-15)+(180-15)=203 循环扫描算法 磁头仅在单方向移动过程中才为路经的请求服务，但只是移动到最内（外）请求柱面为止。 请求序列：130，42，180，15，108，68，97 存在磁头黏性 N-step SCAN（N步扫描） 将磁盘请求队列分为若干个长度为N的子队列，每个队列内采用SCAN算法 例如 例子：磁道由外向内编号0-99,磁头当前位置20,向内移动,N=4 12, 5, 7, 30, 60, 77, 13, 26, 61, 80, 53, 66 20→30→12→7→5→13→26→60→77→80→66→61 →53 当N很大时，接近SCAN算法 当N=1时，蜕化为FCFS算法 FSCAN（Freezing SCAN，冻结扫描) 将磁盘请求分为两个子队列：服务队列，请求队列 用SCAN算法扫描服务队列，并为请求服务，服务期间新到达的请求入请求队列 扫描完成后交换两个队列的地位 特点:克服磁道粘性, 防止饿死 缓冲与缓存 缓冲 [!note] 引入缓冲的原因 缓和CPU与I/O设备间速度不匹配的矛盾 减少对CPU的中断频率，放宽对中断响应时间的限制 提高CPU和I/O设备之间的并行性 Buffering vs. Caching buffering: 处理数据到达与离开速度不一致所采用的技术。 caching: 将慢速存储器上活动信息缓冲到快速存储设备上的技术。 缓冲的分类 硬缓冲与软缓冲 硬缓冲：设备里 软缓冲：内存系统空间（OS管理） 私用与共用 私用缓冲: 一个缓冲区与一个固定设备相联系，不同设备使用不同的缓冲区，利用率低 公用缓冲: 缓冲区由系统统一管理，按需要动态分派给正在进行I/O传输的设备 公共缓冲的管理 单缓冲 一个IO请求，OS在主存中分配一个缓冲区 设备与处理器对缓冲区的操作是串行的 并且无法同时双向通信，半双工 双缓冲 双缓冲提供两个缓冲区。 进程和设备传送数据时（输入），信息由设备传送到一个缓冲区 如满后，信息由设备传到第二个缓冲区，同时处理器将第一个缓冲区内容复制到进程空间 然后，再将输入信息传到第一个缓冲区 如此交替，可以提供设备和CPU之间的并行性。 但双缓冲只是一种说明设备与设备、CPU与设备并行操作的简单模型，并不适用于实际系统中的并行操作。 循环缓冲 在设备与进程之间设置多个缓冲区，这些缓冲区连成环状。 有两个指针 in 和 out，in 指向当前输入的位置，out 指向当前取出的位置。 通过增加缓冲区的个数，可使并行程度得到明显提高。 循环缓冲包括以下两部分。(1) 多个缓冲区，(2) 多个指针 缓冲池 由多个系统公用的缓冲区组成 缓冲池结构：相同类型的缓冲区链成一个队列 一组用于块型设备，其长度通常与外围设备物理块的长度相同 一组用于字符型设备，其长度通常为8 B、16 B 等 三个队列：空缓冲，输入，输出 多用于多道程序并发设计 高速缓存 Cache 通过磁盘高速缓存技术提高磁盘的I/O速度，对访问高速缓存要比访问原始磁盘数据更高效 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - 09_设备与IO管理 "},"docs/Operating_System/review.html":{"url":"docs/Operating_System/review.html","title":"review","keywords":"","body":" 1.1_1 操作系统的概念、功能和目标 1.1_2 操作系统的特征 1.1_3 操作系统的发展与分类 1.1_4 操作系统的运行机制与体系结构 1.1_5 中断和异常 1.1_6 系统调用 2.1_1 进程的定义、组成、组织方式、特征 2.1_2 进程的状态与转换 2.1_3 进程控制 2.1_4 进程通信 2.1_5 线程概念和多线程模型 2.2_1 处理机调度的概念、层次 2.2_2 进程调度的时机、切换与过程调度方式 2.2_3 调度算法的评价指标 2.2_4 FCFS、SJF、HRRN调度算法 2.2_5 时间片轮转、优先级调度、多级反馈队列（适合交互式系统） 2.3_1 进程同步、进程互斥 2.3_2 进程互斥的软件实现方法 2.3_3 进程互斥的硬件实现方法 2.3_4 信号量机制 2.3_5 用信号量机制实现进程互斥、同步、前驱关系 2.3_6 生产者-消费者问题 2.3_7 多生产者-多消费者模型 2.3_8 吸烟者问题 2.3_9 读者-写者问题 2.3_10 哲学家进餐问题 2.3_11 管程 2.4_1 死锁的概念 2.4_2 死锁的处理策略——预防死锁 2.4_3 死锁的处理策略——避免死锁 2.4_4 死锁的处理策略——检测和解除 3.1_1 内存的基础知识 3.1_2 内存管理的概念 3.1_3 覆盖与交换 3.1_4 连续分配管理方式 3.1_5 动态分区分配算法 3.1_6 基本分页存储管理的基本概念 3.1_7 基本地址变换机构 3.1_8 具有快表的地址变换机构 3.1_9 两级页表 3.1_10 基本分段存储管理方式 3.1_11 段页式的管理方式 3.2_1 虚拟内存的基本概念 3.2_2 请求分页管理方式 3.2_3 页面置换算法 3.2_4 页面分配策略 4.1_1 初识文件管理 4.1_2 文件的逻辑结构 4.1_3 文件目录 4.1_4 文件的物理结构（文件分配方式） 4.1_4 文件的物理结构（文件分配方式） 4.1_5 文件存储空间管理 4.1_6 文件的基本操作 4.1_7 文件共享 4.1_8 文件保护 4.1_9 文件系统的层次结构 4.2_1 磁盘的结构 4.2_2 磁盘调度算法 4.2_3 减小磁盘延迟时间的方法 4.2_4 磁盘的管理 5.1_1 I-O设备的概念和分类 5.1_2 I-O控制器 5.1_3 I-O控制方式 5.1_4 I-O软件层次结构 5.1_5 I-O核心子系统 5.1_6 假脱机技术 5.1_7 设备的分配与回收 5.1_8 缓冲区管理 1.1_1 操作系统的概念、功能和目标 作为用户和计算机硬件之间的接口 提供的功能 命令接口（联机命令接口|脱机命令接口） 程序接口 GUI（图形用户界面win|ios|andrio） 目标 方便用户使用 1.1_2 操作系统的特征 并发|并行 并发：多个事件交替发生（宏观同时发生、微观交替进行） 并行：多个事件同时发生 共享 两种资源共享方式 互斥共享方式：一个时间段内只允许一个进程访问该资源 同时共享方式：允许一个时间段内由多个进程“同时”对它们进行访问 虚拟 概念：把一个物理上的实体变为若干个逻辑上的对应物 空分复用计数 时分复用计数 异步 概念：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进。只有系统拥有并发性，才有可能导致异步性。 1.1_3 操作系统的发展与分类 OS的发展与分类 手工操作阶段 纸带机（用户独占全机、人机速度矛盾） 批处理阶段——dan'dao 单道批处理系统（外围机——磁带） 多道批处理系统（操作系统开始出现） 分时操作系统 轮流处理作业 不能处理紧急任务 实时操作系统 优先处理紧急任务 硬实时系统：必须在严格的时间内完成处理 软实时系统：可以偶尔犯错 网络操作系统 分布式操作系统 个人计算机操作系统 1.1_4 操作系统的运行机制与体系结构 OS的运行机制和体系结构 运行机制 两种指令 特权指令 非特权指令 两种处理器状态 核心态（root） 用户态 两种程序 内核程序(运行在核心态 ) 应用程序 操作系统内核 时钟管理（实现计时功能） 中断处理 原语（程序运行具有原子性，不可中断） 对系统资源进行管理的功能 进程管理 存储器管理 设备管理 操作系统的体系结构 大内核（将操作系统的主要功能模块都作为系统内核，运行在核心态） 微内核（只把最基本的功能保留在内核） 1.1_5 中断和异常 中断机制的诞生 操作系统介入，开展管理工作 “用户态—>核心态”是通过中断实现的。并且中断是唯一途径 中断的概念和作用 中断的分类 内中断（异常） 陷阱（trap） 故障（fault） 中止（abort） 外中断 （CPU外部） 外中断的处理过程 1.1_6 系统调用 概念：应用程序通过系统调用请求操作系统的服务。保证系统的稳定性和安全性。 系统调用和库函数的区别： 系统调用是操作系统向上层提供的接口 有的库函数是对系统调用的进一步封装 当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用 2.1_1 进程的定义、组成、组织方式、特征 定义： 组成：PCB（进程存在唯一的标志），程序段，数据段 组织方式：链接方式，指针指向不同的队列；索引方式，索引表 特征：动态性、并发性、独立性、异步性、结构性 2.1_2 进程的状态与转换 状态： 运行状态：占有CPU，并在CPU上运行，单核只能一个进程（双核两个）（CPU√，其它资源√） 就绪状态：已经具备运行条件，但是没有空闲的CPU，暂时不能运行（CPUX，其它资源√） 阻塞状态：等在某个事件的发生，暂时不能运行（CPUX，其它资源X） 创建状态：创建PCB，程序段，数据段 终止状态：回收内存，程序段，数据段，撤销PCB 进程状态间的转换(图，且只能这样转化) 创建态->就绪态 就绪态->运行态 运行态->就绪态 运行态->中止态（比如数组越界） 运行态->阻塞态（主动） 阻塞态->就绪态（被动） 2.1_3 进程控制 基本概念： 什么是进程控制？ 答：实现各种进程状态转换。 如何实现进程控制？ 答：用“原语”实现。 原语做的事情： 1、更新PCD中的信息 2、将PCD插入合适的队列 3、分配/回收资源 进程控制相关的原语： 1、进程的创建： 创建原语：申请空白PCB、为新进程分配所需资源、初始化PCB、将PCB插入就绪队列 引起进程创建的事件：用户登录、作业调度、提供服务、应用请求 2、进程的终止： 撤销原语 引起进程中止的事件：正常结束、异常结束、外界干预 3、进程的阻塞： 阻塞原语：运行态->阻塞态 引起进程阻塞的事件：需要等待系统分配某种资源、需要等待相互合作的其他进程完成工作 4、进程的唤醒： 唤醒原语：阻塞态->就绪态 引起进程唤醒的事件：等待的事件发生 5、进程的切换 切换原语 引起进程切换的事件：当前进程事件片到、有更高优先级的进程到达、当前进程主动阻塞、当前进程终止 2.1_4 进程通信 1、共享存储 （分配共享空间，且互斥（P、V操作） 基于数据结构的共享：固定分配（低级） 基于存储区的共享：划分存储区（高级） 2、消息传递 消息：消息头、消息体 直接通信方式（直接挂载消息） 间接通信方式（间接利用信箱发送消息） 3、管道通信（pipe） 只能半双工通信 互斥（没写满，不能读，反之同理） 2.1_5 线程概念和多线程模型 什么是线程，为什么要引入线程？ 答：线程是一个基本的CPU执行单元，也是程序执行流的最小单位，进一步提高了系统的并发度 引入线程机制后，有什么变化？ 资源分配、调度：进程是资源分配的基本单位，线程是调度的基本单位 并发性：各线程间也能并发，提升了并发度 系统开销：可以只在进程中切换，减小了CPU切换环境的系统开销 1、线程有哪些重要的属性 线程是处理机调度的基本单位 多CPU计算机中，各个线程可占用不同的CPU 每个线程都有一个线程ID、线程控制块（TCB） 线程也有就绪、阻塞、运行三种基本状态 线程几乎不拥有系统资源 同一进程的不同线程间共享进程的资源 由于共享内存地址空间，统一进程中的线程间通信甚至无需系统干预 同一进程中的线程切换，不会引起进程切换 不同进程中的线程切换，会引起进程切换 切换同进程内的线程，系统开销很小 切换进程，系统开销较大 2、线程的实现方式 用户级线程（ULT）： 由应用管理，从用户的视角看能看到的线程 内核级线程（KLT）： 由操作系统管理，从操作系统内核视角看能看到的线程 n个ULT可以映射到m个KLT上（n>=m） 内核级线程才是处理机分配的单位 3、多线程模型 多对一模型 n个ULT映射到1个KLT 优点：开销小，效率高 缺点：容易阻塞，并发度不高 一对一模型 n个ULT映射到n个KLT 优点：并发能力很强 缺点：占用成本高，开销大 多对多模型 n个ULT映射到m个KLT上（n>=m） 中和以上两种优缺点 2.2_1 处理机调度的概念、层次 基本概念 通常进程数量大于处理机数量，所以要按照一定的算法选择一个进程，并将处理机分配给它运行，以实现进程的并发执行 三个层次 高级调度（作业调度） 辅助外存与内存之间的调度，作业调入时会建立相应的PCB，作业调出时才撤销PCB，调入可由操作系统决定，调出由作业运行结束才调出 中级调度（内存调度） 将暂时不用的进程放到外存（PCB不外放），提高内存利用率和系统吞吐量，进程状态为挂起状态，形成挂起队列 低级调度（进程调度） 最基本，用算法为进程分配处理机资源，几十ms一次 三层调度的联系、对比 进程的“挂起态” 七状态模型 五状态前面学了，挂起分为就绪挂起、阻塞挂起 2.2_2 进程调度的时机、切换与过程调度方式 1、时机 什么时候需要进程调度？ 主动放弃（进程正常终止、运行过程中发生异常而终止、进程主动请求阻塞） 被动放弃（分给进程的时间片用完、有更紧急的事需要处理、有更高优先级的进程进入就绪队列） 什么时候不能进行进程调度？ 在处理中断的过程中 在操作系统内核程序临界区中 临界资源：一个时段段内各进程互斥地访问临界资源 临界区：访问临界资源的那段代码 内核程序临界区会访问就绪队列，导致其上锁 在原子操作过程中（原语） 2、切换与过程 “狭义的调度”与“进程切换”的区别 狭义：选择一个进程 广义：狭义+进程切换 进程切换的过程需要做什么？ 对原来运行进程各种数据的保存 对新的进程各种数据的恢复 3、方式 非剥夺调度方式（非抢占式） 只允许进程主动放弃处理机 剥夺调度方式（抢占式） 进程被动放弃，可以优先处理紧急任务，适合分时操作系统、实时操作系统 2.2_3 调度算法的评价指标 1、CPU利用率 CPU利用率=CPU忙碌的时间/总时间 2、系统吞吐量 =总共完成了多少道作业/总共画了多少时间 3、周转时间 周转时间（提交作业到完成作业花费的时间）、平均周转时间（各作业周转时间之和/作业数） 带权周转时间（作业周转时间/作业实际运行的时间）、平均带权周转时间（各作业带权周转时间/作业数） 4、等待时间 进程或作业等待处理机状态时间的和 进程：等待被服务的时间之和 作业：建立后的等待时间+作业在外存后备队列中等待的时间 5、响应时间 从用户提交请求到首次产生响应所用的时间 2.2_4 FCFS、SJF、HRRN调度算法 1、先来先服务（FCFS） 先到达先进行服务 作业-后备队列；进程-就绪队列 非抢占式 公平、算法简单 对长作业有利、对短作业不利、不会饥饿 2、短作业优先（SJF，shortest job first） 最短（服务时间最短）的作业优先得到服务，时间相同，先到达的先被服务 非抢占式（SJF）：选最短需要时间的作业先进入运行态 抢占式（SRTN）：有新作业进入就绪队列或有作业完成了，考察队列中的最小需要时间的作业 在所有进程都几乎同时到达时，采用SJP调度算法的平均等待时间、平均周转时间最少 若无红色前提，抢占式的短作业/进程的平均时间最少 优点：“最短的”平均等待时间，平均周转时间 缺点：对短作业有利，对长作业不利，可能产生饥饿现象 3、高响应比优先（HRRN） 要综合考虑作业/进程的等待时间和要求服务的时间 在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务 响应比=（等待时间+要求服务时间）/要求服务时间 非抢占式 进程主动放弃CPU时，需要该算法选取就绪队列的作业 不会饥饿 2.2_5 时间片轮转、优先级调度、多级反馈队列（适合交互式系统） 1、时间片轮转算法（RR） 算法思想：公平轮流地位各个进程服务，让每个进程在一定时间间隔内都可以得到响应 算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列对位重新排队。 只能用于进程调度 抢占式 优点：响应块，适用于分时操作系统 缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度 不会饥饿 2、优先级调度算法 算法思想：根据任务的紧急程度来决定处理顺序 算法规则：每个进程/作业有各自的优先级，调度时选择优先级最高的作业/进程 适用：作业/进程/IO 抢占式/不可抢占均有 静态优先级：不变 动态优先级：可以变 通常：系统进程优先级高于用户进程，前台进程优先级高于后台进程，操作系统更偏好I/O进程 可以从追求公平、提升资源利用率等角度考虑改变优先级 可能会饥饿 3、多级反馈队列调度算法 算法思想：对其它算法调度的这种权衡 算法实现：设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。新进程到达时先进入第一级队列，按照FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列对位。如果此时已经在最下级的队列，则重新放回最下级队列末尾。啊只有第K级队头的进程为空时，才会为K+1级对头的进程分配时间片，被抢占处理机的进程重新放回原队列队尾。 优点：对各个进程相对公平（FCFS的优点），每个新到达的进程都可以很快就得到响应（RR的优点）；短进程只用较少的时间就可以完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、IO密集型进程 默认抢占式 会饥饿 2.3_1 进程同步、进程互斥 1、进程同步 指为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调他们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。 2、进程互斥 把一个时间段内只允许一个进程使用的资源称为临界资源。 对临界资源的互斥访问，可以在逻辑上分为四个部分： do{ entry section; //进入区 对访问的资源检查或进行上锁 critical section; //临界区(段) 访问临界资源的那部分代码 exit section; //退出区 负责解锁 remainder section; //剩余区 其它处理 } while(true) 1、空闲让进。 空的可以直接进去 2、忙则等待。 繁忙不能进去 3、有限等待。 不能让进程等待无限长时间 4、让权等待。 不能进去，不要堵着 2.3_2 进程互斥的软件实现方法 1、单标志法 两个进程在访问完临界区后会把使用临界区的权限教给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予 int turn =0; //p0进程 while(turn!=0); critical section; turn = 1; remainder section; //p1进程 while(turn!=1); critical section; turn = 0; remainder section; 可以实现互斥 存在的问题：p1要访问的话，必须p0先访问，违背：空闲让进原则 2、双标志先检查 算法思想:设置一个bool数组flag[]来标记自己是否想要进入临界区的意愿 bool flag[2]={false,false}; //p1进程 while(flag[1]); flag[0]=true; critical section; flag[0]=false; remainder section; //p2进程 while(flag[0]); flag[0]=true; critical section; flag[1]=false; remainder section; 主要问题：由于进程是并发进行的，可能会违背忙则等待的原则 3、双标志后检查 算法思想:设置一个bool数组flag[]来标记自己是否想要进入临界区的意愿,不过是先上锁后检查 bool flag[2]={false,false}; //p1进程 flag[0]=true; while(flag[1]); critical section; flag[0]=false; remainder section; //p2进程 flag[0]=true; while(flag[0]); critical section; flag[1]=false; remainder section; 主要问题：由于进程是并发进行的，可能会两个同时上锁，都进不去，违反空闲让进和有限等待原则 会饥饿 4、Peterson 算法 主动让对方先使用处理器 bool flag[2]={false,false}; int turn=0; //p1进程 flag[0]=true; turn=1; while(flag[1]&&turn==1); critical section; flag[0]=false; remainder section; //p2进程 flag[1]=true; turn=0; while(flag[0]&&turn==0); critical section; flag[1]=false; remainder section; 遵循空闲让进、忙则等待、有限等待三个原则 但是未遵循让权等待的原则 2.3_3 进程互斥的硬件实现方法 1、中断屏蔽方法 关中断（不允许进程中断） 临界区 开中断 简单、高校 多处理机，可能会同时访问临界资源 使用OS内核进程 2、TestAndSet（TSL指令） TSL是用硬件实现的，上锁、检查一气呵成 不满足让权等待，会盲等 C语言描述逻辑： //true表示已经上锁 bool TestAndSet(bool *lock){ bool old; old=*lock; *lock=true; return old; } //以下是使用TSL指令实现互斥的算法逻辑 while(TestAndSet (&lock));//上锁并检查 临界区代码段 lock=false; //解锁 3、Swap指令 别称：Exchange指令、XCHG指令 Swap指令是用硬件实现的 //true表示已经上锁 void Swap(bool *a,bool *b){ bool temp; temp=*a; *a=*b; *b=temp; } //以下是使用Swap指令实现互斥的算法逻辑 bool old=true; while(old=true) Swap(&lock,&old); 临界区代码段 lock=false; //解锁 //剩余代码段 简单 适用多处理机 不能让权等待 2.3_4 信号量机制 信号量： 信号量是一种变量，表示系统中某种资源的数量 一对原语：wait（S）原语和signal（S）原语，分别简称P（S）、V（S） 1、整形信号量 用一个整数表示系统资源的变量，用来表示系统中某种资源的数量 int S=1; void wait(int S){ //wait原语，相当于：进入区 while(S可能会出现盲等 2、记录型信号量 记录型数据结构表示的信号量 //记录型信号量的定义 typedef struct{ int value; struct process *L; } semaphore; //某进程需要使用资源时，通过wait原语申请 void wait (semaphore S){ S.value--; if(S.value除非特别说明，否则默认S为记录型信号量 2.3_5 用信号量机制实现进程互斥、同步、前驱关系 1、实现进程互斥 设置互斥信号量mutex，初值为1 对不同的临界资源需要设置不同的互斥信号量 PV必须成对出现 2、实现进程同步 保证一前一后的操作顺序 设置同步信号量S，初始为0 在“前操作”之后执行V（S） 在“后操作”之后执行（V） 3、实现进程的前驱关系 1、要为每一对前驱关系各设置一个同步变量 2、在“前操作”之后对相应的同步变量执行V操作 3、在“后操作”之前对相应的同步变量执行P操作 2.3_6 生产者-消费者问题 （好像很幼稚的逻辑 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待 只有缓冲区不空时，消费者才能从中取出产品，否则必须等待 缓冲区是临界资源，各个进程互斥访问 实现互斥的P操作要放在实现同步的P操作之后，不然会发生死锁 V操作不会导致进程发生阻塞的状态，所以可以交换 使用操作不要放在临界区，不然并发度会降低 2.3_7 多生产者-多消费者模型 在生产-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区 分析同步问题是，应该从“事件”的角度来考虑 2.3_8 吸烟者问题 解决“可以让生产多个产品的单生产者”问题提供一个思路； 若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么各个V操作应该放在各自对应的“事件”发生之后的位置 2.3_9 读者-写者问题 1、允许多个读者同时对文件执行读操作 2、只允许一个写者往文件中写信息 3、任一写者在完成写操作之前不允许其他读者或写者工作 4、写者执行写操作前，应让已有的读者和写者全部退出 semaphore rw=1;//用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件 int count=0;//记录当前有几个读进程在访问文件 semaphore mutex=1;//用于保证对count变量的互斥访问 semaphore w=1; //用于实现“写优先” writer(){ while(1){ P（w）; P(rw); //写之前“加锁” 写文件。。。 V（rw);//写之后“解锁” V(w); } } reader(){ while(1){ P(w); P(mutex); //各读进程互斥访问count if(count==0) P(rw); //第一个读进程的读进程数+1 count++; //访问文件的读进程数+1 V(mutex); V(w); 读文件... P(mutex); //各读进程互斥访问count count--; //访问文件的读进程数-1 if(count==0) V(rw); //最后一个读进程负责“解锁” V(mutex); } } 2.3_10 哲学家进餐问题 五个人，必须拿左右的筷子才能吃饭 避免死锁发生 解决方案： 1、可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐，这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。 2、要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一只后再等待另一只的情况。 3、仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子。 semaphore chopstick[5]={1,1,1,1,1}; semaphore mutex = 1; //互斥地取筷子 Pi(){ //i号哲学家的进程 while(1){ P(mutex); p(chopstick[i]); //拿右 p(chopstick[(i+1)%5]);//拿左 V(mutex); 吃饭... V(chopstick[i]); V(chopstick[(i+1)%5]); 思考... } } 2.3_11 管程 1、为什么要引入管程 PV操作容易出错、困难 2、管程的定义和基本特征 定义： 局部于管程的共享数据结构说明 对该数据结构进程操作的一组过程 对局部于管程的共享数据设置初始值的语句 管程有一个名字 基本特征： 局部于管程数据结构只能被局部于管程的过程所访问 一个进程只有通过调用管程内的过程才能进入管程访问共享数据 每次仅允许一个进程在管程内执行某个内部过程 心得：相当于C++的类，管程是数据放在private中，函数放在public中 拓展1：用管程解决生产者消费者问题 monitor producerconsumer condition full,empty; int count = 0; void insert(Item item){ if(count == N) wait(full); count++; insert_item (item); if(count == 1) signal(empty); } Item remove(){ if(count == 0) wait(empty); count--; if(count == N-1) signal(full); return remove_item(); } end monitor; //使用 producer(){ while(1){ item = 生产一个产品; producerconsumer.insert(item); } } consumer(){ while(1){ item = producerconsumer.remove(); 消费产品 item; } } 拓展2：Java中类似于管程的机制 java中用synchronized来描述一个函数,这个函数同一时间只能被一个线程调用 2.4_1 死锁的概念 1、什么是死锁 各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。 2、进程死锁、饥饿、死循环的区别 死锁： 定义：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。 区别：至少两个或两个的进程同时发生死锁 饥饿： 定义：由于长期得不到想要的资源，某进程无法向前推进的现象。 区别：可能只有一个进程发生饥饿 死循环： 定义：某进程执行过程中一直跳不出某个循环的现象。 区别：死循环是程序员的问题 3、死锁产生的必要条件 互斥条件：多个进程争夺资源发生死锁 不剥夺条件：进程获得的资源不能由其它进程强行抢夺 请求和保持条件：某个进程有了资源，还在请求资源 循环等待条件：存在资源的循环等待链 4、什么时候会发生死锁 对系统资源的竞争 进程推进顺序非法 信号量的使用不当也会造成死锁 5、死锁的处理策略 预防死锁 避免死锁 死锁的检测和解除 2.4_2 死锁的处理策略——预防死锁 1、不允许死锁发生 静态策略：预防死锁 破坏互斥条件（有些不能破坏） ​ 把互斥的资源改造为共享资源 破坏不剥夺条件（复杂，造成之前工作失效，降低系统开销，会全部放弃、导致饥饿） ​ 方案1：当请求得不到满足的时候，立即释放手里的资源 ​ 方案2：由系统介入，强行帮助剥夺 破坏请求和保持条件（资源利用率极低，可能会导致某些进程饥饿） ​ 采用静态分配方法，一次性全部申请，如果申请不到，不要允许 破坏循环等待条件（不方便增加新的设备，实际使用与递增顺序不一致，会导致资源的浪费，必须按规定次序申请资源） ​ 顺序资源分配法：对资源编号，进程按编号递增顺序请求资源 动态检测：避免死锁 2、允许死锁发生 死锁的检测和解除 2.4_3 死锁的处理策略——避免死锁 动态检测：避免死锁 什么是安全序列 进行后面的某些情况，不会使系统发生死锁 什么是系统的不安全状态，与死锁有何联系 如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定时在不安全状态） 如何避免系统进入不安全状态——银行家算法 初始分配完成后，优先全部分配给最少的，并且拿回资源 ​ 步骤： ​ 1、检查此次申请是否超过了之前声明的最大需求数 ​ 2、检查此时系统剩余的可用资源是否还能满足这次请求 ​ 3、试探着分配，更改各数据结构 ​ 4、用安全性算法检查此次所分配是否会导致系统进入不安全状态 2.4_4 死锁的处理策略——检测和解除 死锁的检测 1、用某种数据结构来保存资源的请求和分配信息 2、提供一种算法，利用上述信息来检测系统是否已进入死锁状态 死锁的解除 1、资源剥夺法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。 2、撤销进程法：强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。 3、进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。 3.1_1 内存的基础知识 1、什么是内存 存储单元：每个地址对应一个存储单元 内存地址： 2、进程运行的基本原理 指令的工作原理： 逻辑地址vs物理地址：逻辑地址就是相对地址 从写程序到程序运行：编辑-编译-链接-装入 三种链接方式：静态链接（在程序运行前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件）、装入时动态链接（将各目标模块装入内存时，边装入边链接的链接方式）、运行时动态链接（在程序执行中需要该模块时，才对它进行链接，其优点时便于修改和更新。） 三种装入方式：绝对装入（在编译的时候就知道程序放在内存的哪个位置）、静态重定位（装入时将逻辑地址转表为物理地址）、动态重定位（把地址转化推迟到程序真正要执行时才进行） 3.1_2 内存管理的概念 1、内存空间的分配与回收 2、内存空间的扩充 内存的虚拟性 3、地址转换 逻辑地址和物理地址转换 4、存储保护 设置上下限寄存器 采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器） 3.1_3 覆盖与交换 内存空间的扩充 覆盖技术：将程序分为多个段，内存分为”固定区“和”覆盖区“，需要常驻的放在”固定区“，调入后就不再调出，不常用的段放在”覆盖区“，需要用到时调入内存，用不到时掉出内存 交换技术：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（PCB会常驻内存，不会被患处） 虚拟存储技术： 3.1_4 连续分配管理方式 连续分配方式 单一连续分配：内存被分配为系统区和用户区，系统区在低地址，用户区是一个用户独享 固定分区分配：将用户区分割为若干固定分区给各道程序，分割策略有分区大小相等和分区大小不相等，可以建议一个分区说明表来管理各个分区 动态分区分配：可变分区分配，不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。 内部碎片：分配给某进程的内存区域中，如果有些部分没有用上 外部碎片：是指内存中的某些空闲分区由于太小而难以利用（如果有外部碎片，可以采用紧凑技术） 3.1_5 动态分区分配算法 1、首次适应算法（First Fit) 算法思想：每次从低地址开始查找，找到第一个能满足大小的空闲分区 2、最佳适应算法(Best Fit) 算法思想：为了保证“大进程”到来时能有连续的大片区域，可以尽可能留下大片的空闲区，优先使用更小的空闲区。 空闲分区按容量递增次序链接，分配内存时顺序查找空闲分区链 缺点：会留下小碎片 3、最坏适应算法(Worst Fit) 算法思想：和最佳适应算法相反，按容量递减次序排列，每次尽可能用大的分区 4、领近适应算法(Next Fit) 算法思想：每次从上次查找结束的位置开始检索 缺点：大空间容易被用完 3.1_6 基本分页存储管理的基本概念 允许一个进程分散地装入道许多不相邻的位置 连续分配：为用户进程分配连续的内存空间 非连续分配：为用户进程分配分散的内存空间 将内存分为大小相等的小分区“页框”，将用户的进程空间也分为大小相等的一个个区域，以页框的基本单位分配给每个进程片 分页管理：物理地址=页面的其实位置+偏移量 计算机中用2的整数倍表示页面的大小 页表：存放页号和块号的对应关系 3.1_7 基本地址变换机构 页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M，进程未执行时，页表的起始地址和页表的长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放在页表寄存器中。 3.1_8 具有快表的地址变换机构 1、局部性原理 时间局部性：访问某个变量后，在不久的将来还会被访问 空间局部性：程序访问了某个存储单元，不久之后，其附近的存储单元也很有可能被访问 2、什么是快表（TLB） 快表：又称联想寄存器（TLB），是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。 3、引入快表后，地址的变换过程 3.1_9 两级页表 1、单级页表存在什么问题？如何解决？ 所有页表项必须连续存放，页表过大时需要很大的连续空间 在一段时间内并非所有页面都用得到，因此没必要让整个页表常驻内存 2、两级页表的原理、逻辑地址结构 将长长的页表再分页 逻辑地址结构：（一级页号、二级页号、页内偏移量） 页目录表、外层页表、顶级页表 3、如何实现地址变换？ 按照地址结构将逻辑地址拆分成三部分 从PCB中读出页目录表始址，根据一级页号查页目录表，找到下一级页表在内存中的存放位置 根据二级页号查表，找到最终想访问的内存块号 结合页内偏移量得到物理地址 4、两级页表问题需要注意的几个细节 多级页表中，各级页表的大小不能超过一个页面。若两级页表不够，可以分更多级 多级页表的访问次数（假设没有快表结构）——N级页表访问一个逻辑地址需要N+1次访存 3.1_10 基本分段存储管理方式 1、什么是分段？ 进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每段有段名，每段从0开始编址 段号的位数决定了每个进程最多可以分几个段 段内地址位数决定了每个段的最大长度是多少 2、什么是段表 段表：段映射表 每个程序被分段后，用段表记录该程序在内存中存放的位置 段表：段号 段长 基址 3、如何实现地址变换 4、分段、分页管理的对比 页：信息的物理单位，实现离散分配，提高内存利用率，地址是一维的，访存两次 段：信息的逻辑单位，对系统可见，地址是二维的，访存3次 分段比分页更容易实现信息的共享和保护（不能被修改的代码称为纯代码和可重入代码，不属于临界资源） 3.1_11 段页式的管理方式 1、分页、分段管理方式最大的优缺点 分页：利用率高，碎片少，不方便进行信息共享和保护 分段：方便信息共享和保护，如果段长大，容易产生外部碎片 2、分段+分页的结合——段页式管理方式 先分段再分页 段号+页号+页内偏移量 地址结构是二维的 3、段表、页表 4、如何实现地址变换 3.2_1 虚拟内存的基本概念 1、传统存储管理方式的特征、缺点 之前讲的 一次性：作业必须全部装入内存后才能开始运行，并发性下降 驻留性：一旦作业被装入内存，就会一直驻留在内存 2、局部性原理 时间局部性 空间局部性 高速缓存技术 3、虚拟内存的定义和特征 虚拟内存最大容量是计算机地址结构确定的 虚拟内存的实际容量=min(内存和外存容量之和，CPU寻址范围) eg：某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2DB. 则虚拟内存的最大容量为 2^32B=4GB 虚拟内存的实际容量=min(2^32B,512MB+2GB)=2GB+512MB 多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调用内存 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入换出 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量 4、如何实现虚拟内存技术 在程序执行过程中，当所访问的信息不再内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。 3.2_2 请求分页管理方式 1、页表机制 请求分页存储的页表： 内存块号 状态位 访问字段 修改位 外存地址 2、缺页中断机构 内中断，可被修复 3、地址变换机构 3.2_3 页面置换算法 1、最佳置换算法（OPT） 每次选择淘汰的页面是以后永不使用或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。 实际上不知道后面的序列 2、先进先出置换算法（FIFO） 每次选择淘汰的页面是最早进入内存的页面 Belady异常，当分配的内存块增大时，缺页次数反而增加 3、最近最久未使用置换算法（LRU） 每次淘汰最近最久未使用的页面 4、时钟置换算法（最近未用算法，CLOCK） 简单的：最多经历两轮扫描，初始为1，扫一下为0，再扫一下被踢 5、改进型的时钟置换算法 优先淘汰没有被修改过的，因为没有修改过的不用进行IO操作00->01（改）->00->01 3.2_4 页面分配策略 1、驻留集 指请求分页存储管理中给进程分配的物理块的集合 2、页面分配、置换策略 固定分配局部替换：驻留集大小不可改变 可变分配全局替换：可以将操作系统保留的空闲物理块分配给缺页进程 可变分配局部替换：只能选进程自己的物理块置换 3、调入页面的时机 预调页策略：一次调用若干个相邻页面，运行前调入 请求调页策略：运行时缺页再调入 4、从何处调页 对换区：快，采用连续分配方式 文件区：慢，采用离散分配方式 5、抖动（颠簸）现象 刚刚换出的又要换入，刚刚换入的又要换出，物理块不够 6、工作集 指在某段时间间隔里，进程实际访问页面的集合 4.1_1 初识文件管理 提供的功能： 处理机管理 存储器管理 文件管理 设备管理 目标：安全高效 4.1_2 文件的逻辑结构 1、无结构文件 文件由一系列二进制文件流组成 2、有结构文件（记录式文件） 顺序文件：文件中的记录一个接一个顺序排列，定长或变长，可以顺序存储或者链式存储 按照是否与关键字顺序有关，可以分为串结构和顺序结构 链式：无法随机存取 顺序存储： 可变长：无法随机存取 定长：可以随机存取，采用串结构，无法快速找到关键字；采用顺序结构，可以快速查找关键字 索引文件：索引表本身是定长的顺序文件 索引顺序文件：多级索引表嵌套查找 4.1_3 文件目录 1、文件控制块（FCB） 搜索、创建文件、删除文件、显示目录、修改目录 2、目录结构 单级目录结构 两级目录结构 ​ 主文件目录（MFD）+用户文件目录（UFD） 多级目录结构（树形目录结构） ​ 当代操作系统采用方法、不便于文件共享 无环图目录结构 可以共享 3、索引节点（对文件控制块 压缩文件名和信息 4.1_4 文件的物理结构（文件分配方式） 1、对非空闲磁盘块的管理 连续分配：连续分配方式要求每个文件在磁盘上占有一组连续的块，对文件的拓展不方便，有很多磁盘碎片 链接分配 隐式分配：采用链接分配方式的文件，只支持顺序访问，不支持随机访问，方便拓展 显示分配：文件分配表显式记录下一块物理块的位置，方便拓展，支持随机访问，文件表会占内存空间 4.1_4 文件的物理结构（文件分配方式） 索引分配 索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表记录了文件的各个逻辑块对应的物理块 支持随机访问 链接方案 多层索引 混合索引 4.1_5 文件存储空间管理 1、存储空间的划分与初始化 文件卷（逻辑卷）的概念 目录区与文件区 2、几种管理方法 空闲表法：首位置+长度，回收时注意修改 空闲链表法（空闲盘块链、空闲盘区链） 位示图法 成组链接法：文件卷的目录区中专门用一个磁盘块作为超级块，当系统启动时需要将超级内存块读入内存。并且保证内存与外存中的超级块数据一致。 4.1_6 文件的基本操作 创建文件（create） 1、在外存中找到文件所需的空间 2、创建该文件对应的目录项 删除文件(delete) 1、找到文件名对应的目录项 2、回收文件占用的磁盘块 3、删除文件对应的目录项 读文件(read) 写文件(write) 打开文件(open) 1、找到文件名对应的目录项 2、将目录项复制到内存中的“打开文件”中 关闭文件(close) 4.1_7 文件共享 1、基于索引结点的共享方式（硬链接） 直接指向文件的索引节点 2、基于符号链的共享方式（软链接） 相当于win的快捷方式 4.1_8 文件保护 1、口令保护 2、加密保护 保密性强，不需要在系统中存储“密码” 编码/译码，需要花费一定时间 3、访问控制 在每个文件的FCB中增加一个访问控制表（ACL），该表记录了各个用户可以对该文件执行哪些操作 4.1_9 文件系统的层次结构 用户/应用接口 用户接口 文件目录系统 存取控制模块 逻辑文件系统与文件信息缓冲区 物理文件系统 辅助分配模块 设备管理模块 ​ 设备 4.2_1 磁盘的结构 磁盘、磁道、扇区的概念 如何在磁盘中读写数据 盘面柱面的概念 磁盘的物理地址 磁盘的分类 4.2_2 磁盘调度算法 ​ 1、一次磁盘读/写操作需要的时间 寻找时间Ts=s+m*n 延迟时间Tr=1/(2r) 传输时间Tt=b/(rN) 2、磁盘调度算法 先来先服务（FCFS） 最短寻找时间优先（SSTF） ​ 优先处理最近的磁道，可能会产生饥饿现象 扫描算法（SCAN） ​ 只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动 ​ LOOK，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向 循环扫描算法（C-SCAN） 返回时直接快速移动至起始端而不处理任何请求 ​ C-LOOK，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向 4.2_3 减小磁盘延迟时间的方法 1、寻找时间（寻道时间）：启动磁臂、移动磁头所花的时间 2、延迟时间：将目标扇区转到磁头下面所化的时间 磁头读取一块内容后，需要一小段的时间处理 采用交替编号策略 柱面号在盘面号之前，可以减少磁头移动消耗的时间 错位命名 3、传输时间：读/写 数据花费的时间 4.2_4 磁盘的管理 1、磁盘初始化 低级格式化/物理分区 2、引导块 ROM不可修改，ROM中只存放很小的“自举装入程序” 3、坏块的管理 在FAT表上标明（坏块对操作系统不透明） 5.1_1 I-O设备的概念和分类 1、什么是I-O设备 输入/输出 2、按使用特性分类 人机交互的外部设备 存储设备 网络通信设备 3、按传输速率分类 低俗设备、中速设备、高速设备 4、按信息交换的单位分类 块设备、字符设备 5.1_2 I-O控制器 机械部件：鼠标等 电子部件 功能： 1、接受和识别CPU发出的命令 控制寄存器 2、向CPU报告设备的状态 状态寄存器 3、数据交换 数据寄存器 4、地址识别 内存映射IO 寄存器独立编制 5.1_3 I-O控制方式 1、程序直接控制方式 轮询：完成一次读/写操作的流程 CPU干预频繁 每次读写一个字 实现简单 会使CPU忙等 2、中断驱动方式 让cpu发出io指令后做其它的事情 大量中断会使cpu效率低 每次读写一个字 cpu和io可并行工作 3、DMA方式：直接存储器存取 数据单位：连续的多个块 直接从设备到内存 减少了cpu干预 DR：数据寄存器 MAR：内存地址寄存器 DC：剩余读写字节数 CR：命令/状态寄存器 4、通道控制方式 弱鸡版cpu 通道程序：任务清单 cpu发送命令给通道，然后让通道处理IO操作就行了 处理完了，向cpu发送中断信号 5.1_4 I-O软件层次结构 1、用户层软件 实现与用户交互的接口，向上提供方便易用的库函数 2、设备独立性软件（设备无关性软件） 向上层提供统一的调用接口（read/write） 设备的保护 差错处理 设备的分配与回收 数据缓冲区管理 建立逻辑设备名到物理设备名的映射关系 根据设备类型选择调用相应的驱动程序 3、设备驱动程序（比如打印机驱动） 设置设备寄存器、检查设备状态 4、中断处理程序 进行中断处理 5、硬件 执行IO操作，有机械部件、电子部件组成 5.1_5 I-O核心子系统 1、用户层软件 假脱机系统 2、设备独立性软件（设备无关性软件） IO调度、设备保护、设备分配与回收、缓冲区管理 3、设备驱动程序（比如打印机驱动） 4、中断处理程序 5、硬件 5.1_6 假脱机技术 1、什么是脱机技术，脱机技术可以解决什么问题 脱离主机的控制进行输入/输出控制 SPPOLing系统：必须要有多道程序并发进行 2、假脱机技术的实现原理 输入井和输出井 输入进程和输出进程 输入缓冲区和输出缓冲区 3、共享打印机的原理分析 5.1_7 设备的分配与回收 1、设备分配时应考虑的因素 设备的固有属性：独占设备、共享设备、虚拟设备 设备分配算法： 设备分配中的安全：为进程分配一个设备后就将进程阻塞，本次IO完成后才将进程唤醒 2、静态分配与动态分配 静态分配：进程运行前为其分配全部所需资源、运行结束后归还资源 动态分配：运行中动态分配 3、设备分配管理中的数据结构 树 系统设备表SDT，表目：（设备类型、设备标识符、DCT、驱动程序入口） 设备控制表DCT（设备类型、设备标识符、设备状态、指向控制器表的指针、重复执行次数或事件、设备队列的队首指针） 控制器控制表COCT（控制器标识符、控制器状态、指向通道表的指针设备队列的队首指针、控制器队列的队尾指针） 通道控制表CHCT（通道标识符、通道状态、与通道连接的控制器表首址、通道队列的队首指针、通道队列的队尾指针） 4、设备分配的步骤 根据进程请求的物理设备名——>设备控制表——>控制器控制表——>通道 5、设备分配步骤的改进方法 建立逻辑设备名和设备的映射 5.1_8 缓冲区管理 1、什么时缓冲区？有什么作用？ 缓冲区是一个存储区域 缓和CPU与IO设备之间速度不匹配的矛盾 减少对CPU的中断频率 解决数据粒度不匹配的问题 提高CPU与IO设备之间的并行性 2、单缓冲 在内存中分配一块缓冲区 处理一块时间=max（C,T)+M 3、双缓冲 在内存中分配两块缓冲区 max(T,C+M) 4、循环缓冲 5、缓冲池 由系统中共用的缓冲区组成。这些缓冲区可以分为：空缓冲队列、装满输入数据的缓冲队列、装满输出数据的缓冲队列 ©OZY all right reserved该文件修订时间： 2025-09-07 10:06:22 window.__tbfed_pagefooter_config = {\"theme_colors\":{\"color-theme-1\":\"#000000ff\",\"color-theme-2\":\"#d9d9d9ff\"}}; /* Giscus Theme Mapping and Config */ window.giscusThemeMapping = {\"color-theme-1\":\"gruvbox\",\"color-theme-2\":\"dark_dimmed\",\"default\":\"light\",\"sepia\":\"preferred_color_scheme\",\"night\":\"dark_dimmed\",\"white\":\"light\"}; window.giscusConfig = {\"repo\":\"jlu005807/docs.ozy\",\"repoId\":\"R_kgDOPrTeig\",\"category\":\"General\",\"categoryId\":\"DIC_kwDOPrTeis4CvFgy\",\"mapping\":\"pathname\",\"strict\":\"1\",\"reactionsEnabled\":\"1\",\"emitMetadata\":\"0\",\"inputPosition\":\"bottom\",\"theme\":\"light\",\"lang\":\"zh-CN\",\"loading\":\"eager\"}; 评论区 - review "}}