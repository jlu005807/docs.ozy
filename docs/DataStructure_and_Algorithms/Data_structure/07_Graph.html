
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <title>07_Graph · docs.ozy</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 6.0.3">
        <meta name="author" content="ozy">
        
        
    
    <link rel="stylesheet" href="../../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-search-pro/search.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-chapter-fold/chapter-fold.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-anchor-navigation-ex/style/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-page-treeview-simple/style.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-flexible-alerts/style.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/honkit-plugin-tbfed-pagefooter/footer.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-versions-select/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/honkit-plugin-add-giscus/giscus.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/@honkit/honkit-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../../../styles/website.css">
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="08_Sort.html" />
    
    
    <link rel="prev" href="06_Tree.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../../">
            
                <a href="../../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../../计算机教育中缺失的一课/">
            
                <a href="../../计算机教育中缺失的一课/">
            
                    
                    计算机教育中缺失的一课
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../../计算机教育中缺失的一课/01_the_shell.html">
            
                <a href="../../计算机教育中缺失的一课/01_the_shell.html">
            
                    
                    01_the_shell
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../../计算机教育中缺失的一课/02_Shell_Tools_and_Scripting.html">
            
                <a href="../../计算机教育中缺失的一课/02_Shell_Tools_and_Scripting.html">
            
                    
                    02_Shell_Tools_and_Scripting
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../../计算机教育中缺失的一课/03_Editors_(Vim">
            
                <span>
            
                    
                    03_Editors (Vim)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../../计算机教育中缺失的一课/04_Data_Wrangling.html">
            
                <a href="../../计算机教育中缺失的一课/04_Data_Wrangling.html">
            
                    
                    04_Data_Wrangling
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../../计算机教育中缺失的一课/05_Command-line_Environment.html">
            
                <a href="../../计算机教育中缺失的一课/05_Command-line_Environment.html">
            
                    
                    05_Command-line Environment
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="../../计算机教育中缺失的一课/06_Version_Control_(Git">
            
                <span>
            
                    
                    06_Version Control (Git)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="../../计算机教育中缺失的一课/07_Debugging_and_Profiling.html">
            
                <a href="../../计算机教育中缺失的一课/07_Debugging_and_Profiling.html">
            
                    
                    07_Debugging and Profiling
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="../../计算机教育中缺失的一课/08_Metaprogramming.html">
            
                <a href="../../计算机教育中缺失的一课/08_Metaprogramming.html">
            
                    
                    08_Metaprogramming
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../">
            
                <a href="../">
            
                    
                    DataStructure_and_Algorithms
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../Algorithms/">
            
                <a href="../Algorithms/">
            
                    
                    Algorithms
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1.1" data-path="../Algorithms/01_算法在计算中的作用.html">
            
                <a href="../Algorithms/01_算法在计算中的作用.html">
            
                    
                    01_算法在计算中的作用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.2" data-path="../Algorithms/02_算法基础.html">
            
                <a href="../Algorithms/02_算法基础.html">
            
                    
                    02_算法基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.3" data-path="../Algorithms/03_函数的增长.html">
            
                <a href="../Algorithms/03_函数的增长.html">
            
                    
                    03_函数的增长
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.4" data-path="../Algorithms/04_分治策略.html">
            
                <a href="../Algorithms/04_分治策略.html">
            
                    
                    04_分治策略
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.5" data-path="../Algorithms/15_动态规划.html">
            
                <a href="../Algorithms/15_动态规划.html">
            
                    
                    15_动态规划
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.6" data-path="../Algorithms/16_贪心算法.html">
            
                <a href="../Algorithms/16_贪心算法.html">
            
                    
                    16_贪心算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.7" data-path="../Algorithms/17_回溯.html">
            
                <a href="../Algorithms/17_回溯.html">
            
                    
                    17_回溯
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.8" data-path="../Algorithms/18_分支限界.html">
            
                <a href="../Algorithms/18_分支限界.html">
            
                    
                    18_分支限界
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.9" data-path="../Algorithms/19_NP问题.html">
            
                <a href="../Algorithms/19_NP问题.html">
            
                    
                    19_NP问题
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="./">
            
                <a href="./">
            
                    
                    Data_structure
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.2.1" data-path="01_Introduction.html">
            
                <a href="01_Introduction.html">
            
                    
                    01_Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.2" data-path="02_Linear_List.html">
            
                <a href="02_Linear_List.html">
            
                    
                    02_Linear_List
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.3" data-path="03_Stack_and_Queue.html">
            
                <a href="03_Stack_and_Queue.html">
            
                    
                    03_Stack_and_Queue
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.4" data-path="04_Array_and_Matrix.html">
            
                <a href="04_Array_and_Matrix.html">
            
                    
                    04_Array_and_Matrix
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.5" data-path="05_Character_String.html">
            
                <a href="05_Character_String.html">
            
                    
                    05_Character_String
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.6" data-path="06_Tree.html">
            
                <a href="06_Tree.html">
            
                    
                    06_Tree
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.2.7" data-path="07_Graph.html">
            
                <a href="07_Graph.html">
            
                    
                    07_Graph
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.8" data-path="08_Sort.html">
            
                <a href="08_Sort.html">
            
                    
                    08_Sort
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.9" data-path="09_Search.html">
            
                <a href="09_Search.html">
            
                    
                    09_Search
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.10" data-path="data_structure.html">
            
                <a href="data_structure.html">
            
                    
                    data_structure
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../../Cpp/">
            
                <a href="../../Cpp/">
            
                    
                    Cpp
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../../Cpp/C++-Primer/">
            
                <a href="../../Cpp/C++-Primer/">
            
                    
                    C++-Primer
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1.1" data-path="../../Cpp/C++-Primer/01_泛型算法.html">
            
                <a href="../../Cpp/C++-Primer/01_泛型算法.html">
            
                    
                    01_泛型算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.2" data-path="../../Cpp/C++-Primer/02_关联容器.html">
            
                <a href="../../Cpp/C++-Primer/02_关联容器.html">
            
                    
                    02_关联容器
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.3" data-path="../../Cpp/C++-Primer/03_动态内存.html">
            
                <a href="../../Cpp/C++-Primer/03_动态内存.html">
            
                    
                    03_动态内存
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.4" data-path="../../Cpp/C++-Primer/04_拷贝控制.html">
            
                <a href="../../Cpp/C++-Primer/04_拷贝控制.html">
            
                    
                    04_拷贝控制
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.5" data-path="../../Cpp/C++-Primer/05_重载运算与类型转换.html">
            
                <a href="../../Cpp/C++-Primer/05_重载运算与类型转换.html">
            
                    
                    05_重载运算与类型转换
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.6" data-path="../../Cpp/C++-Primer/06_面向对象程序设计.html">
            
                <a href="../../Cpp/C++-Primer/06_面向对象程序设计.html">
            
                    
                    06_面向对象程序设计
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.7" data-path="../../Cpp/C++-Primer/07_模板与泛型编程.html">
            
                <a href="../../Cpp/C++-Primer/07_模板与泛型编程.html">
            
                    
                    07_模板与泛型编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.8" data-path="../../Cpp/C++-Primer/08_标准库特殊设施.html">
            
                <a href="../../Cpp/C++-Primer/08_标准库特殊设施.html">
            
                    
                    08_标准库特殊设施
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.9" data-path="../../Cpp/C++-Primer/09_用于大型程序的工具.html">
            
                <a href="../../Cpp/C++-Primer/09_用于大型程序的工具.html">
            
                    
                    09_用于大型程序的工具
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.10" data-path="../../Cpp/C++-Primer/10_特殊工具与技术.html">
            
                <a href="../../Cpp/C++-Primer/10_特殊工具与技术.html">
            
                    
                    10_特殊工具与技术
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.11" data-path="../../Cpp/C++-Primer/11_lambda表达式的类型.html">
            
                <a href="../../Cpp/C++-Primer/11_lambda表达式的类型.html">
            
                    
                    11_lambda表达式的类型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.12" data-path="../../Cpp/C++-Primer/12_nullptr.html">
            
                <a href="../../Cpp/C++-Primer/12_nullptr.html">
            
                    
                    12_nullptr
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../../Cpp/Effective-Modern-C++/">
            
                <a href="../../Cpp/Effective-Modern-C++/">
            
                    
                    Effective-Modern-C++
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.2.1" data-path="../../Cpp/Effective-Modern-C++/CHAPTER_1_Deducing_Types.html">
            
                <a href="../../Cpp/Effective-Modern-C++/CHAPTER_1_Deducing_Types.html">
            
                    
                    CHAPTER_1_Deducing_Types
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.2" data-path="../../Cpp/Effective-Modern-C++/CHAPTER_2_auto.html">
            
                <a href="../../Cpp/Effective-Modern-C++/CHAPTER_2_auto.html">
            
                    
                    CHAPTER_2_auto
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.3" data-path="../../Cpp/Effective-Modern-C++/CHAPTER_3_Moving_to_Modern_C++.html">
            
                <a href="../../Cpp/Effective-Modern-C++/CHAPTER_3_Moving_to_Modern_C++.html">
            
                    
                    CHAPTER_3_Moving_to_Modern_C++
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.4" data-path="../../Cpp/Effective-Modern-C++/CHAPTER_4_Smart_Pointers.html">
            
                <a href="../../Cpp/Effective-Modern-C++/CHAPTER_4_Smart_Pointers.html">
            
                    
                    CHAPTER_4_Smart_Pointers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.5" data-path="../../Cpp/Effective-Modern-C++/CHAPTER_5_RValue_References,Move_Semantics_and_Perfect_Forwarding.html">
            
                <a href="../../Cpp/Effective-Modern-C++/CHAPTER_5_RValue_References,Move_Semantics_and_Perfect_Forwarding.html">
            
                    
                    CHAPTER_5_RValue_References,Move_Semantics_and_Perfect_Forwarding
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.6" data-path="../../Cpp/Effective-Modern-C++/CHAPTER_6_Lambda_Expressions.html">
            
                <a href="../../Cpp/Effective-Modern-C++/CHAPTER_6_Lambda_Expressions.html">
            
                    
                    CHAPTER_6_Lambda_Expressions
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../../Cpp/Modern-Cpp-templates-tutorial/">
            
                <a href="../../Cpp/Modern-Cpp-templates-tutorial/">
            
                    
                    Modern-Cpp-templates-tutorial
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.3.1" data-path="../../Cpp/Modern-Cpp-templates-tutorial/01_函数模板.html">
            
                <a href="../../Cpp/Modern-Cpp-templates-tutorial/01_函数模板.html">
            
                    
                    01_函数模板
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.2" data-path="../../Cpp/Modern-Cpp-templates-tutorial/02_类模板.html">
            
                <a href="../../Cpp/Modern-Cpp-templates-tutorial/02_类模板.html">
            
                    
                    02_类模板
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../../Cpp/Pre-knowledge/">
            
                <a href="../../Cpp/Pre-knowledge/">
            
                    
                    Pre-knowledge
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.4.1" data-path="../../Cpp/Pre-knowledge/01_Element-knowledge.html">
            
                <a href="../../Cpp/Pre-knowledge/01_Element-knowledge.html">
            
                    
                    01_Element-knowledge
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.2" data-path="../../Cpp/Pre-knowledge/02_Pointer_and_Reference.html">
            
                <a href="../../Cpp/Pre-knowledge/02_Pointer_and_Reference.html">
            
                    
                    02_Pointer_and_Reference
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.3" data-path="../../Cpp/Pre-knowledge/03_Class_and_Object.html">
            
                <a href="../../Cpp/Pre-knowledge/03_Class_and_Object.html">
            
                    
                    03_Class_and_Object
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.4" data-path="../../Cpp/Pre-knowledge/04_Default_Member_Function.html">
            
                <a href="../../Cpp/Pre-knowledge/04_Default_Member_Function.html">
            
                    
                    04_Default_Member_Function
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.5" data-path="../../Cpp/Pre-knowledge/05_Conversion_and_Namespace.html">
            
                <a href="../../Cpp/Pre-knowledge/05_Conversion_and_Namespace.html">
            
                    
                    05_Conversion_and_Namespace
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.6" data-path="../../Cpp/Pre-knowledge/06_Inheritance_and_Virtual.html">
            
                <a href="../../Cpp/Pre-knowledge/06_Inheritance_and_Virtual.html">
            
                    
                    06_Inheritance_and_Virtual
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.7" data-path="../../Cpp/Pre-knowledge/07_Polymorphism.html">
            
                <a href="../../Cpp/Pre-knowledge/07_Polymorphism.html">
            
                    
                    07_Polymorphism
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.8" data-path="../../Cpp/Pre-knowledge/08_Relationship_of_Class.html">
            
                <a href="../../Cpp/Pre-knowledge/08_Relationship_of_Class.html">
            
                    
                    08_Relationship_of_Class
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.9" data-path="../../Cpp/Pre-knowledge/09_Diamond_Inheritance.html">
            
                <a href="../../Cpp/Pre-knowledge/09_Diamond_Inheritance.html">
            
                    
                    09_Diamond_Inheritance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.10" data-path="../../Cpp/Pre-knowledge/10_dynamic_cast.html">
            
                <a href="../../Cpp/Pre-knowledge/10_dynamic_cast.html">
            
                    
                    10_dynamic_cast
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.11" data-path="../../Cpp/Pre-knowledge/11_Expressions.html">
            
                <a href="../../Cpp/Pre-knowledge/11_Expressions.html">
            
                    
                    11_Expressions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.12" data-path="../../Cpp/Pre-knowledge/12_Singleton_Pattern.html">
            
                <a href="../../Cpp/Pre-knowledge/12_Singleton_Pattern.html">
            
                    
                    12_Singleton_Pattern
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.13" data-path="../../Cpp/Pre-knowledge/13_static.html">
            
                <a href="../../Cpp/Pre-knowledge/13_static.html">
            
                    
                    13_static
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.14" data-path="../../Cpp/Pre-knowledge/14_virtual.html">
            
                <a href="../../Cpp/Pre-knowledge/14_virtual.html">
            
                    
                    14_virtual
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.15" data-path="../../Cpp/Pre-knowledge/15_Miscellaneous.html">
            
                <a href="../../Cpp/Pre-knowledge/15_Miscellaneous.html">
            
                    
                    15_Miscellaneous
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../../计算机组成原理/">
            
                <a href="../../计算机组成原理/">
            
                    
                    计算机组成原理
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../../计算机组成原理/计算机组成原理基础知识.html">
            
                <a href="../../计算机组成原理/计算机组成原理基础知识.html">
            
                    
                    计算机组成原理基础知识
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../../计算机组成原理/计算机组成原理基础知识（简答版）.html">
            
                <a href="../../计算机组成原理/计算机组成原理基础知识（简答版）.html">
            
                    
                    计算机组成原理基础知识（简答版）
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../../Operating_System/">
            
                <a href="../../Operating_System/">
            
                    
                    Operating System
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../../Operating_System/01_概论.html">
            
                <a href="../../Operating_System/01_概论.html">
            
                    
                    01_概论
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../../Operating_System/02_进程管理.html">
            
                <a href="../../Operating_System/02_进程管理.html">
            
                    
                    02_进程管理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../../Operating_System/03_中断和处理器调度.html">
            
                <a href="../../Operating_System/03_中断和处理器调度.html">
            
                    
                    03_中断和处理器调度
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../../Operating_System/04_互斥同步与通讯.html">
            
                <a href="../../Operating_System/04_互斥同步与通讯.html">
            
                    
                    04_互斥同步与通讯
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="../../Operating_System/05_死锁与饥饿.html">
            
                <a href="../../Operating_System/05_死锁与饥饿.html">
            
                    
                    05_死锁与饥饿
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="../../Operating_System/06_主存管理.html">
            
                <a href="../../Operating_System/06_主存管理.html">
            
                    
                    06_主存管理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.7" data-path="../../Operating_System/07_虚拟存储器管理.html">
            
                <a href="../../Operating_System/07_虚拟存储器管理.html">
            
                    
                    07_虚拟存储器管理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.8" data-path="../../Operating_System/08_文件与文件系统.html">
            
                <a href="../../Operating_System/08_文件与文件系统.html">
            
                    
                    08_文件与文件系统
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.9" data-path="../../Operating_System/09_设备与IO管理.html">
            
                <a href="../../Operating_System/09_设备与IO管理.html">
            
                    
                    09_设备与IO管理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.10" data-path="../../Operating_System/review.html">
            
                <a href="../../Operating_System/review.html">
            
                    
                    review
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            本书使用 HonKit 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../../.." >07_Graph</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <html><head></head><body><div id="anchor-navigation-ex-navbar"><i class="fa fa-navicon"></i><ul><li><span class="title-icon "></span><a href="#图"><b></b>图</a></li><ul><li><span class="title-icon "></span><a href="#定义"><b></b>定义</a></li><li><span class="title-icon "></span><a href="#存储结构"><b></b>存储结构</a></li><li><span class="title-icon "></span><a href="#应用重要操作"><b></b>应用(重要操作)</a></li></ul></ul></div><a href="#图" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><div class="treeview__container"><ul>
<li><div><a href="#图">图</a><i class="level__parent level__item level__parent--opened" state="opened" onclick="var curState = this.getAttribute('state');var nextState = curState === 'opened' ? 'hidden' : 'opened';this.setAttribute('state', nextState);this.className = this.className.split(curState).join(nextState);var list = this.parentNode.nextElementSibling;if (nextState === 'hidden') {    list.style.display = 'none';} else {    list.style.display = 'block';}"></i></div>
<ul>
<li><div><a href="#定义">定义</a><i></i></div></li>
<li><div><a href="#存储结构">存储结构</a><i></i></div></li>
<li><div><a href="#应用重要操作">应用(重要操作)</a><i></i></div></li>
</ul></li>
</ul>
</div>

<h1 id="图"><a name="图" class="anchor-navigation-ex-anchor" href="#图"><i class="fa fa-link" aria-hidden="true"></i></a>图</h1>
<h2 id="定义"><a name="定义" class="anchor-navigation-ex-anchor" href="#定义"><i class="fa fa-link" aria-hidden="true"></i></a>定义</h2>
<p>图(Graph) G由两个集合V和E组成，记为G=(V,E) , 其中V是顶点的有穷非空集合， E是V中顶点偶对的有穷集合，这些顶点偶对称为边。</p>
<h2 id="存储结构"><a name="存储结构" class="anchor-navigation-ex-anchor" href="#存储结构"><i class="fa fa-link" aria-hidden="true"></i></a>存储结构</h2>
<ul>
<li><p>边存储</p>
<p>将各个点的关系利用边存起来</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>
{
    <span class="hljs-comment">//存储边节点的编号</span>
    <span class="hljs-comment">//u-&gt;v</span>
    <span class="hljs-type">int</span> u;
    <span class="hljs-type">int</span> v;

    <span class="hljs-comment">//加入权值</span>
    <span class="hljs-type">int</span> weight;

    <span class="hljs-built_in">Edge</span>() = <span class="hljs-keyword">default</span>;

    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> _u, <span class="hljs-type">int</span> _v,<span class="hljs-type">int</span> weight=<span class="hljs-number">1</span>) :<span class="hljs-built_in">u</span>(_u), <span class="hljs-built_in">v</span>(_v),<span class="hljs-built_in">weight</span>(weight){    }
};
</code></pre>
</li>
</ul>
<ul>
<li><p>邻接表（稀疏图）</p>
<p>用顶点表将各个邻接点利用链接结构存放起来</p>
<pre><code class="lang-cpp"><span class="hljs-comment">//边结点</span>
<span class="hljs-comment">//边链表中边结点包括邻接点域(adjvex)、数据域(info) 和链域(nextarc) 三部分</span>
<span class="hljs-comment">//邻接点域指示与顶点V; 邻接的点在图中的位置；数据域存储和边相关的信息， 如权值等；链域指示与顶点v邻接的下一条边的结点。</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>=<span class="hljs-type">int</span>&gt;<span class="hljs-comment">//默认为int</span>
<span class="hljs-keyword">class</span> ArcNode
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//该边所指向的顶点位置，如果为有向边则为弧头</span>
    <span class="hljs-type">int</span> adjvex;

    <span class="hljs-comment">//指向下一条边的指针</span>
    std::shared_ptr&lt;ArcNode&lt;T&gt;&gt; nextarc;

    <span class="hljs-comment">//边信息，如权值,默认无信息</span>
    T info;

    <span class="hljs-built_in">ArcNode</span>() = <span class="hljs-keyword">default</span>;

    <span class="hljs-built_in">ArcNode</span>(<span class="hljs-type">int</span> vex) :<span class="hljs-built_in">adjvex</span>(vex),<span class="hljs-built_in">info</span>(<span class="hljs-number">1</span>),<span class="hljs-built_in">nextarc</span>(<span class="hljs-literal">nullptr</span>){ }

    <span class="hljs-built_in">ArcNode</span>(<span class="hljs-type">int</span> vex,T info) :<span class="hljs-built_in">adjvex</span>(vex),<span class="hljs-built_in">info</span>(info), <span class="hljs-built_in">nextarc</span>(<span class="hljs-literal">nullptr</span>) { }

};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span> = <span class="hljs-type">int</span>, <span class="hljs-keyword">class</span> T = <span class="hljs-type">int</span>&gt;
<span class="hljs-keyword">class</span> Adj_List
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//表头结点表，此vector.size()即顶点数,所以不需要记录顶点数</span>
    std::vector&lt;VexNode&lt;K, T&gt;&gt; vertices;

    <span class="hljs-comment">//记录边数</span>
    <span class="hljs-type">int</span> arcnum;

    <span class="hljs-comment">//是否为有向图</span>
    <span class="hljs-type">bool</span> is_direct;
};
</code></pre>
<ul>
<li>对于链式结构的的邻接表，可以使用变为使用数组存放边的<strong>前向星</strong></li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">// 边类定义，包含两个成员变量：目标节点v和权重w</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">edge</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-type">int</span> v;  <span class="hljs-comment">// 目标节点</span>
    <span class="hljs-type">int</span> w;  <span class="hljs-comment">// 边的权重</span>

    <span class="hljs-comment">// 构造函数，初始化目标节点和边的权重</span>
    <span class="hljs-built_in">edge</span>(<span class="hljs-type">int</span> _v, <span class="hljs-type">int</span> _w) :<span class="hljs-built_in">v</span>(_v), <span class="hljs-built_in">w</span>(_w){ }
};

<span class="hljs-comment">// 存储图的邻接表(前向星)，vextices[i]表示节点i的所有边</span>
vector&lt;vector&lt;edge&gt;&gt; vextices;
</code></pre>
</li>
</ul>
<ul>
<li><p>邻接矩阵（稠密图）</p>
<ul>
<li>利用矩阵(即二维数组）将各个点是否存在边的信息存放起来</li>
</ul>
</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">//使用一个二维数组 adj 来存边，其中 adj[u][v] 为 1 表示存在 u 到 v 的边，为 0 表示不存在。</span>
<span class="hljs-comment">//如果是带边权的图，可以在 adj[u][v] 中存储 u 到 v 的边的边权。</span>
<span class="hljs-comment">//默认顶点到自身没有边</span>
<span class="hljs-comment">//并且二维数组难以改变结构所以不考虑增加和删除节点但是可以增删边，并且二维数组空间大不适用于稀疏图</span>
<span class="hljs-comment">//其实无向图为对称矩阵可以压缩为一维数组存放，但是实现逻辑相似不考虑分离  </span>
<span class="hljs-comment">//小技巧：对于有向无向图图，并且规定没有弧为0，有弧为1，则矩阵A^n[i][j]的值表示从顶点i到顶点j中路径长度为n的数目</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Adj_Matrix</span>
{
<span class="hljs-keyword">public</span>:
    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph;

    <span class="hljs-comment">//标志是否为有向图</span>
    <span class="hljs-type">bool</span> is_direct;

    <span class="hljs-built_in">Adj_Matrix</span>() = <span class="hljs-keyword">default</span>;

    <span class="hljs-comment">//顶点数量number,依旧从零开始,当weight默认时表示无权图</span>
    <span class="hljs-built_in">Adj_Matrix</span>(<span class="hljs-type">int</span> number,<span class="hljs-type">bool</span> direct=<span class="hljs-literal">false</span>, <span class="hljs-type">int</span> weight = INT_MAX):<span class="hljs-built_in">is_direct</span>(direct)
    {
        graph.<span class="hljs-built_in">resize</span>(number, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(number,weight));
    }
};
</code></pre>
<ul>
<li>对于邻接表和邻接矩阵的比较<ul>
<li>首先是，邻接表适用于稀疏图，邻接矩阵适用于稠密图</li>
<li>判断两个顶点是否存在边或者查询修改边的信息，邻接表O(n)（n表示该点的出度），邻接矩阵O(1)，所以频繁查询和修改边的信息则邻接矩阵更合适</li>
<li>对于需要增删顶点则邻接表更适合</li>
</ul>
</li>
</ul>
<h2 id="应用重要操作"><a name="应用重要操作" class="anchor-navigation-ex-anchor" href="#应用重要操作"><i class="fa fa-link" aria-hidden="true"></i></a>应用(重要操作)</h2>
<p>都以邻接矩阵为例</p>
<ul>
<li>DFS:深度优先搜索，非递归时使用栈</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">//深度优先搜索（DFS）算法,并对节点进行处理,vis保存是否访问</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, std::vector&lt;<span class="hljs-type">bool</span>&gt;&amp; vis, <span class="hljs-type">const</span> Adj_Matrix&amp; adj, std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>&amp;)&gt; address = [](<span class="hljs-type">int</span>&amp; u)-&gt;<span class="hljs-type">void</span> {std::cout &lt;&lt; u; })</span>
    </span>{
        <span class="hljs-comment">//访问过或者u不合法</span>
        <span class="hljs-keyword">if</span> (u&lt;<span class="hljs-number">0</span>||u&gt;=vis.<span class="hljs-built_in">size</span>()||vis[u])
        {
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">//标记已访问</span>
        vis[u] = <span class="hljs-literal">true</span>;

        <span class="hljs-built_in">address</span>(u);

        <span class="hljs-comment">//递归搜索</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vis.<span class="hljs-built_in">size</span>(); i++)
        {
            <span class="hljs-comment">//存在邻接点</span>
            <span class="hljs-keyword">if</span> (adj.graph[u][i] != INT_MAX)
            {
                <span class="hljs-built_in">dfs</span>(i, vis,adj,address);
            }
        }
    }
</code></pre>
<ul>
<li>非递归</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">//深度优先搜索（DFS）算法的非递归形式，类似于广度优先，但这里使用栈</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_non_recursive</span><span class="hljs-params">(<span class="hljs-type">int</span> start, std::vector&lt;<span class="hljs-type">bool</span>&gt;&amp; vis, <span class="hljs-type">const</span> Adj_Matrix&amp; adj, std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>&amp;)&gt; address = [](<span class="hljs-type">int</span>&amp; u)-&gt;<span class="hljs-type">void</span> {std::cout &lt;&lt; u; })</span>
    </span>{
        <span class="hljs-comment">//已经访问过或者start不合法</span>
        <span class="hljs-keyword">if</span> (vis[start] || start &lt; <span class="hljs-number">0</span> || start &gt;= vis.<span class="hljs-built_in">size</span>())<span class="hljs-keyword">return</span>;

        std::vector&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-comment">//存放当前连通分支节点</span>

        q.<span class="hljs-built_in">push_back</span>(start);<span class="hljs-comment">//将起始节点入栈</span>

        vis[start] = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 标记为已访问</span>

        <span class="hljs-comment">//栈不为空，即当前连通分支还有未访问的节点</span>
        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())
        {
            <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">back</span>(); <span class="hljs-comment">// 获取栈顶的节点</span>

            q.<span class="hljs-built_in">pop_back</span>();           <span class="hljs-comment">// 出栈</span>

            <span class="hljs-built_in">address</span>(u);       <span class="hljs-comment">// 处理当前节点</span>

            <span class="hljs-comment">// 遍历当前顶点，找到所有邻接并且未访问的节点加入队列</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; adj.graph.<span class="hljs-built_in">size</span>(); i++)
            {
                <span class="hljs-keyword">if</span> (adj.graph[u][i] != INT_MAX &amp;&amp; !vis[i])
                {
                    vis[i] = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 标记为已访问</span>
                    q.<span class="hljs-built_in">push_back</span>(i);     <span class="hljs-comment">// 将邻接节点入栈</span>
                }
            }

        }
    }
</code></pre>
<ul>
<li><p>BFS:广度优先搜索</p>
<ul>
<li>非递归利用队列（类似树的层次遍历）</li>
<li>可用于单源无权（权值为1）最短路</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">//广度优先搜索（BFS）算法（非递归）,并对节点进行处理,vis保存是否访问</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, std::vector&lt;<span class="hljs-type">bool</span>&gt;&amp; vis, <span class="hljs-type">const</span> Adj_Matrix&amp; adj, std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>&amp;)&gt; address = [](<span class="hljs-type">int</span>&amp; u)-&gt;<span class="hljs-type">void</span> {std::cout &lt;&lt; u; })</span>
    </span>{
        <span class="hljs-comment">//已经访问过或者start不合法</span>
        <span class="hljs-keyword">if</span> (vis[start] || start &lt; <span class="hljs-number">0</span> || start &gt;= vis.<span class="hljs-built_in">size</span>())<span class="hljs-keyword">return</span>;

        std::queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-comment">//存放当前连通分支节点，并要着start节点一圈圈增加</span>

        vis[start] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//标记初始点访问</span>

        q.<span class="hljs-built_in">push</span>(start);<span class="hljs-comment">//将起始节点入队</span>

        <span class="hljs-comment">//队列不为空，即当前连通分支还有为访问的节点</span>
        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())
        {
            <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 获取队列前端的节点</span>

            q.<span class="hljs-built_in">pop</span>();           <span class="hljs-comment">// 出队</span>

            <span class="hljs-built_in">address</span>(u);       <span class="hljs-comment">// 处理当前节点</span>

            <span class="hljs-comment">// 遍历当前顶点，找到所有邻接并且未访问的节点加入队列</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;adj.graph.<span class="hljs-built_in">size</span>();i++)
            {
                <span class="hljs-keyword">if</span> (adj.graph[u][i] != INT_MAX &amp;&amp; !vis[i])
                {
                    vis[i] = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 标记为已访问</span>
                    q.<span class="hljs-built_in">push</span>(i);     <span class="hljs-comment">// 将邻接节点入队</span>
                }
            }
        }
    }
</code></pre>
</li>
</ul>
<ul>
<li><p><strong>拓扑序列</strong>：AOV网是一个有向无环图，可以用于证明图是否有环</p>
<blockquote>
<ol>
<li><p>选择一个入度为0的顶点并输出</p>
</li>
<li><p>删除该顶点及该顶点引出的所有边</p>
</li>
<li><p>执行①②，直至所有顶点已输出，或图中剩余顶点 入度均不为0（说明存在环，无法继续拓扑排序）</p>
</li>
<li>对于任何无环的AOV网，其顶点均可排成拓扑序列， 其拓扑序列<strong>未必唯一</strong></li>
<li>拓展：如果图存在拓扑序列，则<strong>DFS可以输出拓扑序的逆序</strong></li>
</ol>
<pre><code class="lang-cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">TopologicalSort</span><span class="hljs-params">(<span class="hljs-type">const</span> Adj_Matrix&amp; adj)</span>
</span>{
    <span class="hljs-comment">// 如果是无向图，无法进行拓扑排序</span>
    <span class="hljs-keyword">if</span> (!adj.is_direct)
    {
        std::cerr &lt;&lt; <span class="hljs-string">"Graph doesn't have direction, topological sorting not possible."</span> &lt;&lt; std::endl;
        <span class="hljs-keyword">return</span> {};
    }

    <span class="hljs-type">int</span> number = adj.graph.<span class="hljs-built_in">size</span>();  <span class="hljs-comment">// 获取图中节点数量</span>

    std::vector&lt;<span class="hljs-type">int</span>&gt; Topo;          <span class="hljs-comment">// 存储拓扑排序结果</span>
    std::queue&lt;<span class="hljs-type">int</span>&gt; zero_in_degree; <span class="hljs-comment">// 存储入度为0的节点</span>

    <span class="hljs-comment">// 存放各个节点的入度</span>
    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">indegree</span><span class="hljs-params">(number, <span class="hljs-number">0</span>)</span></span>;

    <span class="hljs-comment">// 计算每个节点的入度</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = <span class="hljs-number">0</span>; u &lt; number; u++)
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">0</span>; v &lt; number; v++)
        {
            <span class="hljs-comment">// 如果存在边 u -&gt; v，v的入度增加</span>
            <span class="hljs-keyword">if</span> (adj.graph[u][v] != INT_MAX)
            {
                indegree[v]++;
            }
        }
    }

    <span class="hljs-comment">// 将入度为0的节点放入队列</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++)
    {
        <span class="hljs-keyword">if</span> (indegree[i] == <span class="hljs-number">0</span>)
        {
            zero_in_degree.<span class="hljs-built_in">push</span>(i);
        }
    }

    <span class="hljs-comment">// Kahn算法：处理入度为0的节点</span>
    <span class="hljs-keyword">while</span> (!zero_in_degree.<span class="hljs-built_in">empty</span>())
    {
        <span class="hljs-comment">// 从队列中取出一个节点</span>
        <span class="hljs-type">int</span> u = zero_in_degree.<span class="hljs-built_in">front</span>();
        zero_in_degree.<span class="hljs-built_in">pop</span>();

        <span class="hljs-comment">// 将该节点加入拓扑排序结果</span>
        Topo.<span class="hljs-built_in">push_back</span>(u);

        <span class="hljs-comment">// 遍历该节点的所有邻接节点</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++)
        {
            <span class="hljs-comment">// 如果有边 u -&gt; i，i的入度减一</span>
            <span class="hljs-keyword">if</span> (adj.graph[u][i] != INT_MAX)
            {
                indegree[i]--;

                <span class="hljs-comment">// 如果i的入度为0，加入队列</span>
                <span class="hljs-keyword">if</span> (indegree[i] == <span class="hljs-number">0</span>)
                {
                    zero_in_degree.<span class="hljs-built_in">push</span>(i);
                }
            }
        }
    }

    <span class="hljs-comment">// 检查是否存在环：如果拓扑排序结果的节点数不等于图的节点数，说明图中有环</span>
    <span class="hljs-keyword">if</span> (Topo.<span class="hljs-built_in">size</span>() != number)
    {
        std::cerr &lt;&lt; <span class="hljs-string">"Graph has a cycle, topological sorting not possible."</span> &lt;&lt; std::endl;
        <span class="hljs-keyword">return</span> {};
    }

    <span class="hljs-comment">// 返回拓扑排序结果</span>
    <span class="hljs-keyword">return</span> Topo;
}
</code></pre>
</blockquote>
</li>
<li><p><strong>关键路径</strong>：完成整个工程所需的最短时间取决于从源点到汇点的最长路径长度</p>
<blockquote>
<ul>
<li>关键活动：活动的<strong>最早开始时间等于活动 A 的最迟开始时间</strong>， 即<code>l(i)＝e(i)</code>,也是不可以拖延的活动</li>
<li><p>关键路径：由关键活动组成的路径，亦即源点到汇点的最长路径，可能不止一条</p>
</li>
<li><p>对AOE网求各顶点vj的最早发生时间ve(j)</p>
</li>
<li>求各顶点vj的最迟发生时间vl(j)；</li>
<li>求出各活动ai的最早开始时间e(i)和 最迟开始时间l(i)，若e(i)=l(i)，则ai是关键活动</li>
<li>具体算法<ol>
<li>求出拓扑排序，若网中有环则终止算法，按拓扑序求出各顶点的最早发生时间ve</li>
<li>按逆拓扑序求各顶点的最迟发生时间vl</li>
<li>根据ve和vl的值，求各活动的最早开始时间e与最迟开始时间l，若<code>e=l</code>，则对应活动是关键活动，其中最晚开始时间和最早开始时间的差值为活动的<strong>时间余量</strong>。</li>
<li>因为拓扑序列不唯一，所以关键路径也不唯一。</li>
</ol>
</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">//关键路径不唯一</span>
<span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">CriticalPath</span><span class="hljs-params">(<span class="hljs-type">const</span> Adj_Matrix&amp; adj)</span>
</span>{
    <span class="hljs-comment">// 检查是否为无向图</span>
    <span class="hljs-keyword">if</span> (!adj.is_direct)
    {
        std::cerr &lt;&lt; <span class="hljs-string">"Graph doesn't have direction, CriticalPath not possible."</span> &lt;&lt; std::endl;
        <span class="hljs-keyword">return</span> {};
    }

    <span class="hljs-type">int</span> number = adj.graph.<span class="hljs-built_in">size</span>();  <span class="hljs-comment">// 获取图中节点数量</span>

    <span class="hljs-comment">// 获取拓扑排序</span>
    std::vector&lt;<span class="hljs-type">int</span>&gt; Topo = <span class="hljs-built_in">TopologicalSort</span>(adj);

    <span class="hljs-comment">// 如果拓扑排序为空，表示图中存在环，无法进行关键路径计算</span>
    <span class="hljs-keyword">if</span> (Topo.<span class="hljs-built_in">empty</span>())
    {
        std::cout &lt;&lt; <span class="hljs-string">"图中存在环，无法计算关键路径。"</span> &lt;&lt; std::endl;
        <span class="hljs-keyword">return</span> {};
    }

    <span class="hljs-comment">// 初始化边的数量</span>
    <span class="hljs-type">int</span> edge_num = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 初始化每个节点的最早发生时间（VE），开始点的 VE 为0</span>
    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">VE</span><span class="hljs-params">(number, <span class="hljs-number">0</span>)</span></span>;

    <span class="hljs-comment">// 计算每个节点的 VE</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = <span class="hljs-number">0</span>; u &lt; Topo.<span class="hljs-built_in">size</span>(); u++)
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">0</span>; v &lt; number; v++)
        {
            <span class="hljs-comment">// 如果存在边 u -&gt; v，更新 v 的 VE</span>
            <span class="hljs-keyword">if</span> (adj.graph[u][v] != INT_MAX)
            {
                VE[v] = std::<span class="hljs-built_in">max</span>(VE[v], VE[u] + adj.graph[u][v]);
                edge_num++;  <span class="hljs-comment">// 计算边的数量</span>
            }
        }
    }

    <span class="hljs-comment">// 初始化每个节点的最晚发生时间（VL），结束点的 VL 为 VE[number - 1]</span>
    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">VL</span><span class="hljs-params">(number, VE[number - <span class="hljs-number">1</span>])</span></span>;

    <span class="hljs-comment">// 逆拓扑排序计算每个节点的 VL</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = Topo.<span class="hljs-built_in">rbegin</span>(); it != Topo.<span class="hljs-built_in">rend</span>(); it++)
    {
        <span class="hljs-type">int</span> u = *it;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++)
        {
            <span class="hljs-keyword">if</span> (adj.graph[u][i] != INT_MAX)
            {
                VL[u] = std::<span class="hljs-built_in">min</span>(VL[u], VL[i] - adj.graph[u][i]);
            }
        }
    }

    <span class="hljs-comment">// 计算关键路径上的活动（弧的最早开始时间和最晚开始时间相同）</span>
    std::vector&lt;<span class="hljs-type">int</span>&gt; critical_adjpath;

    <span class="hljs-comment">// 遍历拓扑排序中的每个节点，检查哪些弧是关键路径</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = <span class="hljs-number">0</span>; u &lt; Topo.<span class="hljs-built_in">size</span>(); u++)
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">0</span>; v &lt; number; v++)
        {
            <span class="hljs-comment">// 如果存在边 u -&gt; v，计算其最早开始时间 ET 和最晚开始时间 LT</span>
            <span class="hljs-keyword">if</span> (adj.graph[u][v] != INT_MAX)
            {
                <span class="hljs-type">int</span> ET = VE[u];  <span class="hljs-comment">// 最早开始时间</span>
                <span class="hljs-type">int</span> LT = VL[v] - adj.graph[u][v];  <span class="hljs-comment">// 最晚开始时间</span>

                <span class="hljs-comment">// 如果 ET == LT，则该弧是关键路径</span>
                <span class="hljs-keyword">if</span> (ET == LT)
                {
                    <span class="hljs-comment">// 如果 critical_adjpath 为空，加入首尾节点</span>
                    <span class="hljs-keyword">if</span> (critical_adjpath.<span class="hljs-built_in">empty</span>())
                    {
                        critical_adjpath.<span class="hljs-built_in">push_back</span>(u);
                        critical_adjpath.<span class="hljs-built_in">push_back</span>(v);
                    }
                    <span class="hljs-comment">// 如果首尾节点相接，直接添加尾节点</span>
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (critical_adjpath.<span class="hljs-built_in">back</span>() == u)
                    {
                        critical_adjpath.<span class="hljs-built_in">push_back</span>(v);
                    }
                }
            }
        }
    }

    <span class="hljs-comment">// 输出项目的最早完成时间</span>
    std::cout &lt;&lt; <span class="hljs-string">"项目的最早完成时间为："</span> &lt;&lt; VE[number - <span class="hljs-number">1</span>] &lt;&lt; std::endl;

    <span class="hljs-comment">// 返回关键路径</span>
    <span class="hljs-keyword">return</span> critical_adjpath;
}
</code></pre>
</blockquote>
</li>
<li><p>最短路径</p>
<ul>
<li><p>无权图的单源最短路径问题：BFS</p>
<blockquote>
<ul>
<li>BFS过程中，当访问某个顶点时，就确定了该点与源点的最 短距离</li>
<li>通过BFS，从源点开始由近及远求各顶点的最短路径v</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">// 找到无权最短路径，图中所有边权值为1，求点v到其他各个点的最短路径和最短路径长度</span>
<span class="hljs-comment">// path[i] 记录从 v 到 i 的最短路径上顶点 i 的前驱结点</span>
<span class="hljs-comment">// dist[i] 记录从 v 到 i 的最短路径长度</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShortestPath</span><span class="hljs-params">(<span class="hljs-type">const</span> Adj_Matrix&amp; adj, <span class="hljs-type">int</span> v, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; dist, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; path)</span>
</span>{
    <span class="hljs-comment">// dist 和 path 的初始化由调用方完成</span>
    <span class="hljs-type">int</span> number = dist.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 获取图中顶点的数量</span>

    <span class="hljs-comment">// 创建一个队列用于广度优先搜索（BFS）</span>
    std::queue&lt;<span class="hljs-type">int</span>&gt; Q;
    Q.<span class="hljs-built_in">push</span>(v); <span class="hljs-comment">// 将起点 v 入队</span>

    <span class="hljs-comment">// 起点到自身的距离为0</span>
    dist[v] = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 求 v 到其他各个顶点的最短路径，类似于图的 BFS</span>
    <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>())
    {
        <span class="hljs-comment">// 处理队头的顶点 u</span>
        <span class="hljs-type">int</span> u = Q.<span class="hljs-built_in">front</span>();
        Q.<span class="hljs-built_in">pop</span>();

        <span class="hljs-comment">// 遍历当前点 u 的所有边（邻接节点）</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++)
        {
            <span class="hljs-comment">// 如果存在边 u -&gt; i（即图中有连接）</span>
            <span class="hljs-keyword">if</span> (adj.graph[u][i] != INT_MAX)
            {
                <span class="hljs-type">int</span> k = i;  <span class="hljs-comment">// 邻接点 k</span>

                <span class="hljs-comment">// dist[k] == -1 表示未访问过该节点</span>
                <span class="hljs-keyword">if</span> (dist[k] == <span class="hljs-number">-1</span>)
                {
                    <span class="hljs-comment">// 将未访问的邻接点 k 入队</span>
                    Q.<span class="hljs-built_in">push</span>(k);

                    <span class="hljs-comment">// 更新 dist[k] 为 u 到 k 的距离，等于 u 到起点的距离加 1</span>
                    dist[k] = dist[u] + <span class="hljs-number">1</span>;

                    <span class="hljs-comment">// 更新 k 的前驱节点为 u</span>
                    path[k] = u;
                }
            }
        }
    }
}
</code></pre>
</blockquote>
</li>
<li><p>正权图的单源最短路径问题：Dijkstra算法</p>
<blockquote>
<ul>
<li>找到各个局部最优路（任意最短路的前缀，也是一条最短路）</li>
<li>初始化起点到其他点距离</li>
<li>找局部最优路</li>
<li>从局部最优路更新到其他点的距离</li>
<li>重复直到所有点的最优路找到</li>
<li>可以利用优先队列（斐波那契堆）优化找局部最优路的步骤</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">//利用优先队列维护最短路长度最小的结点，适用于稀疏图</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra_ShortestPath_optimize</span><span class="hljs-params">(<span class="hljs-type">const</span> Adj_Matrix&amp; adj, <span class="hljs-type">int</span> v, std::vector&lt;<span class="hljs-type">bool</span>&gt;&amp; vis, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; dist, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; path)</span>
    </span>{
        <span class="hljs-comment">//创建优先队列，利用pair&lt;T,int&gt;分别存放距离，节点,默认T有greater</span>
        std::priority_queue&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, std::greater&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; pq;

        <span class="hljs-comment">//初始化</span>
        dist[v] = <span class="hljs-number">0</span>;

        <span class="hljs-comment">//放入队列</span>
        pq.<span class="hljs-built_in">push</span>({ <span class="hljs-number">0</span>,v });

        <span class="hljs-comment">//直到队列为空则完成</span>
        <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>())
        {
            <span class="hljs-comment">//取当前最短路长度最小的结点</span>
            std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; node = pq.<span class="hljs-built_in">top</span>();
            pq.<span class="hljs-built_in">pop</span>();

            <span class="hljs-comment">//如果此点已经找到最小路径即局部最优路</span>
            <span class="hljs-type">int</span> u = node.second;
            <span class="hljs-keyword">if</span> (vis[u])<span class="hljs-keyword">continue</span>;

            <span class="hljs-comment">////如果有已经更新的最短路径,放弃这个记录</span>
            <span class="hljs-comment">//if (node.first &gt; dist[u])continue;</span>
            <span class="hljs-comment">//此操作和上面判断相同</span>

            <span class="hljs-comment">//标记</span>
            vis[u] = <span class="hljs-literal">true</span>;

            <span class="hljs-comment">//更新从此点出发的其他点最短路径</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;adj.graph.<span class="hljs-built_in">size</span>();i++)
            {
                <span class="hljs-comment">//更小则更新</span>
                <span class="hljs-keyword">if</span> (adj.graph[u][i] != INT_MAX &amp;&amp; dist[u] + adj.graph[u][i] &lt; dist[i])
                {
                    <span class="hljs-comment">//更新路径和前驱并放入队列</span>
                    dist[i] = dist[u] + adj.graph[u][i];
                    path[i] = u;
                    pq.<span class="hljs-built_in">push</span>({ dist[i] ,i });
                }
            }
        }
    }
</code></pre>
</blockquote>
</li>
<li><p>正权图的多源最短路径问题</p>
<ul>
<li><p>多次Dijkstra算法</p>
</li>
<li><p>Floyd算法（多用于邻接矩阵）</p>
<blockquote>
<ul>
<li>算法通过三重循环来更新最短路径。外层循环通过引入一个中间点 <code>k</code>，判断是否可以通过中间点 <code>k</code> 来缩短从 <code>i</code> 到 <code>j</code> 的路径。</li>
<li>如果通过 <code>k</code> 的路径更短，则更新 <code>dist[i][j]</code>，并且更新前驱节点 <code>path[i][j]</code> 为通过 <code>k</code> 到达 <code>j</code> 的前驱节点。</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Floyd_ShortestPath</span><span class="hljs-params">(<span class="hljs-type">const</span> Adj_Matrix&amp; adj)</span>
</span>{
    <span class="hljs-comment">// 将从Vi到Vj的最短路径长度初始化为邻接矩阵中的值</span>
    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; dist, path;

    <span class="hljs-comment">// 初始化dist和path，大小与邻接矩阵相同</span>
    dist.<span class="hljs-built_in">resize</span>(adj.graph.<span class="hljs-built_in">size</span>(), std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(adj.graph.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));
    path.<span class="hljs-built_in">resize</span>(adj.graph.<span class="hljs-built_in">size</span>(), std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(adj.graph.<span class="hljs-built_in">size</span>(), <span class="hljs-number">-1</span>));

    <span class="hljs-comment">// 初始化dist和path</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; adj.graph.<span class="hljs-built_in">size</span>(); i++)
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; adj.graph.<span class="hljs-built_in">size</span>(); j++)
        {
            dist[i][j] = adj.graph[i][j];

            <span class="hljs-comment">// 如果i和j之间有边，则设置j的前驱为i</span>
            <span class="hljs-keyword">if</span> (dist[i][j] &lt; INT_MAX)
                path[i][j] = i; 
        }
    }

    <span class="hljs-comment">// 使用三重循环来计算最短路径</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; adj.graph.<span class="hljs-built_in">size</span>(); k++)  <span class="hljs-comment">// 中间点</span>
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; adj.graph.<span class="hljs-built_in">size</span>(); i++)  <span class="hljs-comment">// 起点</span>
        {
            <span class="hljs-keyword">if</span>(i == k)<span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; adj.graph.<span class="hljs-built_in">size</span>(); j++)  <span class="hljs-comment">// 终点</span>
            {
                <span class="hljs-keyword">if</span>(j == k || j == i)<span class="hljs-keyword">continue</span>;
                <span class="hljs-comment">// 如果通过k能得到更短的路径</span>
                <span class="hljs-keyword">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j])
                {
                    <span class="hljs-comment">// 更新最短路径长度</span>
                    dist[i][j] = dist[i][k] + dist[k][j];

                    <span class="hljs-comment">// 更新路径的前驱节点</span>
                    path[i][j] = path[k][j];
                }
            }
        }
    }

    <span class="hljs-comment">// 打印结果（可以添加打印逻辑）</span>
}
</code></pre>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>最小支撑树：边权之和最小的支撑树称为G的最小支撑树</p>
<ul>
<li><p>Prim算法（加点法）</p>
<blockquote>
<ul>
<li>选择任一点u做为起点，放入集合S，即令S={u}(u属于V)；</li>
<li>找最小跨集合边(u, v) ，即端点分别属于集合S和V-S且权值 最小的边，将该边加入最小支撑树，并将点v放入S；</li>
<li>执行②，直至S=V</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">// 普里姆算法优化，使用优先队列</span>
<span class="hljs-function">Adj_Matrix <span class="hljs-title">MiniSpanTree_Prim</span><span class="hljs-params">(<span class="hljs-type">const</span> Adj_Matrix&amp; adj, <span class="hljs-type">int</span> u = <span class="hljs-number">0</span> <span class="hljs-comment">/*起始点*/</span>)</span> </span>{
    <span class="hljs-comment">// 非连通图，返回空图</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Connected_Component</span>(adj) != <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Adj_Matrix</span>(<span class="hljs-number">0</span>);
    }

    <span class="hljs-type">int</span> n = adj.graph.<span class="hljs-built_in">size</span>();  <span class="hljs-comment">// 图的顶点数</span>
    <span class="hljs-function">Adj_Matrix <span class="hljs-title">MiniSpanTree</span><span class="hljs-params">(n, adj.is_direct)</span></span>;  <span class="hljs-comment">// 最小生成树</span>

    <span class="hljs-comment">// 记录顶点是否已经加入生成树</span>
    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;

    <span class="hljs-comment">// 使用优先队列（最小堆）保存未加入生成树的点和其对应的最小边权值</span>
    <span class="hljs-comment">// 队列中存储的是 (边权值, 顶点) 的 pair</span>
    std::priority_queue&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, std::greater&lt;&gt;&gt; pq;

    <span class="hljs-comment">// 初始化：从起始点u开始，加入队列，权值为0</span>
    pq.<span class="hljs-built_in">push</span>({<span class="hljs-number">0</span>, u});

    <span class="hljs-comment">// 选择其他n-1个顶点，生成n-1条边</span>
    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) {
        <span class="hljs-comment">// 取出当前权值最小的边</span>
        <span class="hljs-type">int</span> current_weight = pq.<span class="hljs-built_in">top</span>().first;
        <span class="hljs-type">int</span> u0 = pq.<span class="hljs-built_in">top</span>().second;
        pq.<span class="hljs-built_in">pop</span>();

        <span class="hljs-comment">// 如果顶点u0已经加入生成树，则跳过</span>
        <span class="hljs-keyword">if</span> (vis[u0]) <span class="hljs-keyword">continue</span>;

        <span class="hljs-comment">// 标记u0为已访问</span>
        vis[u0] = <span class="hljs-literal">true</span>;

        <span class="hljs-comment">// 更新最小生成树的边</span>
        <span class="hljs-keyword">if</span> (u0 != u) {  <span class="hljs-comment">// 排除起始点</span>
            <span class="hljs-type">int</span> v0 = pq.<span class="hljs-built_in">top</span>().second;  <span class="hljs-comment">// 顶点u0的前驱</span>
            MiniSpanTree.graph[u0][v0] = current_weight;

            <span class="hljs-comment">// 无向图则增加对称边</span>
            <span class="hljs-keyword">if</span> (!MiniSpanTree.is_direct) {
                MiniSpanTree.graph[v0][u0] = current_weight;
            }
        }

        <span class="hljs-comment">// 更新与u0的相邻节点的最小边，并加入优先队列</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-keyword">if</span> (!vis[i] &amp;&amp; adj.graph[u0][i] &lt; INT_MAX) {  <span class="hljs-comment">// 如果i未访问且有边</span>
                pq.<span class="hljs-built_in">push</span>({adj.graph[u0][i], i});
            }
        }
    }

    <span class="hljs-comment">// 返回生成的最小生成树</span>
    <span class="hljs-keyword">return</span> MiniSpanTree;
}
</code></pre>
</blockquote>
</li>
<li><p>Kruskal算法（逐边加入）所以不针对邻接矩阵为例</p>
<blockquote>
<ul>
<li>在G中选择权值最小的边，并将此边从G中删除</li>
<li>若该边加入T后不产生环（即此边的两个端点在T的不同连 通分量中），则将此边加入T中，从而使T减少一个连通分 量，否则本步骤无操作，对于是否产生环可以利用并查集</li>
<li>重复①②直至T中仅剩一个连通分量</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">//克鲁斯卡尔 (Kruskal)算法，可称为“加边法”，适用于稀疏图</span>
    <span class="hljs-comment">//每次选出权值最小并且无法使现有的树形成环的边加入最小支撑树,返回一个图</span>
    <span class="hljs-function">std::vector&lt;Edge&gt; <span class="hljs-title">MiniSpanTree_Kruskal</span><span class="hljs-params">(std::vector&lt;Edge&gt; graph,<span class="hljs-type">int</span> number)</span>
    </span>{
        <span class="hljs-comment">//非连通图</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Connected_Component</span>(graph,number) != <span class="hljs-number">1</span>)
        {
            <span class="hljs-keyword">return</span>{};
        }
        std::vector&lt;Edge&gt; MiniSpanTree;
        <span class="hljs-comment">//在Edge增加了weight成员存储权值，可以直接用sort排序</span>
        std::<span class="hljs-built_in">sort</span>(graph.<span class="hljs-built_in">begin</span>(), graph.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> Edge&amp; a, <span class="hljs-type">const</span> Edge&amp; b)-&gt;<span class="hljs-type">bool</span> {<span class="hljs-keyword">return</span> a.weight &lt; b.weight; });

        <span class="hljs-comment">//辅助数组Vexset,标识各个顶点所属的连通分量,类似于并查集</span>
        std::vector&lt;<span class="hljs-type">int</span>&gt; Vexset;
        Vexset.<span class="hljs-built_in">resize</span>(number,<span class="hljs-number">0</span>);
        <span class="hljs-comment">//初始化,表示各顶点自成一个连通分址</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++)
        {
            Vexset[i] = i;
        }

        <span class="hljs-comment">//开始创建最小支撑树</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph.<span class="hljs-built_in">size</span>(); i++)
        {
            <span class="hljs-type">int</span> v1 = graph[i].u;
            <span class="hljs-type">int</span> v2 = graph[i].v;
            <span class="hljs-type">int</span> vs1 = Vexset[v1];
            <span class="hljs-type">int</span> vs2 = Vexset[v2];

            <span class="hljs-comment">//边的两个顶点不在同一连通分量</span>
            <span class="hljs-keyword">if</span> (vs1 != vs2)
            {
                <span class="hljs-comment">//加入此边</span>
                MiniSpanTree.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(v1, v2));

                <span class="hljs-comment">//合并vs1和vs2两个分量，即两个集合统一编号</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; number; j++)
                {
                    <span class="hljs-keyword">if</span> (Vexset[j] == vs2)Vexset[j] = vs1;
                }
            }
        }

        <span class="hljs-comment">//返回</span>
        <span class="hljs-keyword">return</span> MiniSpanTree;
    }
</code></pre>
</blockquote>
</li>
</ul>
</li>
</ul>
<p></p><footer class="page-footer" style="font-size:1.0rem;"><span class="copyright">©<a href="https://jlu005807.github.io/" target="_blank">OZY</a> all right reserved</span><span class="footer-modification">该文件修订时间：
2025-09-07 09:41:17
</span></footer><script>window.__tbfed_pagefooter_config = {"theme_colors":{"color-theme-1":"#000000ff","color-theme-2":"#d9d9d9ff"}};</script><script src="./gitbook/honkit-plugin-tbfed-pagefooter/footer-theme.js"></script><p></p>
<!-- Giscus 评论组件开始 - 2025-09-07T09:41:33.277Z -->
<p><script type="text/javascript">
/* Giscus Theme Mapping and Config */
window.giscusThemeMapping = {"color-theme-1":"gruvbox","color-theme-2":"dark_dimmed","default":"light","sepia":"preferred_color_scheme","night":"dark_dimmed","white":"light"};
window.giscusConfig = {"repo":"jlu005807/docs.ozy","repoId":"R_kgDOPrTeig","category":"General","categoryId":"DIC_kwDOPrTeis4CvFgy","mapping":"pathname","strict":"1","reactionsEnabled":"1","emitMetadata":"0","inputPosition":"bottom","theme":"light","lang":"zh-CN","loading":"eager"};
</script></p>
<p></p><div id="giscus-container" style="margin-top: 50px; padding: 10px; border-top: 1px solid #eaecef;"><div class="giscus-page-info" style="margin-bottom: 15px; font-size: 0.9em; color: #666;">评论区 - 07_Graph</div>
<!-- giscus client.js will be inserted by giscus-theme-switcher.js --><p></p>
<!-- Giscus 评论组件结束 --></div></body></html>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="06_Tree.html" class="navigation navigation-prev " aria-label="Previous page: 06_Tree">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="08_Sort.html" class="navigation navigation-next " aria-label="Next page: 08_Sort">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"07_Graph","level":"1.3.2.7","depth":3,"next":{"title":"08_Sort","level":"1.3.2.8","depth":3,"path":"docs/DataStructure_and_Algorithms/Data_structure/08_Sort.md","ref":"docs/DataStructure_and_Algorithms/Data_structure/08_Sort.md","articles":[]},"previous":{"title":"06_Tree","level":"1.3.2.6","depth":3,"path":"docs/DataStructure_and_Algorithms/Data_structure/06_Tree.md","ref":"docs/DataStructure_and_Algorithms/Data_structure/06_Tree.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-lunr","-search","-sharing","search-pro","chapter-fold","expandable-chapters","github","sharing-plus","anchor-navigation-ex","code","page-treeview-simple","flexible-alerts","tbfed-pagefooter","versions-select","add-giscus"],"styles":{"website":"styles/website.css","ebook":"styles/website.css","pdf":"styles/website.css","mobi":"styles/website.css","epub":"styles/website.css"},"pluginsConfig":{"tbfed-pagefooter":{"copyright":"&copy;<a href=\"https://jlu005807.github.io/\">OZY</a>","show_modify_time":true,"font_size":"1.0rem","modify_label":"该文件修订时间：","modify_format":"YYYY-MM-DD HH:mm:ss","show_power":false,"hover":true},"chapter-fold":{},"github":{"url":"https://github.com/jlu005807"},"search-pro":{},"sharing-plus":{"qq":false,"all":["facebook","google","twitter","instapaper","linkedin","pocket","stumbleupon"],"douban":false,"facebook":true,"weibo":false,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":true,"messenger":false,"line":false,"vk":false,"pocket":true,"google":false,"viber":false,"stumbleupon":false,"qzone":false,"linkedin":false},"code":{"copyButtons":true},"versions-select":{"type":"branches"},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"anchor-navigation-ex":{"showLevel":false,"associatedWithSummary":true,"mode":"float","showGoTop":true,"printLog":false,"multipleH1":true,"float":{"floatIcon":"fa fa-navicon","showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""},"pageTop":{"showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""}},"flexible-alerts":{"style":"callout","note":{"label":"Note","icon":"fa fa-info-circle","className":"info"},"tip":{"label":"Tip","icon":"fa fa-lightbulb-o","className":"tip"},"warning":{"label":"Warning","icon":"fa fa-exclamation-triangle","className":"warning"},"danger":{"label":"Attention","icon":"fa fa-ban","className":"danger"}},"versions":{"options":[{"value":"https://jlu005807.github.io/test-honkit/","text":"docs.ozy"},{"value":"https://jlu005807.github.io/","text":"github.io.ozy","selected":true},{"value":"https://github.com/jlu005807","text":"github.ozy","selected":true}]},"sharing":{"qq":true,"all":["qq","qzone"],"weixin":true,"douban":false,"facebook":false,"weibo":false,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":false,"messenger":false,"line":false,"vk":false,"pocket":false,"google":false,"viber":false,"stumbleupon":false,"qzone":true,"linkedin":false},"add-giscus":{"repo":"jlu005807/docs.ozy","repoId":"R_kgDOPrTeig","category":"General","categoryId":"DIC_kwDOPrTeis4CvFgy","theme_config":{"default":"light","color-theme-1":"gruvbox","color-theme-2":"dark_dimmed"}},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"page-treeview-simple":{"copyright":"Copyright © aleen42","minHeaderCount":"1","minHeaderDeep":"1","collapsed":false},"expandable-chapters":{}},"theme":"default","author":"ozy","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"docs.ozy","language":"zh-hans","gitbook":"3.2.3","description":"我的文档站点"},"file":{"path":"docs/DataStructure_and_Algorithms/Data_structure/07_Graph.md","mtime":"2025-09-07T09:41:17.157Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-09-07T09:41:31.409Z"},"basePath":"../../..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../../../gitbook/gitbook.js"></script>
    <script src="../../../gitbook/theme.js"></script>
    
        
        <script src="../../../gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-search-pro/search.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-chapter-fold/chapter-fold.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-sharing-plus/buttons.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-code/plugin.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-flexible-alerts/plugin.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-versions-select/plugin.js"></script>
        
    
        
        <script src="../../../gitbook/honkit-plugin-add-giscus/giscus-theme-switcher.js"></script>
        
    
        
        <script src="../../../gitbook/@honkit/honkit-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

