
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <title>09_Search · docs.ozy</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 6.0.4">
        <meta name="author" content="ozy">
        
        
    
    <link rel="stylesheet" href="../../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-search-pro/search.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-chapter-fold/chapter-fold.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-anchor-navigation-ex/style/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-page-treeview-simple/style.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-flexible-alerts/style.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-versions-select/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/honkit-plugin-tbfed-pagefooter/footer.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/honkit-plugin-add-giscus/giscus.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/@honkit/honkit-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../../../styles/website.css">
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="data_structure.html" />
    
    
    <link rel="prev" href="08_Sort.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../../">
            
                <a href="../../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../../计算机教育中缺失的一课/">
            
                <a href="../../计算机教育中缺失的一课/">
            
                    
                    计算机教育中缺失的一课
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../../计算机教育中缺失的一课/01_the_shell.html">
            
                <a href="../../计算机教育中缺失的一课/01_the_shell.html">
            
                    
                    01_the_shell
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../../计算机教育中缺失的一课/02_Shell_Tools_and_Scripting.html">
            
                <a href="../../计算机教育中缺失的一课/02_Shell_Tools_and_Scripting.html">
            
                    
                    02_Shell_Tools_and_Scripting
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../../计算机教育中缺失的一课/03_Editors_Vim.html">
            
                <a href="../../计算机教育中缺失的一课/03_Editors_Vim.html">
            
                    
                    03_Editors_Vim
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../../计算机教育中缺失的一课/04_Data_Wrangling.html">
            
                <a href="../../计算机教育中缺失的一课/04_Data_Wrangling.html">
            
                    
                    04_Data_Wrangling
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../../计算机教育中缺失的一课/05_Command-line_Environment.html">
            
                <a href="../../计算机教育中缺失的一课/05_Command-line_Environment.html">
            
                    
                    05_Command-line Environment
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="../../计算机教育中缺失的一课/06_Version_Control_Git.html">
            
                <a href="../../计算机教育中缺失的一课/06_Version_Control_Git.html">
            
                    
                    06_Version_Control_Git
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="../../计算机教育中缺失的一课/07_Debugging_and_Profiling.html">
            
                <a href="../../计算机教育中缺失的一课/07_Debugging_and_Profiling.html">
            
                    
                    07_Debugging and Profiling
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="../../计算机教育中缺失的一课/08_Metaprogramming.html">
            
                <a href="../../计算机教育中缺失的一课/08_Metaprogramming.html">
            
                    
                    08_Metaprogramming
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../">
            
                <a href="../">
            
                    
                    DataStructure_and_Algorithms
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="./">
            
                <a href="./">
            
                    
                    Data_structure
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1.1" data-path="01_Introduction.html">
            
                <a href="01_Introduction.html">
            
                    
                    01_Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.2" data-path="02_Linear_List.html">
            
                <a href="02_Linear_List.html">
            
                    
                    02_Linear_List
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.3" data-path="03_Stack_and_Queue.html">
            
                <a href="03_Stack_and_Queue.html">
            
                    
                    03_Stack_and_Queue
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.4" data-path="04_Array_and_Matrix.html">
            
                <a href="04_Array_and_Matrix.html">
            
                    
                    04_Array_and_Matrix
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.5" data-path="05_Character_String.html">
            
                <a href="05_Character_String.html">
            
                    
                    05_Character_String
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.6" data-path="06_Tree.html">
            
                <a href="06_Tree.html">
            
                    
                    06_Tree
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.7" data-path="07_Graph.html">
            
                <a href="07_Graph.html">
            
                    
                    07_Graph
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.8" data-path="08_Sort.html">
            
                <a href="08_Sort.html">
            
                    
                    08_Sort
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.1.9" data-path="09_Search.html">
            
                <a href="09_Search.html">
            
                    
                    09_Search
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.10" data-path="data_structure.html">
            
                <a href="data_structure.html">
            
                    
                    data_structure
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../Algorithms/">
            
                <a href="../Algorithms/">
            
                    
                    Algorithms
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.2.1" data-path="../Algorithms/01_算法在计算中的作用.html">
            
                <a href="../Algorithms/01_算法在计算中的作用.html">
            
                    
                    01_算法在计算中的作用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.2" data-path="../Algorithms/02_算法基础.html">
            
                <a href="../Algorithms/02_算法基础.html">
            
                    
                    02_算法基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.3" data-path="../Algorithms/03_函数的增长.html">
            
                <a href="../Algorithms/03_函数的增长.html">
            
                    
                    03_函数的增长
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.4" data-path="../Algorithms/04_分治策略.html">
            
                <a href="../Algorithms/04_分治策略.html">
            
                    
                    04_分治策略
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.5" data-path="../Algorithms/15_动态规划.html">
            
                <a href="../Algorithms/15_动态规划.html">
            
                    
                    15_动态规划
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.6" data-path="../Algorithms/16_贪心算法.html">
            
                <a href="../Algorithms/16_贪心算法.html">
            
                    
                    16_贪心算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.7" data-path="../Algorithms/17_回溯.html">
            
                <a href="../Algorithms/17_回溯.html">
            
                    
                    17_回溯
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.8" data-path="../Algorithms/18_分支限界.html">
            
                <a href="../Algorithms/18_分支限界.html">
            
                    
                    18_分支限界
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.9" data-path="../Algorithms/19_NP问题.html">
            
                <a href="../Algorithms/19_NP问题.html">
            
                    
                    19_NP问题
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../../Cpp/">
            
                <a href="../../Cpp/">
            
                    
                    Cpp
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../../Cpp/C++-Primer/">
            
                <a href="../../Cpp/C++-Primer/">
            
                    
                    C++-Primer
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1.1" data-path="../../Cpp/C++-Primer/01_泛型算法.html">
            
                <a href="../../Cpp/C++-Primer/01_泛型算法.html">
            
                    
                    01_泛型算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.2" data-path="../../Cpp/C++-Primer/02_关联容器.html">
            
                <a href="../../Cpp/C++-Primer/02_关联容器.html">
            
                    
                    02_关联容器
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.3" data-path="../../Cpp/C++-Primer/03_动态内存.html">
            
                <a href="../../Cpp/C++-Primer/03_动态内存.html">
            
                    
                    03_动态内存
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.4" data-path="../../Cpp/C++-Primer/04_拷贝控制.html">
            
                <a href="../../Cpp/C++-Primer/04_拷贝控制.html">
            
                    
                    04_拷贝控制
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.5" data-path="../../Cpp/C++-Primer/05_重载运算与类型转换.html">
            
                <a href="../../Cpp/C++-Primer/05_重载运算与类型转换.html">
            
                    
                    05_重载运算与类型转换
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.6" data-path="../../Cpp/C++-Primer/06_面向对象程序设计.html">
            
                <a href="../../Cpp/C++-Primer/06_面向对象程序设计.html">
            
                    
                    06_面向对象程序设计
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.7" data-path="../../Cpp/C++-Primer/07_模板与泛型编程.html">
            
                <a href="../../Cpp/C++-Primer/07_模板与泛型编程.html">
            
                    
                    07_模板与泛型编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.8" data-path="../../Cpp/C++-Primer/08_标准库特殊设施.html">
            
                <a href="../../Cpp/C++-Primer/08_标准库特殊设施.html">
            
                    
                    08_标准库特殊设施
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.9" data-path="../../Cpp/C++-Primer/09_用于大型程序的工具.html">
            
                <a href="../../Cpp/C++-Primer/09_用于大型程序的工具.html">
            
                    
                    09_用于大型程序的工具
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.10" data-path="../../Cpp/C++-Primer/10_特殊工具与技术.html">
            
                <a href="../../Cpp/C++-Primer/10_特殊工具与技术.html">
            
                    
                    10_特殊工具与技术
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.11" data-path="../../Cpp/C++-Primer/11_lambda表达式的类型.html">
            
                <a href="../../Cpp/C++-Primer/11_lambda表达式的类型.html">
            
                    
                    11_lambda表达式的类型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.12" data-path="../../Cpp/C++-Primer/12_nullptr.html">
            
                <a href="../../Cpp/C++-Primer/12_nullptr.html">
            
                    
                    12_nullptr
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../../Cpp/Effective-Modern-C++/">
            
                <a href="../../Cpp/Effective-Modern-C++/">
            
                    
                    Effective-Modern-C++
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.2.1" data-path="../../Cpp/Effective-Modern-C++/CHAPTER_1_Deducing_Types.html">
            
                <a href="../../Cpp/Effective-Modern-C++/CHAPTER_1_Deducing_Types.html">
            
                    
                    CHAPTER_1_Deducing_Types
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.2" data-path="../../Cpp/Effective-Modern-C++/CHAPTER_2_auto.html">
            
                <a href="../../Cpp/Effective-Modern-C++/CHAPTER_2_auto.html">
            
                    
                    CHAPTER_2_auto
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.3" data-path="../../Cpp/Effective-Modern-C++/CHAPTER_3_Moving_to_Modern_C++.html">
            
                <a href="../../Cpp/Effective-Modern-C++/CHAPTER_3_Moving_to_Modern_C++.html">
            
                    
                    CHAPTER_3_Moving_to_Modern_C++
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.4" data-path="../../Cpp/Effective-Modern-C++/CHAPTER_4_Smart_Pointers.html">
            
                <a href="../../Cpp/Effective-Modern-C++/CHAPTER_4_Smart_Pointers.html">
            
                    
                    CHAPTER_4_Smart_Pointers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.5" data-path="../../Cpp/Effective-Modern-C++/CHAPTER_5_RValue_References,Move_Semantics_and_Perfect_Forwarding.html">
            
                <a href="../../Cpp/Effective-Modern-C++/CHAPTER_5_RValue_References,Move_Semantics_and_Perfect_Forwarding.html">
            
                    
                    CHAPTER_5_RValue_References,Move_Semantics_and_Perfect_Forwarding
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.6" data-path="../../Cpp/Effective-Modern-C++/CHAPTER_6_Lambda_Expressions.html">
            
                <a href="../../Cpp/Effective-Modern-C++/CHAPTER_6_Lambda_Expressions.html">
            
                    
                    CHAPTER_6_Lambda_Expressions
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../../Cpp/Modern-Cpp-templates-tutorial/">
            
                <a href="../../Cpp/Modern-Cpp-templates-tutorial/">
            
                    
                    Modern-Cpp-templates-tutorial
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.3.1" data-path="../../Cpp/Modern-Cpp-templates-tutorial/01_函数模板.html">
            
                <a href="../../Cpp/Modern-Cpp-templates-tutorial/01_函数模板.html">
            
                    
                    01_函数模板
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.2" data-path="../../Cpp/Modern-Cpp-templates-tutorial/02_类模板.html">
            
                <a href="../../Cpp/Modern-Cpp-templates-tutorial/02_类模板.html">
            
                    
                    02_类模板
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../../Cpp/Pre-knowledge/">
            
                <a href="../../Cpp/Pre-knowledge/">
            
                    
                    Pre-knowledge
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.4.1" data-path="../../Cpp/Pre-knowledge/01_Element-knowledge.html">
            
                <a href="../../Cpp/Pre-knowledge/01_Element-knowledge.html">
            
                    
                    01_Element-knowledge
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.2" data-path="../../Cpp/Pre-knowledge/02_Pointer_and_Reference.html">
            
                <a href="../../Cpp/Pre-knowledge/02_Pointer_and_Reference.html">
            
                    
                    02_Pointer_and_Reference
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.3" data-path="../../Cpp/Pre-knowledge/03_Class_and_Object.html">
            
                <a href="../../Cpp/Pre-knowledge/03_Class_and_Object.html">
            
                    
                    03_Class_and_Object
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.4" data-path="../../Cpp/Pre-knowledge/04_Default_Member_Function.html">
            
                <a href="../../Cpp/Pre-knowledge/04_Default_Member_Function.html">
            
                    
                    04_Default_Member_Function
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.5" data-path="../../Cpp/Pre-knowledge/05_Conversion_and_Namespace.html">
            
                <a href="../../Cpp/Pre-knowledge/05_Conversion_and_Namespace.html">
            
                    
                    05_Conversion_and_Namespace
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.6" data-path="../../Cpp/Pre-knowledge/06_Inheritance_and_Virtual.html">
            
                <a href="../../Cpp/Pre-knowledge/06_Inheritance_and_Virtual.html">
            
                    
                    06_Inheritance_and_Virtual
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.7" data-path="../../Cpp/Pre-knowledge/07_Polymorphism.html">
            
                <a href="../../Cpp/Pre-knowledge/07_Polymorphism.html">
            
                    
                    07_Polymorphism
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.8" data-path="../../Cpp/Pre-knowledge/08_Relationship_of_Class.html">
            
                <a href="../../Cpp/Pre-knowledge/08_Relationship_of_Class.html">
            
                    
                    08_Relationship_of_Class
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.9" data-path="../../Cpp/Pre-knowledge/09_Diamond_Inheritance.html">
            
                <a href="../../Cpp/Pre-knowledge/09_Diamond_Inheritance.html">
            
                    
                    09_Diamond_Inheritance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.10" data-path="../../Cpp/Pre-knowledge/10_dynamic_cast.html">
            
                <a href="../../Cpp/Pre-knowledge/10_dynamic_cast.html">
            
                    
                    10_dynamic_cast
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.11" data-path="../../Cpp/Pre-knowledge/11_Expressions.html">
            
                <a href="../../Cpp/Pre-knowledge/11_Expressions.html">
            
                    
                    11_Expressions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.12" data-path="../../Cpp/Pre-knowledge/12_Singleton_Pattern.html">
            
                <a href="../../Cpp/Pre-knowledge/12_Singleton_Pattern.html">
            
                    
                    12_Singleton_Pattern
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.13" data-path="../../Cpp/Pre-knowledge/13_static.html">
            
                <a href="../../Cpp/Pre-knowledge/13_static.html">
            
                    
                    13_static
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.14" data-path="../../Cpp/Pre-knowledge/14_virtual.html">
            
                <a href="../../Cpp/Pre-knowledge/14_virtual.html">
            
                    
                    14_virtual
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.15" data-path="../../Cpp/Pre-knowledge/15_Miscellaneous.html">
            
                <a href="../../Cpp/Pre-knowledge/15_Miscellaneous.html">
            
                    
                    15_Miscellaneous
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../../计算机组成原理/">
            
                <a href="../../计算机组成原理/">
            
                    
                    计算机组成原理
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../../计算机组成原理/计算机组成原理基础知识.html">
            
                <a href="../../计算机组成原理/计算机组成原理基础知识.html">
            
                    
                    计算机组成原理基础知识
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../../计算机组成原理/计算机组成原理基础知识（简答版）.html">
            
                <a href="../../计算机组成原理/计算机组成原理基础知识（简答版）.html">
            
                    
                    计算机组成原理基础知识（简答版）
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../../Operating_System/">
            
                <a href="../../Operating_System/">
            
                    
                    Operating System
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../../Operating_System/01_概论.html">
            
                <a href="../../Operating_System/01_概论.html">
            
                    
                    01_概论
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../../Operating_System/02_进程管理.html">
            
                <a href="../../Operating_System/02_进程管理.html">
            
                    
                    02_进程管理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../../Operating_System/03_中断和处理器调度.html">
            
                <a href="../../Operating_System/03_中断和处理器调度.html">
            
                    
                    03_中断和处理器调度
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../../Operating_System/04_互斥同步与通讯.html">
            
                <a href="../../Operating_System/04_互斥同步与通讯.html">
            
                    
                    04_互斥同步与通讯
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="../../Operating_System/05_死锁与饥饿.html">
            
                <a href="../../Operating_System/05_死锁与饥饿.html">
            
                    
                    05_死锁与饥饿
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="../../Operating_System/06_主存管理.html">
            
                <a href="../../Operating_System/06_主存管理.html">
            
                    
                    06_主存管理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.7" data-path="../../Operating_System/07_虚拟存储器管理.html">
            
                <a href="../../Operating_System/07_虚拟存储器管理.html">
            
                    
                    07_虚拟存储器管理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.8" data-path="../../Operating_System/08_文件与文件系统.html">
            
                <a href="../../Operating_System/08_文件与文件系统.html">
            
                    
                    08_文件与文件系统
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.9" data-path="../../Operating_System/09_设备与IO管理.html">
            
                <a href="../../Operating_System/09_设备与IO管理.html">
            
                    
                    09_设备与IO管理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.10" data-path="../../Operating_System/review.html">
            
                <a href="../../Operating_System/review.html">
            
                    
                    review
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../../物联网控制技术/">
            
                <a href="../../物联网控制技术/">
            
                    
                    物联网控制技术
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../../物联网控制技术/01_概述物联网控制.html">
            
                <a href="../../物联网控制技术/01_概述物联网控制.html">
            
                    
                    01_概述物联网控制
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../../物联网控制技术/02_单片机.html">
            
                <a href="../../物联网控制技术/02_单片机.html">
            
                    
                    02_单片机
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../../物联网控制技术/03_51汇编语言.html">
            
                <a href="../../物联网控制技术/03_51汇编语言.html">
            
                    
                    03_51汇编语言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../../物联网控制技术/04_C51语言.html">
            
                <a href="../../物联网控制技术/04_C51语言.html">
            
                    
                    04_C51语言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="../../物联网控制技术/05_软硬件结合.html">
            
                <a href="../../物联网控制技术/05_软硬件结合.html">
            
                    
                    05_软硬件结合
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="../../物联网控制技术/06_物联网控制算法.html">
            
                <a href="../../物联网控制技术/06_物联网控制算法.html">
            
                    
                    06_物联网控制算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.7" data-path="../../物联网控制技术/07_物联网控制系统.html">
            
                <a href="../../物联网控制技术/07_物联网控制系统.html">
            
                    
                    07_物联网控制系统
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8" data-path="../../物联网控制技术/08_review.html">
            
                <a href="../../物联网控制技术/08_review.html">
            
                    
                    08_review
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../../RFID/">
            
                <a href="../../RFID/">
            
                    
                    RFID
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../../RFID/01_射频识别技术概论.html">
            
                <a href="../../RFID/01_射频识别技术概论.html">
            
                    
                    01_射频识别技术概论
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../../RFID/02_RFID基础与前端.html">
            
                <a href="../../RFID/02_RFID基础与前端.html">
            
                    
                    02_RFID基础与前端
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../../RFID/03_编码和调制.html">
            
                <a href="../../RFID/03_编码和调制.html">
            
                    
                    03_编码和调制
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4" data-path="../../RFID/04_数据校验和防碰撞算法.html">
            
                <a href="../../RFID/04_数据校验和防碰撞算法.html">
            
                    
                    04_数据校验和防碰撞算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.5" data-path="../../RFID/05_RFID系统数据传输的安全性.html">
            
                <a href="../../RFID/05_RFID系统数据传输的安全性.html">
            
                    
                    05_RFID系统数据传输的安全性
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.6" data-path="../../RFID/06_RFID标准.html">
            
                <a href="../../RFID/06_RFID标准.html">
            
                    
                    06_RFID标准
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.7" data-path="../../RFID/review.html">
            
                <a href="../../RFID/review.html">
            
                    
                    review
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.8" data-path="../../RFID/RFID技术模拟考试题.html">
            
                <a href="../../RFID/RFID技术模拟考试题.html">
            
                    
                    RFID技术模拟考试题
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../../传感器技术/">
            
                <a href="../../传感器技术/">
            
                    
                    传感器技术
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../../传感器技术/传感器.html">
            
                <a href="../../传感器技术/传感器.html">
            
                    
                    传感器
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            本书使用 HonKit 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../../.." >09_Search</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <html><head></head><body><div id="anchor-navigation-ex-navbar"><i class="fa fa-navicon"></i><ul><li><span class="title-icon "></span><a href="#查找"><b></b>查找</a></li><ul><li><span class="title-icon "></span><a href="#定义"><b></b>定义</a></li><li><span class="title-icon "></span><a href="#线性结构查找"><b></b>线性结构查找</a></li><ul><li><span class="title-icon "></span><a href="#顺序查找"><b></b>顺序查找</a></li><li><span class="title-icon "></span><a href="#二分查找"><b></b>二分查找</a></li><li><span class="title-icon "></span><a href="#分块查找"><b></b>分块查找</a></li></ul><li><span class="title-icon "></span><a href="#树形结构的查找"><b></b>树形结构的查找</a></li><ul><li><span class="title-icon "></span><a href="#二叉查找树"><b></b>二叉查找树</a></li><li><span class="title-icon "></span><a href="#avltree高度平衡树"><b></b>AVLTree(高度平衡树)</a></li><li><span class="title-icon "></span><a href="#红黑树（red-black-tree）"><b></b>红黑树（Red Black Tree）</a></li><li><span class="title-icon "></span><a href="#splay-树"><b></b>Splay 树</a></li><li><span class="title-icon "></span><a href="#节点维护信息"><b></b>节点维护信息</a></li><li><span class="title-icon "></span><a href="#b树（b-tree）"><b></b>B树（B-Tree）</a></li><li><span class="title-icon "></span><a href="#b-树"><b></b>B+ 树</a></li></ul><li><span class="title-icon "></span><a href="#散列查找"><b></b>散列查找</a></li><ul><li><span class="title-icon "></span><a href="#散列（hash-亦称哈希、杂凑）"><b></b>散列（Hash, 亦称哈希、杂凑）</a></li></ul></ul></ul></div><a href="#查找" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><div class="treeview__container"><ul>
<li><div><a href="#查找">查找</a><i class="level__parent level__item level__parent--opened" state="opened" onclick="var curState = this.getAttribute('state');var nextState = curState === 'opened' ? 'hidden' : 'opened';this.setAttribute('state', nextState);this.className = this.className.split(curState).join(nextState);var list = this.parentNode.nextElementSibling;if (nextState === 'hidden') {    list.style.display = 'none';} else {    list.style.display = 'block';}"></i></div>
<ul>
<li><div><a href="#定义">定义</a><i></i></div></li>
<li><div><a href="#线性结构查找">线性结构查找</a><i class="level__parent level__item level__parent--opened" state="opened" onclick="var curState = this.getAttribute('state');var nextState = curState === 'opened' ? 'hidden' : 'opened';this.setAttribute('state', nextState);this.className = this.className.split(curState).join(nextState);var list = this.parentNode.nextElementSibling;if (nextState === 'hidden') {    list.style.display = 'none';} else {    list.style.display = 'block';}"></i></div>
<ul>
<li><div><a href="#顺序查找">顺序查找</a><i></i></div></li>
<li><div><a href="#二分查找">二分查找</a><i class="level__parent level__item level__parent--opened" state="opened" onclick="var curState = this.getAttribute('state');var nextState = curState === 'opened' ? 'hidden' : 'opened';this.setAttribute('state', nextState);this.className = this.className.split(curState).join(nextState);var list = this.parentNode.nextElementSibling;if (nextState === 'hidden') {    list.style.display = 'none';} else {    list.style.display = 'block';}"></i></div>
<ul>
<li><div><a href="#对半查找">对半查找</a><i></i></div></li>
<li><div><a href="#斐波那契查找">斐波那契查找</a><i></i></div></li>
<li><div><a href="#插值查找">插值查找</a><i></i></div></li>
</ul></li>
<li><div><a href="#分块查找">分块查找</a><i></i></div></li>
</ul></li>
<li><div><a href="#树形结构的查找">树形结构的查找</a><i class="level__parent level__item level__parent--opened" state="opened" onclick="var curState = this.getAttribute('state');var nextState = curState === 'opened' ? 'hidden' : 'opened';this.setAttribute('state', nextState);this.className = this.className.split(curState).join(nextState);var list = this.parentNode.nextElementSibling;if (nextState === 'hidden') {    list.style.display = 'none';} else {    list.style.display = 'block';}"></i></div>
<ul>
<li><div><a href="#二叉查找树">二叉查找树</a><i></i></div></li>
<li><div><a href="#avltree高度平衡树">AVLTree(高度平衡树)</a><i></i></div></li>
<li><div><a href="#红黑树（red-black-tree）">红黑树（Red Black Tree）</a><i></i></div></li>
<li><div><a href="#splay-树">Splay 树</a><i></i></div></li>
<li><div><a href="#b树（b-tree）">B树（B-Tree）</a><i></i></div></li>
<li><div><a href="#b-树">B+ 树</a><i></i></div></li>
</ul></li>
<li><div><a href="#散列查找">散列查找</a><i class="level__parent level__item level__parent--opened" state="opened" onclick="var curState = this.getAttribute('state');var nextState = curState === 'opened' ? 'hidden' : 'opened';this.setAttribute('state', nextState);this.className = this.className.split(curState).join(nextState);var list = this.parentNode.nextElementSibling;if (nextState === 'hidden') {    list.style.display = 'none';} else {    list.style.display = 'block';}"></i></div>
<ul>
<li><div><a href="#散列（hash-亦称哈希、杂凑）">散列（Hash, 亦称哈希、杂凑）</a><i class="level__parent level__item level__parent--opened" state="opened" onclick="var curState = this.getAttribute('state');var nextState = curState === 'opened' ? 'hidden' : 'opened';this.setAttribute('state', nextState);this.className = this.className.split(curState).join(nextState);var list = this.parentNode.nextElementSibling;if (nextState === 'hidden') {    list.style.display = 'none';} else {    list.style.display = 'block';}"></i></div>
<ul>
<li><div><a href="#哈希函数">哈希函数</a><i></i></div></li>
<li><div><a href="#冲突">冲突</a><i></i></div></li>
<li><div><a href="#散列表的删除">散列表的删除</a><i></i></div></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>

<h1 id="查找"><a name="查找" class="anchor-navigation-ex-anchor" href="#查找"><i class="fa fa-link" aria-hidden="true"></i></a>查找</h1>
<h2 id="定义"><a name="定义" class="anchor-navigation-ex-anchor" href="#定义"><i class="fa fa-link" aria-hidden="true"></i></a>定义</h2>
<blockquote>
<p>[!note]</p>
<ul>
<li><strong>查找亦称检索</strong>。给定一个文件包含n个记录（或称元 素、结点），每个记录都有一个关键词域。一个查找算法， 就是对给定的值K，在文件中找关键词等于K的那个记录。</li>
<li>查找结果：成功或者失败</li>
<li>平均查找长度：查找一个元素所作的关键词平均比较次数</li>
</ul>
</blockquote>
<h2 id="线性结构查找"><a name="线性结构查找" class="anchor-navigation-ex-anchor" href="#线性结构查找"><i class="fa fa-link" aria-hidden="true"></i></a>线性结构查找</h2>
<h3 id="顺序查找"><a name="顺序查找" class="anchor-navigation-ex-anchor" href="#顺序查找"><i class="fa fa-link" aria-hidden="true"></i></a>顺序查找</h3>
<ul>
<li>从表的一端开始，依次将记录的关键字和给定值进行比较，寻找关键字</li>
<li>既适用于线性表的顺序存储结构，又适用于线性表的链式存储结构</li>
<li>实现简单，仅实现其中数组查找</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T </span>= <span class="hljs-type">int</span>&gt;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Seq</span><span class="hljs-params">(T* ST,<span class="hljs-type">int</span> n, T key)</span>
</span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
    {
        <span class="hljs-comment">//比较</span>
        <span class="hljs-keyword">if</span> (ST[i] == key)
        {
            <span class="hljs-comment">//直接返回</span>
            <span class="hljs-keyword">return</span> i;
        }
    }
    <span class="hljs-comment">//查找失败返回-1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}
</code></pre>
<ul>
<li>改进</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">//通过为表引入一个“虚拟＂记录key即设置监视哨，并且每次前进步长为二</span>
<span class="hljs-comment">//通过设置监视哨， 免去查找过程中每一步都要检测整个表是否查找完毕从而减少比较次数，能提高算法S的查找效率</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T </span>= <span class="hljs-type">int</span>&gt;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Seq_modify</span><span class="hljs-params">(std::vector&lt;T&gt;&amp; ST, T key)</span>
</span>{
    <span class="hljs-comment">// 放入虚拟记录</span>
    ST.<span class="hljs-built_in">push_back</span>(key);

    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (ST[i] != key) 
    {
        <span class="hljs-keyword">if</span> (ST[i + <span class="hljs-number">1</span>] != key) 
        {
            i += <span class="hljs-number">2</span>;  <span class="hljs-comment">// 步长为2</span>
        } 
        <span class="hljs-keyword">else</span> 
        {
            i++;  <span class="hljs-comment">// 步长为1</span>
        }
    }

    <span class="hljs-comment">// 返回结果</span>
    <span class="hljs-keyword">if</span> (i == ST.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) 
    {
        <span class="hljs-comment">// 查找失败</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    } 
    <span class="hljs-keyword">else</span> 
    {
        <span class="hljs-comment">// 查找成功，返回索引</span>
        <span class="hljs-keyword">return</span> i;
    }
}
</code></pre>
<h3 id="二分查找"><a name="二分查找" class="anchor-navigation-ex-anchor" href="#二分查找"><i class="fa fa-link" aria-hidden="true"></i></a>二分查找</h3>
<p>二分查找要求线性表必须采用顺序存储结构， 而且表中元素按关键字有序排列</p>
<blockquote>
<ul>
<li>有序表Rlow ,Rlow+1 ,…, Rhigh 按照关键词递增有序。</li>
<li>选取一个 位置 mid (low &lt;= mid &lt;= high)，比较K和Rmid，<ul>
<li>若: K &lt; Rmid，[K只可能在Rmid左侧] </li>
<li>K &gt; Rmid，[K只可能在Rmid右侧] </li>
<li>K = Rmid ，[查找成功结束] </li>
<li>使用不同的规则确定mid，可得到不同的二分查找方法：<strong>对半查找、斐波那契查找、插值查找</strong>等</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="对半查找"><a name="对半查找" class="anchor-navigation-ex-anchor" href="#对半查找"><i class="fa fa-link" aria-hidden="true"></i></a>对半查找</h4>
<p>K与待查表的中间记录进行比较，即<code>mid == (low+high)/2</code></p>
<p>每次迭代可将查找范围缩小一半。</p>
<ul>
<li>左闭右闭</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">// target 是在一个在左闭右闭的区间里，也就是[left, right] </span>
<span class="hljs-comment">//闭区间里，while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的</span>
<span class="hljs-comment">//if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T</span>=<span class="hljs-type">int</span>&gt;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Binary_Search</span><span class="hljs-params">(T* a, <span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right, T key)</span>
</span>{
    <span class="hljs-type">int</span> mid;

    <span class="hljs-comment">//循坏搜索</span>
    <span class="hljs-keyword">while</span> (left &lt;= right)
    {
        <span class="hljs-comment">//防止溢出 等同于(left + right) / 2</span>
        mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);

        <span class="hljs-keyword">if</span> (key &lt; a[mid])<span class="hljs-comment">//大于转为右区间</span>
        {

            right = mid - <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[mid] &lt; key)<span class="hljs-comment">//小于转为左区间</span>
        {
            left = mid + <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span><span class="hljs-comment">//找到键值</span>
        {
            <span class="hljs-keyword">return</span> mid;
        }
    }

    <span class="hljs-comment">//未找到</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}
</code></pre>
<ul>
<li>左闭右开</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">//定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</span>
<span class="hljs-comment">//while (left &lt; right)，这里使用 &lt; , 因为left == right在区间[left, right)是没有意义的</span>
<span class="hljs-comment">//if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T</span>=<span class="hljs-type">int</span>&gt;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Binary_Search</span><span class="hljs-params">(T* a, <span class="hljs-type">int</span> n, T key)</span>
</span>{
    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> right = n;

    <span class="hljs-comment">//循坏搜索</span>
    <span class="hljs-keyword">while</span> (left &lt; right)
    {
        <span class="hljs-type">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);

        <span class="hljs-keyword">if</span> (key &lt; a[mid])<span class="hljs-comment">//大于转为右区间</span>
        {

            right = mid;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[mid] &lt; key)<span class="hljs-comment">//小于转为左区间</span>
        {
            left = mid + <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span><span class="hljs-comment">//找到键值</span>
        {
            <span class="hljs-keyword">return</span> mid;
        }
    }

    <span class="hljs-comment">// 未找到目标值</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}
</code></pre>
<ul>
<li>递归写法</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">//闭区间递归实现二分查找</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T </span>= <span class="hljs-type">int</span>&gt;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Binary_Search_Recursive</span><span class="hljs-params">(T* a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, T key)</span>
</span>{
    <span class="hljs-keyword">if</span> (left &gt; right) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 区间为空，未找到</span>
    }

    <span class="hljs-type">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 计算中间索引，防止溢出</span>

    <span class="hljs-keyword">if</span> (key &lt; a[mid]) {
        <span class="hljs-comment">// 在左区间查找</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Binary_Search_Recursive</span>(a, left, mid - <span class="hljs-number">1</span>, key);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[mid] &lt; key) {
        <span class="hljs-comment">// 在右区间查找</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Binary_Search_Recursive</span>(a, mid + <span class="hljs-number">1</span>, right, key);
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 找到目标值</span>
        <span class="hljs-keyword">return</span> mid;
    }
}

<span class="hljs-comment">// 左闭右开递归实现 [left, right)</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T </span>= <span class="hljs-type">int</span>&gt;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Binary_Search_Recursive_Open</span><span class="hljs-params">(T* a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, T key)</span>
</span>{
    <span class="hljs-keyword">if</span> (left &gt;= right) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 区间为空，未找到</span>
    }

    <span class="hljs-type">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 防止溢出</span>

    <span class="hljs-keyword">if</span> (key &lt; a[mid]) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Binary_Search_Recursive_Open</span>(a, left, mid, key); <span class="hljs-comment">// 在左区间查找</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[mid] &lt; key) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Binary_Search_Recursive_Open</span>(a, mid + <span class="hljs-number">1</span>, right, key); <span class="hljs-comment">// 在右区间查找</span>
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> mid; <span class="hljs-comment">// 找到目标值</span>
    }
}
</code></pre>
<ul>
<li>扩展：二叉判定树</li>
</ul>
<blockquote>
<ul>
<li>便于分析算法的时间效率，采用二叉树表示查找过程</li>
<li>对于 有序表Rlow , Rlow+1 ,…, Rhigh ，对半查找的二叉判定树T(low,high) 的是按如下递归定义的扩充二叉树： <ul>
<li>当high-low+1 &lt;= 0时：T(low, high)为空； </li>
<li>当high-low+1 &gt; 0时，令mid=(low+high)/2 <ul>
<li>T(low, high)的根结点是mid ； </li>
<li>根结点的左子树是Rlow ,…,Rmid-1 对应的二叉判定树； </li>
<li>根结点的右子树是Rmid+1 ,…,Rhigh 对应的二叉判定树。</li>
</ul>
</li>
</ul>
</li>
<li>在二叉树中空指针的位置，都增加特殊的结点（空叶结点）， 由此生成的二叉树称为扩充二叉树。称空叶结点为外结点，其余结点为内结点</li>
<li>对半查找算法的每次 成功查找对应判定树 的一个内结点，元素 比较次数为该结点的深度加1，用于计算查找成功的平均查找长度。</li>
<li>每次不成功的查找对应判定树的一个外结 点，关键词的比较次 数为该结点的深度。用于计算查找失败的平均查找长度。</li>
</ul>
</blockquote>
<ul>
<li>对于对半查找的优化或者改进</li>
</ul>
<blockquote>
<ul>
<li><strong>一致查找</strong></li>
<li></li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">//一致对半查找，</span>
<span class="hljs-comment">//譬如仅使用三个指针(s、门和e)中的两个。</span>
<span class="hljs-comment">//其具体思路是，使用当前位置i和它的变化率x,在每次不相等的比较之后，可置i&lt;-i土x和x&lt;-x/2(近似地）。</span>
<span class="hljs-comment">// 算法U之所以被称为是一致的，</span>
<span class="hljs-comment">//其原因是在第K层上的一个结点的编号与在第K - l层上其父结点的编号之差的绝对值，</span>
<span class="hljs-comment">//对于第k层上的所有结点均有一致的常数x。</span>

<span class="hljs-comment">//构建辅助数组DELTA记录每次区间数量m的值,避免在查找过程中计算。</span>
<span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cal_delta</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>
</span>{
    std::vector&lt;<span class="hljs-type">int</span>&gt; delta; <span class="hljs-comment">// 保存步长</span>
    <span class="hljs-type">int</span> k = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">log2</span>(n)) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 计算层数</span>
    <span class="hljs-type">int</span> temp = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)
    {
        delta.<span class="hljs-built_in">push_back</span>((n + temp) / (temp * <span class="hljs-number">2</span>)); <span class="hljs-comment">// 计算步长</span>
        temp *= <span class="hljs-number">2</span>; <span class="hljs-comment">// 更新 temp</span>
    }

    <span class="hljs-keyword">return</span> delta; <span class="hljs-comment">// 返回步长数组</span>
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T </span>= <span class="hljs-type">int</span>&gt;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cbiSearch</span><span class="hljs-params">(T* a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> key)</span>
</span>{
    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 空数组，直接返回</span>

    <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == key)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 特殊情况：第一个元素就是目标</span>

    std::vector&lt;<span class="hljs-type">int</span>&gt; Delta = <span class="hljs-built_in">cal_delta</span>(n); <span class="hljs-comment">// 生成步长数组</span>
    <span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>;
    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;        <span class="hljs-comment">// 当前步长索引</span>

    <span class="hljs-keyword">while</span> (key != a[i]) <span class="hljs-comment">// 循环直到找到 key</span>
    {
        <span class="hljs-keyword">if</span> (key &lt; a[i]) <span class="hljs-comment">// key 在当前元素左侧</span>
        {
            <span class="hljs-keyword">if</span> ( j &gt;= Delta.<span class="hljs-built_in">size</span>()|| Delta[j] == <span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 步长为 0，无法再分割</span>
            <span class="hljs-keyword">else</span>
            {
                i -= Delta[j]; <span class="hljs-comment">// 左移</span>
                j++;           <span class="hljs-comment">// 步长递减</span>
            }
        }
        <span class="hljs-keyword">if</span> (a[i] &lt; key) <span class="hljs-comment">// key 在当前元素右侧</span>
        {
            <span class="hljs-keyword">if</span> (j &gt;= Delta.<span class="hljs-built_in">size</span>() || Delta[j] == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 步长为 0，无法再分割</span>
            <span class="hljs-keyword">else</span>
            {
                i += Delta[j]; <span class="hljs-comment">// 右移</span>
                j++;           <span class="hljs-comment">// 步长递减</span>
            }
        }
    }
    <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// 找到目标，返回下标</span>
}
</code></pre>
</blockquote>
<h4 id="斐波那契查找"><a name="斐波那契查找" class="anchor-navigation-ex-anchor" href="#斐波那契查找"><i class="fa fa-link" aria-hidden="true"></i></a>斐波那契查找</h4>
<ul>
<li>在二分搜索的基础上，根据斐波那契数列分割，而不是简单的二分</li>
<li>前提是待查找的查找表必须顺序存储并且有序</li>
<li>平均和最坏情况下的时间复杂性为O(log2n)。</li>
<li>总体运行时间略快于对半查找算法。 因为<strong>算法不涉及乘除法</strong>，而只涉及加减法。</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">//数列从坐标1开始计数</span>
<span class="hljs-comment">//构造辅助数组，即斐波那契数列，数列生成到大于等于n</span>
<span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">Fib_arr</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>
</span>{
    std::vector&lt;<span class="hljs-type">int</span>&gt; Fib;
    <span class="hljs-comment">//初始化</span>
    Fib.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);
    Fib.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;; i++)
    {
        <span class="hljs-type">int</span> next = Fib[i - <span class="hljs-number">1</span>] + Fib[i - <span class="hljs-number">2</span>];
        Fib.<span class="hljs-built_in">push_back</span>(next);
        <span class="hljs-keyword">if</span> (next - <span class="hljs-number">1</span> &gt;= n) <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-keyword">return</span> Fib;
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T</span>=<span class="hljs-type">int</span>&gt;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci_Search</span><span class="hljs-params">(T* a,<span class="hljs-type">int</span> n,T key)</span>
</span>{
    <span class="hljs-comment">//空表</span>
    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;

    <span class="hljs-comment">//初始化</span>
    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> right = n - <span class="hljs-number">1</span>;

    <span class="hljs-comment">//得到辅助数列</span>
    std::vector&lt;<span class="hljs-type">int</span>&gt; F = <span class="hljs-built_in">Fib_arr</span>(n);
    <span class="hljs-type">int</span> k = F.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;

    <span class="hljs-comment">//如果a数组不足F[k]-1，则重复增加a的最后一个数直到长度等于F[k]-1</span>
    std::vector&lt;T&gt; temp{ a,a+n };

    <span class="hljs-comment">//一次性调整 temp 的大小来提高效率</span>
    temp.<span class="hljs-built_in">resize</span>(F[k] - <span class="hljs-number">1</span>, temp[n - <span class="hljs-number">1</span>]);


    <span class="hljs-comment">//查找，注意这里实现查找区间左边比右边大</span>
    <span class="hljs-comment">//即如果当前区间为F[k]-1=F[k-1]-1 + F[k-2]-1 + 1;最后一个1的位置给mid</span>
    <span class="hljs-comment">//左区间为F[k-1]-1, 右区间为F[k-2]-1</span>
    <span class="hljs-keyword">while</span> (left &lt;= right)
    {
        <span class="hljs-comment">// mid 由左边界和 F[k-1] 决定，确保不越界,但是正常情况下不会越界 </span>
        <span class="hljs-type">int</span> mid = std::<span class="hljs-built_in">min</span>(left + F[k - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>, right);

        <span class="hljs-keyword">if</span> (key &lt; temp[mid])  <span class="hljs-comment">// 如果 key 在左区间</span>
        {
            right = mid - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 更新右边界</span>
            k -= <span class="hljs-number">1</span>;          <span class="hljs-comment">// 更新斐波那契索引，左区间长度为 F[k-1]</span>
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp[mid] &lt; key)  <span class="hljs-comment">// 如果 key 在右区间</span>
        {
            left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 更新左边界</span>
            k -= <span class="hljs-number">2</span>;          <span class="hljs-comment">// 更新斐波那契索引，右区间长度为 F[k-2]</span>
        }
        <span class="hljs-keyword">else</span>  <span class="hljs-comment">// 找到目标值</span>
        {
            <span class="hljs-comment">// 如果是补充值，则返回原数组最后一个元素</span>
            <span class="hljs-keyword">return</span> mid &lt; n ? mid : n - <span class="hljs-number">1</span>;  
        }
    }

    <span class="hljs-comment">//未找到</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}
</code></pre>
<h4 id="插值查找"><a name="插值查找" class="anchor-navigation-ex-anchor" href="#插值查找"><i class="fa fa-link" aria-hidden="true"></i></a>插值查找</h4>
<ul>
<li>基本原理是根据要查找的值在有序数组中的大致位置进行估计，以此来缩小搜索范围</li>
<li>通过数据的分布情况来预测目标值的位置，特别适用于有序且均匀分布的数据集</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T</span>=<span class="hljs-type">int</span>&gt;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InterPolation_Search</span><span class="hljs-params">(T* a, <span class="hljs-type">int</span> n, T key)</span>
</span>{
    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;

    <span class="hljs-comment">//初始化</span>
    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> right = n - <span class="hljs-number">1</span>;
    <span class="hljs-comment">//插值</span>
    <span class="hljs-type">int</span> pos = INT_MAX;
    <span class="hljs-comment">//迭代</span>
    <span class="hljs-keyword">while</span> (left &lt;= right&amp;&amp;a[left]!=a[right])<span class="hljs-comment">//防止除以零</span>
    {
        <span class="hljs-comment">// 使用插值公式计算估计位置,此处和二分查找不同</span>
        pos = left + (((key - a[left]) * (right - left)) / (a[right] - a[left]));

        <span class="hljs-comment">// 越界检查</span>
        <span class="hljs-keyword">if</span> (pos &lt; left || pos &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;

        <span class="hljs-keyword">if</span> (key &lt; a[pos])
        {
            right = pos - <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[pos] &lt; key)
        {
            left = pos + <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">return</span> pos;
        }

    }

    <span class="hljs-comment">// 特殊情况：剩余单个元素时检查是否匹配</span>
    <span class="hljs-keyword">return</span> (a[left] == key) ? left : <span class="hljs-number">-1</span>;
}
</code></pre>
<h3 id="分块查找"><a name="分块查找" class="anchor-navigation-ex-anchor" href="#分块查找"><i class="fa fa-link" aria-hidden="true"></i></a>分块查找</h3>
<ul>
<li><p>分块查找，又称为索引顺序查找</p>
</li>
<li><p>在此查找法中，除表本身以外，尚需建立一个 “索引表”。</p>
</li>
<li><p>对每个子表（或称块）建立一个索引项，其中包括两项内容：</p>
</li>
<li><p>关键字项（其值为该子表内的最大关键字）和指针项（指示该子表的第一个记录在表中位置）。</p>
</li>
<li><p>索引表按关键字有序，则表或者有序或者分块有序，由于块内是无序的，故插入和删除比较容易，无需进行大量移动。</p>
</li>
<li><p>过程</p>
<blockquote>
<ol>
<li>将大数组分成若干子数组（块），每个块中的数值都 比后一块中数值小（块内不要求有序），建一个索引表记录每个子表的起始地址和各块中的最大关键字</li>
<li>先将key依次和索引表中各最大关键字利用对半查找进行比较，确定待查记录所在的块（子表）</li>
<li>确定了关键字所在的块后，从该块的指针项（指示该子表的第一个记录在表中位置）顺序查找</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="树形结构的查找"><a name="树形结构的查找" class="anchor-navigation-ex-anchor" href="#树形结构的查找"><i class="fa fa-link" aria-hidden="true"></i></a>树形结构的查找</h2>
<blockquote>
<p>[!tip]</p>
<ul>
<li>对有序数组的二分查找，适用于静态查找场景，若元素动态变化（插入、删除元素），为了维持数组有序，需要O(n)时间调整。</li>
<li>所以就有了树形结构的查找结构</li>
</ul>
</blockquote>
<h3 id="二叉查找树"><a name="二叉查找树" class="anchor-navigation-ex-anchor" href="#二叉查找树"><i class="fa fa-link" aria-hidden="true"></i></a>二叉查找树</h3>
<blockquote>
<p>[!note]</p>
<ul>
<li>一棵二叉树，其各结点关键词互异，且中根序列按其关键词递增排列</li>
<li>二叉查找树中任一结点P，其左子树中结点的关键词都小于P的关键词，右子树中结点的关键词都大于P的关键词， 且结点P的左右子树也都是二叉查找树。</li>
<li>查找、插入、删除平均时间复杂度O(logn)，但最坏情况时间复杂度为O(n)（根节点为最大节点或者最小结点</li>
</ul>
</blockquote>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>=<span class="hljs-type">int</span>&gt;
<span class="hljs-keyword">class</span> Tree
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//数据项</span>
    T data;<span class="hljs-comment">//重载了==运算符和&lt;运算符</span>
    <span class="hljs-comment">//左右子树</span>
    Tree* lchild;
    Tree* rchild;

    <span class="hljs-comment">// 维护其他信息，如高度，节点数量等</span>

    <span class="hljs-type">int</span> size;   <span class="hljs-comment">// 当前节点为根的子树大小</span>
    <span class="hljs-type">int</span> count;  <span class="hljs-comment">// 当前节点的重复数量</span>

    <span class="hljs-built_in">Tree</span>() = <span class="hljs-keyword">default</span>;
    <span class="hljs-built_in">Tree</span>(T key,Tree* left=<span class="hljs-literal">nullptr</span>, Tree* right=<span class="hljs-literal">nullptr</span>):<span class="hljs-built_in">size</span>(<span class="hljs-number">1</span>),<span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>),<span class="hljs-built_in">data</span>(key),<span class="hljs-built_in">lchild</span>(left),<span class="hljs-built_in">rchild</span>(right){ }

};
</code></pre>
<ul>
<li><p>核心操作</p>
<ul>
<li><strong>查找</strong>：在二叉查找树中查找关键词为K的结点</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">//在根指针T所指二叉排序树中递归地查找某关键字等于key的数据元素</span>
    <span class="hljs-function">Tree&lt;T&gt;* <span class="hljs-title">SearchBiSortTree</span><span class="hljs-params">(Tree&lt;T&gt;* root, T key)</span>
    </span>{
        <span class="hljs-comment">//二叉排序树为空，则查找失败，返回空指针</span>
        <span class="hljs-keyword">if</span> (!root)<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;

        <span class="hljs-comment">//key等千T-&gt;data.key, 则查找成功，返回根结点地址</span>
        <span class="hljs-keyword">if</span> (root-&gt;data == key)
        {
            <span class="hljs-keyword">return</span> root;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; root-&gt;data)<span class="hljs-comment">//key小千T-&gt;data.key, 则递归查找左子树</span>
        {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBiSortTree</span>(root-&gt;lchild, key);
        }
        <span class="hljs-keyword">else</span><span class="hljs-comment">//key大千T-&gt;data.key, 则递归查找右子树</span>
        {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBiSortTree</span>(root-&gt;rchild, key);
        }
    }
</code></pre>
<ul>
<li>插入：将关键词为K的结点插入二叉查找树，插入后仍为二 叉查找树，若K已在树中，则该节点大小加一。</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">//当二叉排序树T中不存在关键字等千e.key的数据元素时,则插入该元素</span>
<span class="hljs-comment">//注意传入二级指针</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertBiSortTree</span><span class="hljs-params">(Tree&lt;T&gt;*&amp; root, T key)</span>
</span>{
    <span class="hljs-comment">//空树直接将其作为根节点</span>
    <span class="hljs-keyword">if</span> (!root)
    {
        Tree&lt;T&gt;* temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Tree</span>&lt;T&gt;(key);
        root = temp;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; root-&gt;data)<span class="hljs-comment">//将*S插入左子树</span>
    {
        <span class="hljs-built_in">InsertBiSortTree</span>(root-&gt;lchild, key);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;data &lt; key)<span class="hljs-comment">//将*S插入右子树</span>
    {
        <span class="hljs-built_in">InsertBiSortTree</span>(root-&gt;rchild, key);
    }
    <span class="hljs-keyword">else</span><span class="hljs-comment">//相等说明root存在相同关键字的结点,个数++</span>
    {
        root-&gt;count++;
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">//处理size,根的节点数等于左右子树和加上本身个数</span>
    root-&gt;size = root-&gt;count + (root-&gt;left ? root-&gt;left-&gt;size : <span class="hljs-number">0</span>) + (root-&gt;right ? root-&gt;right-&gt;size : <span class="hljs-number">0</span>);  <span class="hljs-comment">// 更新节点的子树大小</span>
    <span class="hljs-keyword">return</span>;
}
</code></pre>
<ul>
<li><strong>删除</strong>：删除关键词为K的结点（如果该结点大小大于一则大小减一），删除后仍为二叉查找树，采用代替法删除</li>
</ul>
</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">//二叉排序树的删除</span>
<span class="hljs-comment">//被删除的结点可能是二叉排序树中的任何结点</span>
<span class="hljs-comment">//删除结点后，要根据其位置不同修改其双亲结点及相关结点的指针，以保持二叉排序树的特性</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DeleteBST</span><span class="hljs-params">(Tree&lt;T&gt;*&amp; root, T key)</span><span class="hljs-comment">//因为可能删除根节点，所以传入二级指针</span>
</span>{
    <span class="hljs-comment">//空树</span>
    <span class="hljs-keyword">if</span> (!root)<span class="hljs-keyword">return</span>;

    <span class="hljs-comment">//初始化,目标结点和目标节点的父节点以便查找</span>
    Tree&lt;T&gt;* p = root;
    Tree&lt;T&gt;* pre = <span class="hljs-literal">nullptr</span>;

    <span class="hljs-comment">//查找</span>
    <span class="hljs-keyword">while</span> (p)
    {
        <span class="hljs-comment">//找到关键字等于key的结点* p, 结束循环</span>
        <span class="hljs-keyword">if</span> (p-&gt;data == key)<span class="hljs-keyword">break</span>;

        <span class="hljs-comment">//前移</span>
        pre = p;
        <span class="hljs-comment">//判断往左移还是右移</span>
        p = key &lt; p-&gt;data ? p-&gt;lchild : p-&gt;rchild;

    }

    <span class="hljs-comment">//找不到</span>
    <span class="hljs-keyword">if</span> (!p)<span class="hljs-keyword">return</span>;

    <span class="hljs-comment">//count大于1</span>
    <span class="hljs-keyword">if</span> (p-&gt;count &gt; <span class="hljs-number">1</span>)
    {
        p-&gt;count--;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">//考虑三种情况</span>

        <span class="hljs-comment">//q记录s的前驱</span>
        Tree&lt;T&gt;* q = p;
        Tree&lt;T&gt;* s = p-&gt;rchild;

        <span class="hljs-comment">//被删结点*p左右子树均不空</span>
        <span class="hljs-keyword">if</span> (p-&gt;lchild &amp;&amp; p-&gt;rchild)
        {

            <span class="hljs-comment">//在*p的左子树中继续查找其前驱结点，即最右下结点也是左子树最大节点用以代替被删除节点</span>
            <span class="hljs-comment">//或者找右子树最小节点代替</span>
            <span class="hljs-keyword">while</span> (s-&gt;rchild)
            {
                q = s;
                s = s-&gt;rchild;
            }

            <span class="hljs-comment">//s指向被删结点的 “前驱",以最大节点替换被删结点</span>
            p-&gt;data = s-&gt;data;

            <span class="hljs-comment">//重接*q的右子树</span>
            <span class="hljs-keyword">if</span> (q != p)<span class="hljs-comment">//避免q未移动</span>
            {
                <span class="hljs-comment">//s左子树的值依旧大于其前驱，并且s作为最大节点一定没有右子树了</span>
                q-&gt;rchild = s-&gt;lchild;
            }
            <span class="hljs-keyword">else</span><span class="hljs-comment">//重接*q的左子树,未移动则q即是被s替换的p</span>
            {
                q-&gt;lchild = s-&gt;lchild;
            }

            <span class="hljs-keyword">delete</span> s;
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!p-&gt;rchild)<span class="hljs-comment">//被删结点*p无右子树， 只需重接其左子树</span>
        {
            q = p;
            p = p-&gt;lchild;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;lchild)<span class="hljs-comment">//被删结点*p无左子树， 只需重接其右子树</span>
        {
            q = p;
            p = p-&gt;rchild;
        }

        <span class="hljs-comment">//将p所指的子树挂接到其双亲结点*f相应的位置</span>

        <span class="hljs-comment">//被删结点为根节点</span>
        <span class="hljs-keyword">if</span> (!pre)root = p;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q == pre-&gt;lchild)<span class="hljs-comment">//被删结点为前驱的左子树</span>
        {
            <span class="hljs-comment">//挂接到*f的左子树位置</span>
            pre-&gt;lchild = p;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-comment">//被删结点为前驱的左子树</span>
        {
            pre-&gt;rchild = p;
        }

        <span class="hljs-keyword">delete</span> q;
    }

    <span class="hljs-comment">//维护size</span>
    root-&gt;size = root-&gt;count + (root-&gt;left ? root-&gt;left-&gt;size : <span class="hljs-number">0</span>) + (root-&gt;right ? root-&gt;right-&gt;size : <span class="hljs-number">0</span>);  <span class="hljs-comment">// 更新节点的子树大小</span>

    <span class="hljs-keyword">return</span>;
}

<span class="hljs-comment">//递归版本，注意传入二级指针</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Tree&lt;T&gt;*&amp; root,T key)</span>
</span>{
    <span class="hljs-comment">//空树，或者找不到</span>
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)
    {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (root-&gt;data &lt; key)
    {
        <span class="hljs-built_in">remove</span>(root-&gt;rchild, key);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; root-&gt;data)
    {
        <span class="hljs-built_in">remove</span>(root-&gt;lchild, key);
    }
    <span class="hljs-keyword">else</span><span class="hljs-comment">//找到</span>
    {
        <span class="hljs-keyword">if</span> (root-&gt;count &gt; <span class="hljs-number">1</span>) {
            root-&gt;count--;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">//左子树为空</span>
            <span class="hljs-keyword">if</span> (root-&gt;lchild == <span class="hljs-literal">nullptr</span>)
            {
                Tree&lt;T&gt;* temp = root;
                root = root-&gt;rchild;
                <span class="hljs-keyword">delete</span> temp;
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">//右子树为空</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;rchild == <span class="hljs-literal">nullptr</span>) 
            {
                Tree&lt;T&gt;* temp = root;
                root = root-&gt;lchild;
                <span class="hljs-keyword">delete</span> temp;
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-comment">//找到继承者，即左子树最大节点或者右子树最小节点</span>
                Tree&lt;T&gt;* successor = <span class="hljs-built_in">findMax</span>(root-&gt;lchild);
                root-&gt;data = successor-&gt;data;
                root-&gt;count = successor-&gt;count;

                <span class="hljs-comment">// 当 successor-&gt;count &gt; 1时，也应该删除该节点，否则</span>
                <span class="hljs-comment">// 后续的删除只会减少重复数量</span>
                successor-&gt;count = <span class="hljs-number">1</span>;
                <span class="hljs-built_in">remove</span>(root-&gt;rchild, successor-&gt;data);
            }
        }
    }
    <span class="hljs-comment">// 继续维护size，不写成 --root-&gt;size;</span>
    <span class="hljs-comment">// 是因为value可能不在树中，从而可能未发生删除</span>
    root-&gt;size = root-&gt;count + (root-&gt;left ? root-&gt;left-&gt;size : <span class="hljs-number">0</span>) +(root-&gt;right ? root-&gt;right-&gt;size : <span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span>;
}
</code></pre>
<h3 id="avltree高度平衡树"><a name="avltree高度平衡树" class="anchor-navigation-ex-anchor" href="#avltree高度平衡树"><i class="fa fa-link" aria-hidden="true"></i></a>AVLTree(高度平衡树)</h3>
<ul>
<li>定义</li>
</ul>
<blockquote>
<p>[!note]</p>
<p>一棵满足如下条件的二叉查找树：任意结点的左子树和右子树的<strong>高度最多相差1</strong>。 </p>
<ul>
<li>即对于任意结点P，| P的左子树高度−P的右子树高度 | &lt;=1</li>
<li>AVL树中任意结点P的<strong>平衡系数(平衡因子）</strong>定义为：P的左子树高度减去右子树高度。从定义可知平衡系数只可能为：-1,0,1</li>
</ul>
</blockquote>
<ul>
<li>核心操作</li>
</ul>
<blockquote>
<p>[!important]</p>
<ul>
<li><p>查找：与普通二叉查找树一致。</p>
</li>
<li><p><strong>插入和删除</strong>：先使用二叉查找树的插入/删除方法，但插入/ 删除一个结点后，有可能破坏AVL树的平衡性。因此需对平衡树进行调整，恢复其平衡性，实现这种调整的操作称为“<strong>旋转（Rotation）</strong>”。</p>
<blockquote>
<ol>
<li>插入新结点X后，若AVL树失去平衡，应调整失去平衡的最小子树，即找从<strong>X到根结点的路径上的第一个失衡结点A</strong>， 平衡以 A为根的子树。</li>
<li>调整策略： ①LL型：右转  ②RR型：左转 ③LR型：左转+右转 ④RL型：右转+左转</li>
</ol>
</blockquote>
<p>对于插入：</p>
<blockquote>
<p>如何找从插入点到根结点的路径中第一个失衡结点A？ </p>
<p>➢ 从根到插入点（自顶向下）：通过递归过程实现； </p>
<p>➢ 从插入点到根（自底向上）：通过递归函数的<strong>返回过程（ 回溯）</strong>实现。在上一层递归函数返回后，检查当前结点的平衡性。</p>
<pre><code class="lang-cpp"> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(AVLnode* &amp;root, <span class="hljs-type">int</span> K)</span> </span>{
     <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">AVLnode</span>(K);
     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(K &lt; root-&gt;key)  <span class="hljs-comment">//在左子树插入</span>
            <span class="hljs-built_in">Insert</span>(root-&gt;left, K);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(K &gt; root-&gt;key)  <span class="hljs-comment">//在右子树插入</span>
            <span class="hljs-built_in">Insert</span>(root-&gt;right, K);
     <span class="hljs-built_in">ReBalance</span>(root);
 }

<span class="hljs-comment">//调整平衡</span>
 <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReBalance</span><span class="hljs-params">(AVLnode* &amp;t)</span> </span>{
     <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;
     <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Height</span>(t-&gt;left)- <span class="hljs-built_in">Height</span>(t-&gt;right)==<span class="hljs-number">2</span>){   
         <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Height</span>(t-&gt;left-&gt;left) &gt;= <span class="hljs-built_in">Height</span>(t-&gt;left-&gt;right)) 
            <span class="hljs-built_in">LL</span>(t);
         <span class="hljs-keyword">else</span>
             <span class="hljs-built_in">LR</span>(t);
     }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Height</span>(t-&gt;right)- <span class="hljs-built_in">Height</span>(t-&gt;left)==<span class="hljs-number">2</span>){
         <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Height</span>(t-&gt;right-&gt;right) &gt;= <span class="hljs-built_in">Height</span>(t-&gt;right-&gt;left))  
            <span class="hljs-built_in">RR</span>(t);
         <span class="hljs-keyword">else</span>
             <span class="hljs-built_in">RL</span>(t);
     }
     <span class="hljs-built_in">UpdateHeight</span>(t);
 }
</code></pre>
</blockquote>
<p>对于删除</p>
<blockquote>
<ol>
<li>二叉查找树的删除算法进行删除</li>
<li>沿实际删除点到根结点的路径，向上找第 一个不平衡点为A，平衡以 A为根的子树。</li>
<li>平衡后，可能使子树A高度变小。这样可能导致A的父结点 不满足平衡性。</li>
<li>要继续向上考察结点的平衡性，最远可能至根结点， 即最多需要做O(logn)次旋转</li>
</ol>
<pre><code class="lang-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(AVLnode* &amp;root, <span class="hljs-type">int</span> K)</span> </span>{
     <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;
     <span class="hljs-keyword">if</span>(K&lt;root-&gt;key) <span class="hljs-built_in">remove</span>(root-&gt;left, K);  <span class="hljs-comment">//在左子树删K</span>
     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(K&gt;root-&gt;key) <span class="hljs-built_in">remove</span>(root-&gt;right, K); <span class="hljs-comment">//在右子树删K</span>
     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right!=<span class="hljs-literal">NULL</span>){
            AVLnode *s=root-&gt;right;
             <span class="hljs-keyword">while</span>(s-&gt;left!=<span class="hljs-literal">NULL</span>) s=s-&gt;left;
            root-&gt;key=s-&gt;key;    <span class="hljs-comment">//s为t右子树中根序列第一个结点</span>
            <span class="hljs-built_in">remove</span>(root-&gt;right, s-&gt;key);
         }<span class="hljs-keyword">else</span>{ 
            AVLnode* oldroot=root;
             root=(root-&gt;left!=<span class="hljs-literal">NULL</span>)? root-&gt;left:root-&gt;right;
             <span class="hljs-keyword">delete</span> oldroot;
             }
     <span class="hljs-built_in">ReBalance</span>(root);
}
</code></pre>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li><p>总结</p>
<blockquote>
<ul>
<li>AVL树的高度为<strong>O(logn)</strong>，因此使插入、删除、查找的最坏时间复杂度均为O(logn)。</li>
<li>删除操作最坏情况下需要做O(logn)次旋转，即从删除节点一直维护平衡到根节点</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="红黑树（red-black-tree）"><a name="红黑树（red-black-tree）" class="anchor-navigation-ex-anchor" href="#红黑树（red-black-tree）"><i class="fa fa-link" aria-hidden="true"></i></a>红黑树（Red Black Tree）</h3>
<p>红黑树是一种<strong>自平衡</strong>的二叉搜索树。每个节点额外存储了一个 color 字段 ("RED" or "BLACK")，用于确保树在插入和删除时保持平衡。</p>
<blockquote>
<p>[!tip]</p>
<p>一棵合法的红黑树必须遵循以下五条性质：</p>
<ol>
<li><p>节点为红色或黑色(<strong>非红即黑</strong>)</p>
</li>
<li><p>NIL 节点（空叶子节点或者说外结点）为黑色（<strong>黑外</strong>）</p>
</li>
<li><p>红色节点的子节点为黑色（<strong>红父黑子</strong>）</p>
</li>
<li><p>从根节点到 NIL 节点的每条路径上的黑色节点数量相同</p>
</li>
<li><p>根结点为黑色； （<strong>黑根</strong>）</p>
<blockquote>
<p>这条性质要求完成插入操作后若根节点为红色则将其染黑，但由于将根节点染黑的操作也可以延迟至删除操作时进行，因此，该条性质并非必须满足。</p>
</blockquote>
</li>
</ol>
</blockquote>
<ul>
<li><p>红黑树类的定义</p>
<blockquote>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> Value, <span class="hljs-keyword">typename</span> Compare = std::less&lt;Key&gt;&gt;
<span class="hljs-keyword">class</span> RBTreeMap {
  <span class="hljs-comment">// 排序函数</span>
  Compare compare = <span class="hljs-built_in">Compare</span>();

  <span class="hljs-comment">// 节点结构体</span>
  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {
      std::shared_ptr&lt;Node&gt; parent,left,right;
      <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">color</span>{BLACL,RED};
      Key key;
      Value value;
  };

  <span class="hljs-comment">// 根节点指针</span>
  Node* root = <span class="hljs-literal">nullptr</span>;
  <span class="hljs-comment">// 记录红黑树中当前的节点个数</span>
  <span class="hljs-type">size_t</span> count = <span class="hljs-number">0</span>;
}
</code></pre>
</blockquote>
</li>
</ul>
<hr></hr>
<h3 id="splay-树"><a name="splay-树" class="anchor-navigation-ex-anchor" href="#splay-树"><i class="fa fa-link" aria-hidden="true"></i></a>Splay 树</h3>
<blockquote>
<p>[!note]</p>
<p><strong>Splay 树</strong>, 或 <strong>伸展树</strong>，是一种<strong>平衡二叉查找树</strong></p>
<p>它通过 <strong>Splay/伸展操作</strong> 不断将某个节点<strong>旋转到根节点</strong>，使得整棵树仍然满足二叉查找树的性质，能够在均摊 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="O(\log N)"></img> 时间内完成插入，查找和删除操作，并且保持平衡而不至于退化为链。</p>
</blockquote>
<ul>
<li>结构</li>
</ul>
<blockquote>
<p>Splay 树是一棵二叉搜索树，查找某个值时满足性质：</p>
<p>左子树任意节点的值 &lt; 根节点的值 &lt; 右子树任意节点的值。</p>
<h3 id="节点维护信息"><a name="节点维护信息" class="anchor-navigation-ex-anchor" href="#节点维护信息"><i class="fa fa-link" aria-hidden="true"></i></a>节点维护信息</h3>
<table>
<thead>
<tr>
<th style="text-align:center">rt</th>
<th style="text-align:center">tot</th>
<th style="text-align:center">fa[i]</th>
<th style="text-align:center">ch[i][0/1]</th>
<th style="text-align:center">val[i]</th>
<th style="text-align:center">cnt[i]</th>
<th style="text-align:center">sz[i]</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">根节点编号</td>
<td style="text-align:center">节点个数</td>
<td style="text-align:center">父亲</td>
<td style="text-align:center">左右儿子编号</td>
<td style="text-align:center">节点权值</td>
<td style="text-align:center">权值出现次数</td>
<td style="text-align:center">子树大小</td>
</tr>
</tbody>
</table>
</blockquote>
<ul>
<li><p>旋转操作</p>
<blockquote>
<p>为了使 Splay 保持平衡而进行旋转操作，旋转的本质是将某个节点上移一个位置。</p>
<p><strong>旋转需要保证</strong>：</p>
<ul>
<li>整棵 Splay 的中序遍历不变（不能破坏二叉查找树的性质）。</li>
<li>受影响的节点维护的信息依然正确有效。</li>
<li><code>root</code> 必须指向旋转后的根节点。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="b树（b-tree）"><a name="b树（b-tree）" class="anchor-navigation-ex-anchor" href="#b树（b-tree）"><i class="fa fa-link" aria-hidden="true"></i></a>B树（B-Tree）</h3>
<blockquote>
<p>[!note]</p>
<p>B树：平衡m叉查找树。</p>
<p>一个结点存<strong>多个关键词</strong>，形成多叉查找树来代替 二叉查找树，降低查找树高度。 </p>
</blockquote>
<ul>
<li><p>B树结点结构</p>
<blockquote>
<ol>
<li>包含j个关键词：满足 <code>K1&lt;K2&lt;...&lt;Kj</code>。</li>
<li>包含j+1个指针：第i个指针pi（0 &lt; i &lt;j）指向的子树所包含关键词都在Ki和Ki+1之间</li>
</ol>
<p><img src="assets/image-20250228203936993-1740746379893-1.png" alt="image-20250228203936993"></img></p>
</blockquote>
</li>
<li><p>m阶B树的定义</p>
<blockquote>
<ul>
<li>① 每个结点至多有m个孩子； </li>
<li>② 除根和叶结点外，每个结点至少有[m/2]取下界个孩子； </li>
<li>③ 若根结点不是叶结点，则至少有2个孩子； </li>
<li>④ 有k个孩子的结点恰好包含k-1个递增有序的关键词； </li>
<li>⑤ 所有的叶结点在同一层，不包含任何信息。</li>
</ul>
<blockquote>
<p>[!important]</p>
<p>根和叶以外的结点有<strong>[m/2]取下界～m个孩子</strong></p>
<p>根结点有<strong>2 ～m个孩子</strong></p>
</blockquote>
</blockquote>
</li>
</ul>
<blockquote>
<p>在 B 树中，有两种节点：</p>
<ol>
<li>内部节点（internal node）：存储了数据以及指向其子节点的指针。</li>
<li>叶子节点（leaf node）：与内部节点不同的是，叶子节点只存储数据，并没有子节点。是虚拟的结点</li>
<li>指向叶结点的指针是空指针</li>
</ol>
</blockquote>
<ul>
<li><p>B树的查找</p>
<blockquote>
<p> ①在根结点内查找K，即在其所包含的关键词K1 ,…, Kj 中查找 K（可采用顺序查找或对半查找），<strong>找到则查找成功</strong>； </p>
<p>②否则，确定K在<strong>某个Ki 和Ki+1 之间</strong>，于是在指针pi 所指向的 子树里继续查找K，即将pi 所指向的结点读入内存，继续查 找；如果pi 为空，则查找失败。</p>
</blockquote>
</li>
<li><p>B树的插入</p>
<blockquote>
<p>先查找，在查找失败的位置插入。</p>
<p>若在结点中插入关键词后，结点包含的关键词超过m-1个， 则该结点关键词上溢，需进行分裂操作。</p>
</blockquote>
</li>
<li><p>B树的删除</p>
<blockquote>
<p>类似于二叉查找树的删除</p>
<p>但是当删除关键词后，若该结点目前包含的关键词个数小于[m/2]-1 称为下溢，则从左（右）兄弟结点中借最大（最小）关键词。</p>
</blockquote>
</li>
</ul>
<h3 id="b-树"><a name="b-树" class="anchor-navigation-ex-anchor" href="#b-树"><i class="fa fa-link" aria-hidden="true"></i></a>B+ 树</h3>
<blockquote>
<p>① 每个结点至多有m个子结点； </p>
<p>② 除根结点外，其它每个非叶结点至少有m/2个子结点；</p>
<p> ③ 根结点至少有两个子结点； </p>
<p>④ 包含n个孩子的结点有n个关键词（即每个关键词对应一棵子 树）； </p>
<p>⑤ 每个非叶结点仅包含各孩子的最大关键词及指向各孩子的指 针（每个非叶结点不存放实际的数据记录，可看成索引）； </p>
<p>⑥ 所有叶结点包含全部关键词及指向相应数据记录的指针，且 <strong>叶结点按关键词递增的顺序连成一个链表</strong>（每个叶结点的指 针指向磁盘上实际数据文件中的记录，也可看成索引）。</p>
<p><img src="assets/image-20250228204941576-1740746982729-3-1740746984248-5.png" alt="image-20250228204941576"></img></p>
<p>[!warning]</p>
<p> B树：每个结点存储关键词及其 对应的<strong>实际数据 记录</strong>（或指针）</p>
<p>B+树：只存关键词</p>
</blockquote>
<hr></hr>
<h2 id="散列查找"><a name="散列查找" class="anchor-navigation-ex-anchor" href="#散列查找"><i class="fa fa-link" aria-hidden="true"></i></a>散列查找</h2>
<h3 id="散列（hash-亦称哈希、杂凑）"><a name="散列（hash-亦称哈希、杂凑）" class="anchor-navigation-ex-anchor" href="#散列（hash-亦称哈希、杂凑）"><i class="fa fa-link" aria-hidden="true"></i></a>散列（Hash, 亦称哈希、杂凑）</h3>
<blockquote>
<p>[!note]</p>
<p>哈希表又称散列表，一种以「key-value」形式存储数据的数据结构。</p>
<p>所谓以「key-value」形式存储数据，是指任意的键值 key 都唯一对应到内存中的某个位置。只需要输入查找的键值，就可以快速地找到其对应的 value。</p>
<p>可以把哈希表理解为一种高级的数组，这种数组的下标可以是很大的整数，浮点数，字符串甚至结构体。</p>
</blockquote>
<h4 id="哈希函数"><a name="哈希函数" class="anchor-navigation-ex-anchor" href="#哈希函数"><i class="fa fa-link" aria-hidden="true"></i></a>哈希函数</h4>
<blockquote>
<p>✓自变量K：关键词 </p>
<p>✓函数值h(K)：元素在散列表中的存 储地址（亦称散列地址） </p>
<p>✓作用：把关键词值<strong>映射</strong>到散列地址</p>
<p>哈希函数应当易于计算，并且尽量使计算出来的<strong>索引均匀分布</strong>。</p>
</blockquote>
<h4 id="冲突"><a name="冲突" class="anchor-navigation-ex-anchor" href="#冲突"><i class="fa fa-link" aria-hidden="true"></i></a>冲突</h4>
<blockquote>
<p>[!warning]</p>
<p>多个不同的关键词具有<strong>相同的散列函数值</strong>， 即<code>K1!=K2, h(K1)=h(K2)</code></p>
</blockquote>
<ul>
<li><p>一些方法来处理冲突</p>
</li>
<li><p>拉链法</p>
<blockquote>
<p>拉链法也称开散列法（open hashing）。</p>
<p>拉链法是在每个存放数据的地方开一个<strong>链表</strong>，如果有多个键值索引到同一个地方，只用把他们都放到那个位置的链表里就行了。查询的时候需要把对应位置的链表整个扫一遍，对其中的每个数据比较其键值与查询的键值是否一致。</p>
<p><strong>若链表很长，可将其替代为跳表或查找树</strong></p>
</blockquote>
</li>
<li><p>闭散列法</p>
</li>
</ul>
<blockquote>
<p>闭散列方法把所有记录<strong>直接存储在散列表</strong>中，如果发生冲突则根据某种方式继续进行探查。</p>
<ol>
<li>线性探查（亦称线性探测）:当发生冲突时，以固定的次序查找表中的记录，直到<strong>找到一个关键词为K的结点或者找到一个空位置</strong>。</li>
<li>二次探查: 一旦冲突，能更快的跳离“是非之地”，避免聚集</li>
<li>双重探查：从h(K)开始，寻找空地址时，所前进的<strong>步长不是固定</strong>的，而与K有关，</li>
</ol>
</blockquote>
<h4 id="散列表的删除"><a name="散列表的删除" class="anchor-navigation-ex-anchor" href="#散列表的删除"><i class="fa fa-link" aria-hidden="true"></i></a>散列表的删除</h4>
<ul>
<li><p>懒惰删除</p>
<blockquote>
<p>并不真正的删除元素，而是将删除的位置做一个<strong>标记</strong>，其状态置为“已删除”</p>
</blockquote>
</li>
<li><p>实时删除</p>
<blockquote>
<p>将位置j清空，然后考察位置j+1到下一个空位前的每一个位置i，看将位置j清空后，<strong>是否阻碍</strong>查找T[i]的探查路 径，若是则将T[i]前移至空位。</p>
</blockquote>
</li>
<li><p>延迟删除</p>
<blockquote>
<p>每隔一段时间<strong>定期执行一次真正删除</strong>， 把标记为“已删除”的结点真正清空</p>
</blockquote>
</li>
</ul>
<hr></hr>
<p></p><footer class="page-footer" style="font-size:1.0rem;"><span class="copyright">©<a href="https://jlu005807.github.io/" target="_blank">OZY</a> all right reserved</span><span class="footer-modification">该文件修订时间：
2025-09-20 05:42:10
</span></footer><script>window.__tbfed_pagefooter_config = {"theme_colors":{"color-theme-1":"#000000ff","color-theme-2":"#d9d9d9ff"}};</script><script src="./gitbook/honkit-plugin-tbfed-pagefooter/footer-theme.js"></script><p></p>
<!-- Giscus 评论组件开始 - 2025-09-20T05:42:19.832Z -->
<p><script type="text/javascript">
/* Giscus Theme Mapping and Config */
window.giscusThemeMapping = {"color-theme-1":"gruvbox","color-theme-2":"dark_dimmed","default":"light","sepia":"preferred_color_scheme","night":"dark_dimmed","white":"light"};
window.giscusConfig = {"repo":"jlu005807/docs.ozy","repoId":"R_kgDOPrTeig","category":"General","categoryId":"DIC_kwDOPrTeis4CvFgy","mapping":"pathname","strict":"1","reactionsEnabled":"1","emitMetadata":"0","inputPosition":"bottom","theme":"light","lang":"zh-CN","loading":"eager"};
</script></p>
<p></p><div id="giscus-container" style="margin-top: 50px; padding: 10px; border-top: 1px solid #eaecef;"><div class="giscus-page-info" style="margin-bottom: 15px; font-size: 0.9em; color: #666;">评论区 - 09_Search</div>
<!-- giscus client.js will be inserted by giscus-theme-switcher.js --><p></p>
<!-- Giscus 评论组件结束 --></div></body></html>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="08_Sort.html" class="navigation navigation-prev " aria-label="Previous page: 08_Sort">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="data_structure.html" class="navigation navigation-next " aria-label="Next page: data_structure">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"09_Search","level":"1.3.1.9","depth":3,"next":{"title":"data_structure","level":"1.3.1.10","depth":3,"path":"docs/DataStructure_and_Algorithms/Data_structure/data_structure.md","ref":"docs/DataStructure_and_Algorithms/Data_structure/data_structure.md","articles":[]},"previous":{"title":"08_Sort","level":"1.3.1.8","depth":3,"path":"docs/DataStructure_and_Algorithms/Data_structure/08_Sort.md","ref":"docs/DataStructure_and_Algorithms/Data_structure/08_Sort.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-lunr","-search","-sharing","search-pro","chapter-fold","expandable-chapters","anchor-navigation-ex","code","page-treeview-simple","flexible-alerts","versions-select","tbfed-pagefooter","add-giscus"],"styles":{"website":"styles/website.css","ebook":"styles/website.css","pdf":"styles/website.css","mobi":"styles/website.css","epub":"styles/website.css"},"pluginsConfig":{"tbfed-pagefooter":{"copyright":"&copy;<a href=\"https://jlu005807.github.io/\">OZY</a>","show_modify_time":true,"font_size":"1.0rem","modify_label":"该文件修订时间：","modify_format":"YYYY-MM-DD HH:mm:ss","show_power":false,"hover":true},"chapter-fold":{},"search-pro":{},"code":{"copyButtons":true},"versions-select":{"type":"branches"},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"anchor-navigation-ex":{"showLevel":false,"associatedWithSummary":true,"mode":"float","showGoTop":true,"printLog":false,"multipleH1":true,"float":{"floatIcon":"fa fa-navicon","showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""},"pageTop":{"showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""}},"flexible-alerts":{"style":"callout","note":{"label":"Note","icon":"fa fa-info-circle","className":"info"},"tip":{"label":"Tip","icon":"fa fa-lightbulb-o","className":"tip"},"warning":{"label":"Warning","icon":"fa fa-exclamation-triangle","className":"warning"},"danger":{"label":"Attention","icon":"fa fa-ban","className":"danger"}},"versions":{"options":[{"value":"https://jlu005807.github.io/docs.ozy","text":"docs.ozy","selected":true},{"value":"https://jlu005807.github.io/","text":"github.io.ozy"}]},"add-giscus":{"repo":"jlu005807/docs.ozy","repoId":"R_kgDOPrTeig","category":"General","categoryId":"DIC_kwDOPrTeis4CvFgy","theme_config":{"default":"light","color-theme-1":"gruvbox","color-theme-2":"dark_dimmed"}},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"page-treeview-simple":{"copyright":"Copyright © aleen42","minHeaderCount":"1","minHeaderDeep":"1","collapsed":false},"expandable-chapters":{}},"theme":"default","author":"ozy","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"docs.ozy","language":"zh-hans","gitbook":"3.2.3","description":"我的文档站点"},"file":{"path":"docs/DataStructure_and_Algorithms/Data_structure/09_Search.md","mtime":"2025-09-20T05:42:10.341Z","type":"markdown"},"gitbook":{"version":"6.0.4","time":"2025-09-20T05:42:17.534Z"},"basePath":"../../..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../../../gitbook/gitbook.js"></script>
    <script src="../../../gitbook/theme.js"></script>
    
        
        <script src="../../../gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-search-pro/search.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-chapter-fold/chapter-fold.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-code/plugin.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-flexible-alerts/plugin.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-versions-select/plugin.js"></script>
        
    
        
        <script src="../../../gitbook/honkit-plugin-add-giscus/giscus-theme-switcher.js"></script>
        
    
        
        <script src="../../../gitbook/@honkit/honkit-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

