# 编程泛型(10个)

面向+**对象, 方面, 表格**+编程

**过程+命令+函数**+编程

**流程+消息**+驱动编程

**泛型+结构化**+编程

##### 编程泛型和C++语言

一种编程范型可以被多种语言支持, 一种语言也可以支持多种编程范型.

##### 集成开发环境(记住顺序) :

集成代码 编辑、编译、运行、调试、测试、发布等

## C++项目(工程）的组成: 

实现文件cpp, 头文件hpp, h

库文件, 可执行文件(dll, lib, exe), 资源文件(rc, res)

数据文件(XML, dat), 其他...

编译为: exe, dll, lib

# 预处理

处理源代码中的带有**#**号的语句，生成编译程序可处理的文本文件；

# 编译过程：

对每个预处理后源程序，编译并生成相应的二进制目标文件(object文件)。此过程中，仅要求编译器能够**识别每个标识符，知道其各自的类型、含义**，但不要求知道存放位置.

# 链接过程：

对在整个程序范围内，确定各标志符所代表的**地址**，如变量、函数入口(找到main函数)，生成可执行文件。此过程中，要求编译器能够确定每个标识符所对应的含义或地址。

> [!NOTE]
>
> 1. C++的编译是以实现文件(.cpp文件)为**基本编译单位**的；
> 2. 预编译、编译和链接过程，有时我们**统称编译过程**；
> 3. 各阶段均无错误，才能生成可执行文件；
> 4. 即使生成了可执行文件，不代表程序就正确；
> 5. 让编译过程通过，是相对简单的；真正困难的是调试逻辑错误

# 入口函数:

# 预备知识（第1–3章要点）

本文档提取常见的语言基础、构建流程和工程约定，作为快速参考：编译流程、项目组织、声明/定义、存储与作用域、typedef/枚举等。

## 编程范式简述

- 面向对象（OOP）：类/对象、继承、多态；
- 过程式：函数/模块为中心；
- 事件/消息驱动：以事件循环和回调为主；
- 泛型/模板编程：类型参数化，实现可复用的算法与容器；

一门语言可以支持多种范式，C++ 就是典型的多范式语言。

## C++ 项目基本组成

- 源文件：`.cpp/.c`（实现）
- 头文件：`.h/.hpp`（声明与接口）
- 库：`.lib`/`.a`（静态），`.dll`/`.so`（动态）
- 可执行文件：`.exe` 等
- 资源/数据：图像、配置、XML/JSON 等

常见工具链：`gcc/clang/MSVC` + `make` / `ninja` / CMake 用于生成构建系统。

## 编译流程（高层）

1. 预处理（Preprocessing）：处理 `#include`, `#define` 等，展开为单一翻译单元；
2. 编译（Compilation）：将翻译单元编译为目标文件 `.o/.obj`；
3. 链接（Linking）：将目标文件与库合并，解析符号，生成可执行文件或库。

要点：编译器在编译阶段只需知道符号的类型和声明，链接阶段负责把符号绑定到具体地址。

## 程序入口

标准可执行程序入口为：

```cpp
int main(int argc, char* argv[]) {
    // ...
}
```

（注意：不要依赖非标准的 `void main()`。）

## 头文件、声明与定义

- 头文件应放声明（函数原型、类定义、常量声明、模板实现可放头文件）；
- 头文件不应放非 `inline` 的函数定义或非 `inline` 的全局变量定义（否则会违反 ODR）；
- 使用 include guard 或 `#pragma once` 防止重复包含，但仍需避免在头中放置会导致多重定义的实体。

示例：

```cpp
// header.h
void f(); // 声明

// source.cpp
#include "header.h"
void f() { /* 定义 */ }
```



## 抽象数据类型（ADT）

ADT = 数据集合 + 对其施加的操作。类是实现 ADT 的常见方式。

## typedef / using

`typedef` 与 `using`（C++11）用于创建类型别名：

```cpp
typedef int (*FuncPtr)(int,int);
using FuncPtr2 = int(*)(int,int);

int add(int a, int b){ return a+b; }
FuncPtr f = add; // 调用 f(1,2)
```

`using` 在模板别名时更表达性强，推荐在新代码中使用 `using`。

## 枚举（enum）

- C++98: `enum E { A, B, C };`（枚举值与整数可互转，可能导致命名污染）；
- C++11: `enum class E : int { A, B, C };`（强类型、作用域内名字、推荐使用）。

示例：

```cpp
enum class Day : int { Monday=1, Tuesday, Wednesday };
Day d = Day::Monday;
int v = static_cast<int>(d);
```

## 声明与定义（要点）

- 声明（declaration）：告诉编译器符号的类型与接口；
- 定义（definition）：为符号分配存储或提供实现（函数体、非-inline 变量等）。

遵循“先声明后使用”和“一处定义，多处声明”的原则。



## 存储区与生命周期

常见区域：
- 全局/静态区（static storage）：程序启动时分配，结束时释放；
- 常量区：只读常量等；
- 代码区：程序指令；
- 栈（自动存储）：局部变量，随函数调用创建/销毁；
- 堆：动态分配，程序员管理（`new` / `delete` 或智能指针）。

## 作用域与链接性

- 文件作用域（static 修饰的全局）：仅在该翻译单元可见；
- 外部链接（extern）：符号可在多个翻译单元间共享；
- 局部作用域：块作用域、函数作用域、类作用域等。

示例（extern）：

```cpp
// a.cpp
int a = 10; // 定义

// b.cpp
extern int a; // 声明
```



## 包含（include）注意事项

- 头文件中避免 `using namespace std;`，避免把名字污染到所有包含者；
- 将实现（非 inline）放入 `.cpp`，在头中放声明；
- `#pragma once` 与 include guard 都是防重复包含的手段，但不能掩盖头文件设计上的多重定义问题。

示例：错误的头文件（会导致链接错误）不应包含非-inline 函数定义。

## 其他要点

- C++ 是编译型语言：代码需先编译为目标文件再链接生成可执行文件；
- Build 工具（Make/CMake/Ninja）能大幅提升构建效率并管理依赖关系；

---

如果你确认，我会现在读取并重写你当前打开的 `chapter19-20.md`（按目录顺序继续），生成更清晰的章节并保留图片引用。
}

